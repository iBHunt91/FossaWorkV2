#!/usr/bin/env python3
"""
FossaWork V2 Vulnerability Scanner
Custom vulnerability detection and analysis
"""

import ast
import asyncio
import hashlib
import json
import os
import re
import subprocess
import sys
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Any, Optional, Tuple
import sqlite3
import tempfile

class VulnerabilityScanner:
    """Comprehensive vulnerability detection framework"""
    
    def __init__(self, project_root: str):
        self.project_root = Path(project_root)
        self.backend_path = self.project_root / "backend"
        self.frontend_path = self.project_root / "frontend"
        self.scan_results = {
            "timestamp": datetime.now().isoformat(),
            "version": "2.0.0",
            "vulnerabilities": [],
            "statistics": {},
            "risk_score": 0
        }
        
        # Vulnerability patterns
        self.sql_injection_patterns = [
            r'.*\+.*["\'].*SELECT.*["\']',
            r'.*f["\'].*SELECT.*{.*}.*["\']',
            r'.*%.*["\'].*SELECT.*["\']',
            r'.*\.format\(.*SELECT.*\)',
            r'cursor\.execute\(["\'].*\+.*["\']',
        ]
        
        self.xss_patterns = [
            r'innerHTML\s*=\s*.*\+',
            r'document\.write\s*\(',
            r'eval\s*\(',
            r'dangerouslySetInnerHTML',
        ]
        
        self.command_injection_patterns = [
            r'os\.system\s*\(',
            r'subprocess\.call\s*\(',
            r'subprocess\.run\s*\(',
            r'eval\s*\(',
            r'exec\s*\(',
            r'execfile\s*\(',
        ]
        
        self.path_traversal_patterns = [
            r'\.\./',
            r'\.\.\\\\'
            r'os\.path\.join\s*\(.*\.\.',
            r'open\s*\(.*\.\.',
        ]
        
        # Sensitive data patterns
        self.sensitive_patterns = {
            'api_key': r'api[_-]?key\s*[:=]\s*["\'][^"\']{10,}["\']',
            'password': r'password\s*[:=]\s*["\'][^"\']{3,}["\']',
            'secret': r'secret\s*[:=]\s*["\'][^"\']{10,}["\']',
            'token': r'token\s*[:=]\s*["\'][^"\']{10,}["\']',
            'private_key': r'private[_-]?key\s*[:=]\s*["\'][^"\']{10,}["\']',
            'database_url': r'(mysql|postgresql|mongodb)://[^"\'\\s]+',
        }
        
        # Crypto vulnerability patterns
        self.crypto_weak_patterns = {
            'md5': r'hashlib\.md5\(',
            'sha1': r'hashlib\.sha1\(',
            'des': r'DES\.',
            'rc4': r'RC4\.',
            'weak_random': r'random\.random\(',
        }
        
    async def run_comprehensive_scan(self) -> Dict[str, Any]:
        """Run complete vulnerability scan"""
        print("üîç Starting Comprehensive Vulnerability Scan...")
        
        # Static Code Analysis
        await self._scan_static_vulnerabilities()
        
        # Dependency Vulnerabilities
        await self._scan_dependency_vulnerabilities()
        
        # Configuration Vulnerabilities
        await self._scan_configuration_vulnerabilities()
        
        # Database Vulnerabilities
        await self._scan_database_vulnerabilities()
        
        # Cryptographic Vulnerabilities
        await self._scan_cryptographic_vulnerabilities()
        
        # Authentication Vulnerabilities
        await self._scan_authentication_vulnerabilities()
        
        # Authorization Vulnerabilities
        await self._scan_authorization_vulnerabilities()
        
        # Input Validation Vulnerabilities
        await self._scan_input_validation_vulnerabilities()
        
        # Session Management Vulnerabilities
        await self._scan_session_vulnerabilities()
        
        # Information Disclosure Vulnerabilities
        await self._scan_information_disclosure()
        
        # Business Logic Vulnerabilities
        await self._scan_business_logic_vulnerabilities()
        
        # Calculate statistics and risk score
        self._calculate_statistics()
        
        return self.scan_results
    
    async def _scan_static_vulnerabilities(self):
        """Scan for static code vulnerabilities"""
        print("üîç Scanning Static Code Vulnerabilities...")
        
        # Scan Python files
        for file_path in self.backend_path.rglob("*.py"):
            await self._scan_python_file(file_path)
        
        # Scan TypeScript/JavaScript files
        for file_path in self.frontend_path.rglob("*.tsx"):
            await self._scan_typescript_file(file_path)
        
        for file_path in self.frontend_path.rglob("*.ts"):
            await self._scan_typescript_file(file_path)
    
    async def _scan_python_file(self, file_path: Path):
        """Scan individual Python file for vulnerabilities"""
        try:
            content = file_path.read_text()
            relative_path = file_path.relative_to(self.project_root)
            
            # SQL Injection
            await self._check_sql_injection(content, relative_path)
            
            # Command Injection
            await self._check_command_injection(content, relative_path)
            
            # Path Traversal
            await self._check_path_traversal(content, relative_path)
            
            # Hardcoded Secrets
            await self._check_hardcoded_secrets(content, relative_path)
            
            # Weak Cryptography
            await self._check_weak_cryptography(content, relative_path)
            
            # Unsafe Deserialization
            await self._check_unsafe_deserialization(content, relative_path)
            
            # Debug Code
            await self._check_debug_code(content, relative_path)
            
            # AST Analysis
            await self._analyze_python_ast(content, relative_path)
            
        except Exception as e:
            self._add_vulnerability(
                "LOW", "ANALYSIS_ERROR", f"Could not analyze {file_path}: {e}",
                str(file_path.relative_to(self.project_root)), 0
            )
    
    async def _scan_typescript_file(self, file_path: Path):
        """Scan individual TypeScript file for vulnerabilities"""
        try:
            content = file_path.read_text()
            relative_path = file_path.relative_to(self.project_root)
            
            # XSS vulnerabilities
            await self._check_xss_vulnerabilities(content, relative_path)
            
            # Client-side secrets
            await self._check_client_secrets(content, relative_path)
            
            # Unsafe DOM manipulation
            await self._check_unsafe_dom(content, relative_path)
            
            # Prototype pollution
            await self._check_prototype_pollution(content, relative_path)
            
            # Weak client validation
            await self._check_client_validation(content, relative_path)
            
        except Exception as e:
            self._add_vulnerability(
                "LOW", "ANALYSIS_ERROR", f"Could not analyze {file_path}: {e}",
                str(file_path.relative_to(self.project_root)), 0
            )
    
    async def _check_sql_injection(self, content: str, file_path: Path):
        """Check for SQL injection vulnerabilities"""
        for i, line in enumerate(content.split('\n'), 1):
            for pattern in self.sql_injection_patterns:
                if re.search(pattern, line, re.IGNORECASE):
                    self._add_vulnerability(
                        "CRITICAL", "SQL_INJECTION", 
                        f"Potential SQL injection in string concatenation: {line.strip()}",
                        str(file_path), i, 9.0
                    )
    
    async def _check_command_injection(self, content: str, file_path: Path):
        """Check for command injection vulnerabilities"""
        for i, line in enumerate(content.split('\n'), 1):
            for pattern in self.command_injection_patterns:
                if re.search(pattern, line):
                    # Check if input is properly validated
                    if not self._has_input_validation(line):
                        severity = "CRITICAL" if "os.system" in line else "HIGH"
                        score = 9.0 if severity == "CRITICAL" else 7.0
                        
                        self._add_vulnerability(
                            severity, "COMMAND_INJECTION",
                            f"Potential command injection: {line.strip()}",
                            str(file_path), i, score
                        )
    
    async def _check_path_traversal(self, content: str, file_path: Path):
        """Check for path traversal vulnerabilities"""
        for i, line in enumerate(content.split('\n'), 1):
            for pattern in self.path_traversal_patterns:
                if re.search(pattern, line):
                    self._add_vulnerability(
                        "HIGH", "PATH_TRAVERSAL",
                        f"Potential path traversal: {line.strip()}",
                        str(file_path), i, 7.5
                    )
    
    async def _check_hardcoded_secrets(self, content: str, file_path: Path):
        """Check for hardcoded secrets"""
        for secret_type, pattern in self.sensitive_patterns.items():
            for match in re.finditer(pattern, content, re.IGNORECASE):
                line_num = content[:match.start()].count('\n') + 1
                
                # Skip if it's in a test file or comment
                if 'test' in str(file_path).lower() or match.group().strip().startswith('#'):
                    continue
                
                self._add_vulnerability(
                    "CRITICAL", "HARDCODED_SECRET",
                    f"Hardcoded {secret_type} detected: {match.group()[:50]}...",
                    str(file_path), line_num, 8.5
                )
    
    async def _check_weak_cryptography(self, content: str, file_path: Path):
        """Check for weak cryptographic implementations"""
        for crypto_type, pattern in self.crypto_weak_patterns.items():
            for match in re.finditer(pattern, content):
                line_num = content[:match.start()].count('\n') + 1
                
                severity = "HIGH" if crypto_type in ['md5', 'sha1'] else "MEDIUM"
                score = 7.0 if severity == "HIGH" else 5.0
                
                self._add_vulnerability(
                    severity, "WEAK_CRYPTOGRAPHY",
                    f"Weak cryptographic algorithm: {crypto_type}",
                    str(file_path), line_num, score
                )
    
    async def _check_unsafe_deserialization(self, content: str, file_path: Path):
        """Check for unsafe deserialization"""
        unsafe_patterns = [
            r'pickle\.loads?\(',
            r'cPickle\.loads?\(',
            r'yaml\.load\(',
            r'eval\(',
            r'exec\(',
        ]
        
        for i, line in enumerate(content.split('\n'), 1):
            for pattern in unsafe_patterns:
                if re.search(pattern, line):
                    self._add_vulnerability(
                        "HIGH", "UNSAFE_DESERIALIZATION",
                        f"Unsafe deserialization: {line.strip()}",
                        str(file_path), i, 8.0
                    )
    
    async def _check_debug_code(self, content: str, file_path: Path):
        """Check for debug code in production"""
        debug_patterns = [
            r'print\s*\(',
            r'console\.log\(',
            r'debug\s*=\s*True',
            r'DEBUG\s*=\s*True',
            r'pdb\.set_trace\(',
            r'debugger;',
        ]
        
        for i, line in enumerate(content.split('\n'), 1):
            for pattern in debug_patterns:
                if re.search(pattern, line):
                    self._add_vulnerability(
                        "LOW", "DEBUG_CODE",
                        f"Debug code detected: {line.strip()}",
                        str(file_path), i, 2.0
                    )
    
    async def _analyze_python_ast(self, content: str, file_path: Path):
        """Analyze Python AST for complex vulnerabilities"""
        try:
            tree = ast.parse(content)
            
            for node in ast.walk(tree):
                # Check for dangerous function calls
                if isinstance(node, ast.Call):
                    await self._analyze_function_call(node, file_path, content)
                
                # Check for string operations
                if isinstance(node, ast.BinOp) and isinstance(node.op, ast.Add):
                    await self._analyze_string_concatenation(node, file_path, content)
                
        except SyntaxError:
            # Skip files with syntax errors
            pass
        except Exception as e:
            # Log but don't fail
            pass
    
    async def _analyze_function_call(self, node: ast.Call, file_path: Path, content: str):
        """Analyze function calls for vulnerabilities"""
        if isinstance(node.func, ast.Attribute):
            func_name = f"{node.func.value.id if hasattr(node.func.value, 'id') else ''}.{node.func.attr}"
        elif isinstance(node.func, ast.Name):
            func_name = node.func.id
        else:
            return
        
        # Check for dangerous function calls
        dangerous_functions = {
            'eval': 'CODE_EXECUTION',
            'exec': 'CODE_EXECUTION',
            'os.system': 'COMMAND_INJECTION',
            'subprocess.call': 'COMMAND_INJECTION',
            'open': 'FILE_ACCESS',
        }
        
        for dangerous_func, vuln_type in dangerous_functions.items():
            if dangerous_func in func_name:
                line_num = getattr(node, 'lineno', 0)
                self._add_vulnerability(
                    "HIGH", vuln_type,
                    f"Dangerous function call: {func_name}",
                    str(file_path), line_num, 7.5
                )
    
    async def _analyze_string_concatenation(self, node: ast.BinOp, file_path: Path, content: str):
        """Analyze string concatenation for SQL injection"""
        # Look for string concatenation with SQL keywords
        if hasattr(node.left, 's') and hasattr(node.right, 's'):
            left_str = getattr(node.left, 's', '')
            right_str = getattr(node.right, 's', '')
            
            sql_keywords = ['SELECT', 'INSERT', 'UPDATE', 'DELETE', 'WHERE']
            
            if any(keyword in left_str.upper() or keyword in right_str.upper() 
                   for keyword in sql_keywords):
                line_num = getattr(node, 'lineno', 0)
                self._add_vulnerability(
                    "HIGH", "SQL_INJECTION",
                    "String concatenation with SQL keywords",
                    str(file_path), line_num, 8.0
                )
    
    async def _check_xss_vulnerabilities(self, content: str, file_path: Path):
        """Check for XSS vulnerabilities in frontend code"""
        for i, line in enumerate(content.split('\n'), 1):
            for pattern in self.xss_patterns:
                if re.search(pattern, line):
                    self._add_vulnerability(
                        "HIGH", "XSS",
                        f"Potential XSS vulnerability: {line.strip()}",
                        str(file_path), i, 7.0
                    )
    
    async def _check_client_secrets(self, content: str, file_path: Path):
        """Check for secrets in client-side code"""
        client_secret_patterns = {
            'api_key': r'["\'].*[Aa][Pp][Ii][_-]?[Kk][Ee][Yy].*["\']',
            'token': r'["\'].*[Tt][Oo][Kk][Ee][Nn].*["\']',
            'secret': r'["\'].*[Ss][Ee][Cc][Rr][Ee][Tt].*["\']',
        }
        
        for secret_type, pattern in client_secret_patterns.items():
            for match in re.finditer(pattern, content):
                line_num = content[:match.start()].count('\n') + 1
                
                self._add_vulnerability(
                    "CRITICAL", "CLIENT_SECRET",
                    f"Secret in client code: {secret_type}",
                    str(file_path), line_num, 9.0
                )
    
    async def _check_unsafe_dom(self, content: str, file_path: Path):
        """Check for unsafe DOM manipulation"""
        unsafe_dom_patterns = [
            r'innerHTML\s*=\s*.*\+',
            r'outerHTML\s*=\s*.*\+',
            r'document\.write\s*\(',
            r'\.html\s*\(.*\+',
        ]
        
        for i, line in enumerate(content.split('\n'), 1):
            for pattern in unsafe_dom_patterns:
                if re.search(pattern, line):
                    self._add_vulnerability(
                        "MEDIUM", "UNSAFE_DOM",
                        f"Unsafe DOM manipulation: {line.strip()}",
                        str(file_path), i, 6.0
                    )
    
    async def _check_prototype_pollution(self, content: str, file_path: Path):
        """Check for prototype pollution vulnerabilities"""
        pollution_patterns = [
            r'Object\.prototype\.',
            r'\[.*prototype.*\]',
            r'__proto__',
            r'constructor\.prototype',
        ]
        
        for i, line in enumerate(content.split('\n'), 1):
            for pattern in pollution_patterns:
                if re.search(pattern, line):
                    self._add_vulnerability(
                        "MEDIUM", "PROTOTYPE_POLLUTION",
                        f"Potential prototype pollution: {line.strip()}",
                        str(file_path), i, 5.5
                    )
    
    async def _check_client_validation(self, content: str, file_path: Path):
        """Check for client-side only validation"""
        validation_patterns = [
            r'if\s*\(.*\.length\s*[<>]',
            r'if\s*\(.*\.match\(',
            r'if\s*\(/.*/.test\(',
        ]
        
        # Look for validation without server-side counterpart
        for i, line in enumerate(content.split('\n'), 1):
            for pattern in validation_patterns:
                if re.search(pattern, line):
                    # This is a simplified check - in practice, would need deeper analysis
                    self._add_vulnerability(
                        "LOW", "CLIENT_VALIDATION",
                        f"Client-side validation (ensure server-side exists): {line.strip()[:50]}",
                        str(file_path), i, 3.0
                    )
    
    async def _scan_dependency_vulnerabilities(self):
        """Scan for vulnerable dependencies"""
        print("üîç Scanning Dependency Vulnerabilities...")
        
        # Python dependencies
        await self._scan_python_dependencies()
        
        # Node.js dependencies
        await self._scan_node_dependencies()
    
    async def _scan_python_dependencies(self):
        """Scan Python dependencies for vulnerabilities"""
        requirements_files = list(self.project_root.rglob("requirements*.txt"))
        
        for req_file in requirements_files:
            try:
                # Use pip-audit if available
                result = subprocess.run(
                    ['pip-audit', '--format=json', '--requirement', str(req_file)],
                    capture_output=True, text=True, timeout=60
                )
                
                if result.returncode == 0:
                    vulnerabilities = json.loads(result.stdout)
                    
                    for vuln in vulnerabilities.get('vulnerabilities', []):
                        self._add_vulnerability(
                            "HIGH", "VULNERABLE_DEPENDENCY",
                            f"Vulnerable Python package: {vuln.get('package', 'unknown')} - {vuln.get('vulnerability_id', '')}",
                            str(req_file.relative_to(self.project_root)), 0, 7.5
                        )
                        
            except (subprocess.TimeoutExpired, subprocess.CalledProcessError, FileNotFoundError):
                # Fallback to manual check
                await self._manual_python_dependency_check(req_file)
    
    async def _manual_python_dependency_check(self, req_file: Path):
        """Manual check for known vulnerable Python packages"""
        known_vulnerable = {
            'django': ['1.11.0', '2.0.0', '2.1.0'],
            'flask': ['0.12.0', '1.0.0'],
            'requests': ['2.19.0', '2.20.0'],
            'urllib3': ['1.24.0', '1.25.0'],
            'pyyaml': ['3.12', '3.13', '5.1'],
        }
        
        try:
            content = req_file.read_text()
            
            for line in content.split('\n'):
                if '==' in line:
                    package, version = line.split('==', 1)
                    package = package.strip().lower()
                    version = version.strip()
                    
                    if package in known_vulnerable:
                        if version in known_vulnerable[package]:
                            self._add_vulnerability(
                                "HIGH", "VULNERABLE_DEPENDENCY",
                                f"Known vulnerable Python package: {package}=={version}",
                                str(req_file.relative_to(self.project_root)), 0, 7.0
                            )
                            
        except Exception:
            pass
    
    async def _scan_node_dependencies(self):
        """Scan Node.js dependencies for vulnerabilities"""
        package_files = list(self.project_root.rglob("package.json"))
        
        for package_file in package_files:
            try:
                # Use npm audit if available
                result = subprocess.run(
                    ['npm', 'audit', '--json'],
                    cwd=package_file.parent,
                    capture_output=True, text=True, timeout=60
                )
                
                if result.stdout:
                    audit_data = json.loads(result.stdout)
                    
                    for vuln_id, vuln_data in audit_data.get('vulnerabilities', {}).items():
                        severity = vuln_data.get('severity', 'medium').upper()
                        if severity not in ['LOW', 'MEDIUM', 'HIGH', 'CRITICAL']:
                            severity = 'MEDIUM'
                        
                        score = {'LOW': 3.0, 'MEDIUM': 5.0, 'HIGH': 7.0, 'CRITICAL': 9.0}[severity]
                        
                        self._add_vulnerability(
                            severity, "VULNERABLE_DEPENDENCY",
                            f"Vulnerable Node.js package: {vuln_data.get('name', vuln_id)}",
                            str(package_file.relative_to(self.project_root)), 0, score
                        )
                        
            except (subprocess.TimeoutExpired, subprocess.CalledProcessError, 
                    FileNotFoundError, json.JSONDecodeError):
                pass
    
    async def _scan_configuration_vulnerabilities(self):
        """Scan for configuration vulnerabilities"""
        print("üîç Scanning Configuration Vulnerabilities...")
        
        # Check environment files
        await self._scan_env_files()
        
        # Check configuration files
        await self._scan_config_files()
        
        # Check Docker configurations
        await self._scan_docker_configs()
    
    async def _scan_env_files(self):
        """Scan environment files for vulnerabilities"""
        env_files = list(self.project_root.rglob(".env*"))
        
        for env_file in env_files:
            try:
                content = env_file.read_text()
                
                # Check for default values
                for i, line in enumerate(content.split('\n'), 1):
                    if '=' in line and not line.strip().startswith('#'):
                        key, value = line.split('=', 1)
                        
                        # Check for weak defaults
                        if value.strip() in ['password', 'secret', '123456', 'admin']:
                            self._add_vulnerability(
                                "HIGH", "WEAK_DEFAULT",
                                f"Weak default value in environment: {key}",
                                str(env_file.relative_to(self.project_root)), i, 7.0
                            )
                        
                        # Check for hardcoded secrets
                        if len(value.strip()) > 20 and not value.strip().startswith('$'):
                            self._add_vulnerability(
                                "MEDIUM", "HARDCODED_CONFIG",
                                f"Potentially hardcoded secret in config: {key}",
                                str(env_file.relative_to(self.project_root)), i, 5.0
                            )
                            
            except Exception:
                pass
    
    async def _scan_config_files(self):
        """Scan configuration files for vulnerabilities"""
        config_files = []
        config_files.extend(list(self.project_root.rglob("*.json")))
        config_files.extend(list(self.project_root.rglob("*.yaml")))
        config_files.extend(list(self.project_root.rglob("*.yml")))
        config_files.extend(list(self.project_root.rglob("*.ini")))
        config_files.extend(list(self.project_root.rglob("*.conf")))
        
        for config_file in config_files:
            try:
                content = config_file.read_text()
                
                # Check for sensitive information
                for secret_type, pattern in self.sensitive_patterns.items():
                    for match in re.finditer(pattern, content, re.IGNORECASE):
                        line_num = content[:match.start()].count('\n') + 1
                        
                        self._add_vulnerability(
                            "HIGH", "CONFIG_SECRET",
                            f"Secret in configuration file: {secret_type}",
                            str(config_file.relative_to(self.project_root)), line_num, 7.5
                        )
                
                # Check for debug settings
                debug_patterns = [
                    r'debug\s*[:=]\s*true',
                    r'DEBUG\s*[:=]\s*true',
                    r'verbose\s*[:=]\s*true',
                ]
                
                for pattern in debug_patterns:
                    for match in re.finditer(pattern, content, re.IGNORECASE):
                        line_num = content[:match.start()].count('\n') + 1
                        
                        self._add_vulnerability(
                            "MEDIUM", "DEBUG_CONFIG",
                            "Debug mode enabled in configuration",
                            str(config_file.relative_to(self.project_root)), line_num, 4.0
                        )
                        
            except Exception:
                pass
    
    async def _scan_docker_configs(self):
        """Scan Docker configurations for vulnerabilities"""
        docker_files = []
        docker_files.extend(list(self.project_root.rglob("Dockerfile*")))
        docker_files.extend(list(self.project_root.rglob("docker-compose*.yml")))
        docker_files.extend(list(self.project_root.rglob("docker-compose*.yaml")))
        
        for docker_file in docker_files:
            try:
                content = docker_file.read_text()
                
                # Check for running as root
                if 'USER root' in content or not re.search(r'USER \w+', content):
                    self._add_vulnerability(
                        "MEDIUM", "DOCKER_ROOT",
                        "Container running as root user",
                        str(docker_file.relative_to(self.project_root)), 0, 5.0
                    )
                
                # Check for privileged mode
                if 'privileged: true' in content:
                    self._add_vulnerability(
                        "HIGH", "DOCKER_PRIVILEGED",
                        "Container running in privileged mode",
                        str(docker_file.relative_to(self.project_root)), 0, 7.5
                    )
                
                # Check for hardcoded secrets
                for secret_type, pattern in self.sensitive_patterns.items():
                    if re.search(pattern, content, re.IGNORECASE):
                        self._add_vulnerability(
                            "HIGH", "DOCKER_SECRET",
                            f"Hardcoded secret in Docker configuration: {secret_type}",
                            str(docker_file.relative_to(self.project_root)), 0, 8.0
                        )
                        
            except Exception:
                pass
    
    async def _scan_database_vulnerabilities(self):
        """Scan for database vulnerabilities"""
        print("üîç Scanning Database Vulnerabilities...")
        
        # Check SQLite database if it exists
        db_path = self.backend_path / "fossawork_v2.db"
        if db_path.exists():
            await self._scan_sqlite_database(db_path)
        
        # Check database configuration
        await self._scan_database_config()
    
    async def _scan_sqlite_database(self, db_path: Path):
        """Scan SQLite database for vulnerabilities"""
        try:
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            
            # Check for weak permissions
            db_stat = db_path.stat()
            if oct(db_stat.st_mode)[-3:] == '777':
                self._add_vulnerability(
                    "HIGH", "DB_PERMISSIONS",
                    "Database file has overly permissive permissions",
                    str(db_path.relative_to(self.project_root)), 0, 7.0
                )
            
            # Check table structure for security issues
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
            tables = cursor.fetchall()
            
            for table in tables:
                table_name = table[0]
                
                # Check for unencrypted sensitive data
                cursor.execute(f"PRAGMA table_info({table_name})")
                columns = cursor.fetchall()
                
                for column in columns:
                    column_name = column[1].lower()
                    
                    if any(sensitive in column_name for sensitive in 
                           ['password', 'secret', 'token', 'key', 'credit_card']):
                        # Check if data is encrypted (simplified check)
                        cursor.execute(f"SELECT {column[1]} FROM {table_name} LIMIT 1")
                        sample_data = cursor.fetchone()
                        
                        if sample_data and sample_data[0] and len(str(sample_data[0])) < 50:
                            self._add_vulnerability(
                                "HIGH", "UNENCRYPTED_DATA",
                                f"Potentially unencrypted sensitive data in {table_name}.{column[1]}",
                                str(db_path.relative_to(self.project_root)), 0, 8.0
                            )
            
            conn.close()
            
        except Exception as e:
            pass
    
    async def _scan_database_config(self):
        """Scan database configuration for vulnerabilities"""
        config_patterns = [
            r'DATABASE_URL\s*=.*://.*:.*@',
            r'DB_PASSWORD\s*=',
            r'mysql://.*:.*@',
            r'postgresql://.*:.*@',
        ]
        
        for file_path in self.project_root.rglob("*.py"):
            try:
                content = file_path.read_text()
                
                for pattern in config_patterns:
                    for match in re.finditer(pattern, content):
                        line_num = content[:match.start()].count('\n') + 1
                        
                        self._add_vulnerability(
                            "MEDIUM", "DB_CONFIG_EXPOSURE",
                            "Database credentials in configuration",
                            str(file_path.relative_to(self.project_root)), line_num, 6.0
                        )
                        
            except Exception:
                pass
    
    async def _scan_cryptographic_vulnerabilities(self):
        """Scan for cryptographic vulnerabilities"""
        print("üîç Scanning Cryptographic Vulnerabilities...")
        
        # Already handled in static analysis, but add specific crypto checks
        await self._check_crypto_implementation()
        await self._check_random_number_generation()
        await self._check_certificate_validation()
    
    async def _check_crypto_implementation(self):
        """Check cryptographic implementation"""
        crypto_files = []
        
        for file_path in self.backend_path.rglob("*.py"):
            try:
                content = file_path.read_text()
                
                if any(keyword in content.lower() for keyword in 
                       ['encrypt', 'decrypt', 'cipher', 'crypto', 'hash']):
                    crypto_files.append(file_path)
                    
                    # Check for proper key management
                    if 'key =' in content or 'KEY =' in content:
                        if not re.search(r'os\.environ|getenv|config', content):
                            self._add_vulnerability(
                                "HIGH", "HARDCODED_CRYPTO_KEY",
                                "Hardcoded cryptographic key",
                                str(file_path.relative_to(self.project_root)), 0, 8.5
                            )
                    
                    # Check for proper IV/nonce usage
                    if 'iv' in content.lower() or 'nonce' in content.lower():
                        if 'random' not in content.lower():
                            self._add_vulnerability(
                                "MEDIUM", "WEAK_IV",
                                "Potentially reused or weak IV/nonce",
                                str(file_path.relative_to(self.project_root)), 0, 6.0
                            )
                            
            except Exception:
                pass
    
    async def _check_random_number_generation(self):
        """Check random number generation"""
        for file_path in self.backend_path.rglob("*.py"):
            try:
                content = file_path.read_text()
                
                # Check for weak random number generation
                weak_random_patterns = [
                    r'random\.random\(',
                    r'random\.randint\(',
                    r'time\.time\(\)',
                ]
                
                for pattern in weak_random_patterns:
                    if re.search(pattern, content):
                        # Check if it's used for security purposes
                        if any(security_term in content.lower() for security_term in 
                               ['password', 'token', 'secret', 'key', 'salt', 'nonce']):
                            self._add_vulnerability(
                                "MEDIUM", "WEAK_RANDOM",
                                "Weak random number generator for security purposes",
                                str(file_path.relative_to(self.project_root)), 0, 6.5
                            )
                            
            except Exception:
                pass
    
    async def _check_certificate_validation(self):
        """Check certificate validation"""
        for file_path in self.backend_path.rglob("*.py"):
            try:
                content = file_path.read_text()
                
                # Check for disabled certificate validation
                dangerous_patterns = [
                    r'verify\s*=\s*False',
                    r'ssl_verify\s*=\s*False',
                    r'CERT_NONE',
                    r'ssl\.CERT_NONE',
                ]
                
                for pattern in dangerous_patterns:
                    if re.search(pattern, content):
                        self._add_vulnerability(
                            "HIGH", "DISABLED_CERT_VALIDATION",
                            "Disabled certificate validation",
                            str(file_path.relative_to(self.project_root)), 0, 8.0
                        )
                        
            except Exception:
                pass
    
    async def _scan_authentication_vulnerabilities(self):
        """Scan for authentication vulnerabilities"""
        print("üîç Scanning Authentication Vulnerabilities...")
        
        await self._check_password_storage()
        await self._check_session_management()
        await self._check_jwt_implementation()
    
    async def _check_password_storage(self):
        """Check password storage implementation"""
        for file_path in self.backend_path.rglob("*.py"):
            try:
                content = file_path.read_text()
                
                if 'password' in content.lower():
                    # Check for proper hashing
                    if not any(secure_hash in content for secure_hash in 
                             ['bcrypt', 'scrypt', 'argon2', 'pbkdf2']):
                        if any(insecure_hash in content for insecure_hash in 
                               ['md5', 'sha1', 'sha256']) and 'password' in content:
                            self._add_vulnerability(
                                "HIGH", "WEAK_PASSWORD_HASH",
                                "Weak password hashing algorithm",
                                str(file_path.relative_to(self.project_root)), 0, 8.0
                            )
                            
            except Exception:
                pass
    
    async def _check_session_management(self):
        """Check session management implementation"""
        for file_path in self.backend_path.rglob("*.py"):
            try:
                content = file_path.read_text()
                
                if 'session' in content.lower():
                    # Check for secure session configuration
                    if not any(secure_flag in content for secure_flag in 
                             ['httponly', 'secure', 'samesite']):
                        self._add_vulnerability(
                            "MEDIUM", "INSECURE_SESSION",
                            "Insecure session configuration",
                            str(file_path.relative_to(self.project_root)), 0, 6.0
                        )
                        
            except Exception:
                pass
    
    async def _check_jwt_implementation(self):
        """Check JWT implementation"""
        for file_path in self.backend_path.rglob("*.py"):
            try:
                content = file_path.read_text()
                
                if 'jwt' in content.lower():
                    # Check for weak JWT secrets
                    if re.search(r'secret\s*=\s*["\'][^"\']{1,10}["\']', content):
                        self._add_vulnerability(
                            "HIGH", "WEAK_JWT_SECRET",
                            "Weak JWT secret key",
                            str(file_path.relative_to(self.project_root)), 0, 8.5
                        )
                    
                    # Check for algorithm confusion
                    if 'algorithm' in content and 'none' in content.lower():
                        self._add_vulnerability(
                            "CRITICAL", "JWT_NONE_ALGORITHM",
                            "JWT allows 'none' algorithm",
                            str(file_path.relative_to(self.project_root)), 0, 9.5
                        )
                        
            except Exception:
                pass
    
    async def _scan_authorization_vulnerabilities(self):
        """Scan for authorization vulnerabilities"""
        print("üîç Scanning Authorization Vulnerabilities...")
        
        await self._check_access_controls()
        await self._check_privilege_escalation()
        await self._check_idor_vulnerabilities()
    
    async def _check_access_controls(self):
        """Check access control implementation"""
        for file_path in self.backend_path.rglob("*.py"):
            try:
                content = file_path.read_text()
                
                # Look for route handlers without authentication
                if '@app.route' in content or '@router.' in content:
                    lines = content.split('\n')
                    
                    for i, line in enumerate(lines):
                        if '@app.route' in line or '@router.' in line:
                            # Check next few lines for authentication decorators
                            auth_found = False
                            for j in range(max(0, i-5), min(len(lines), i+5)):
                                if any(auth_term in lines[j] for auth_term in 
                                       ['@login_required', '@authenticate', '@requires_auth', 'Depends']):
                                    auth_found = True
                                    break
                            
                            if not auth_found and 'login' not in line.lower():
                                self._add_vulnerability(
                                    "MEDIUM", "MISSING_AUTH",
                                    f"Route without authentication: {line.strip()}",
                                    str(file_path.relative_to(self.project_root)), i+1, 6.5
                                )
                                
            except Exception:
                pass
    
    async def _check_privilege_escalation(self):
        """Check for privilege escalation vulnerabilities"""
        for file_path in self.backend_path.rglob("*.py"):
            try:
                content = file_path.read_text()
                
                # Look for role/permission changes without proper validation
                privilege_patterns = [
                    r'role\s*=\s*["\']admin["\']',
                    r'is_admin\s*=\s*True',
                    r'permissions\s*=\s*.*admin',
                ]
                
                for pattern in privilege_patterns:
                    for match in re.finditer(pattern, content):
                        line_num = content[:match.start()].count('\n') + 1
                        
                        # Check if there's proper authorization check nearby
                        context_lines = content.split('\n')[max(0, line_num-5):line_num+5]
                        
                        if not any('check' in line.lower() or 'verify' in line.lower() 
                                  for line in context_lines):
                            self._add_vulnerability(
                                "HIGH", "PRIVILEGE_ESCALATION",
                                "Potential privilege escalation without validation",
                                str(file_path.relative_to(self.project_root)), line_num, 8.0
                            )
                            
            except Exception:
                pass
    
    async def _check_idor_vulnerabilities(self):
        """Check for Insecure Direct Object Reference vulnerabilities"""
        for file_path in self.backend_path.rglob("*.py"):
            try:
                content = file_path.read_text()
                
                # Look for direct object access patterns
                idor_patterns = [
                    r'get\(\s*id\s*\)',
                    r'filter\(\s*id\s*=',
                    r'WHERE\s+id\s*=',
                    r'/\{id\}',
                ]
                
                for pattern in idor_patterns:
                    for match in re.finditer(pattern, content, re.IGNORECASE):
                        line_num = content[:match.start()].count('\n') + 1
                        
                        # Check if there's ownership verification
                        context_lines = content.split('\n')[max(0, line_num-10):line_num+10]
                        
                        if not any(term in ' '.join(context_lines).lower() for term in 
                                  ['owner', 'user_id', 'belongs_to', 'permission']):
                            self._add_vulnerability(
                                "MEDIUM", "IDOR",
                                "Potential Insecure Direct Object Reference",
                                str(file_path.relative_to(self.project_root)), line_num, 6.5
                            )
                            
            except Exception:
                pass
    
    async def _scan_input_validation_vulnerabilities(self):
        """Scan for input validation vulnerabilities"""
        print("üîç Scanning Input Validation Vulnerabilities...")
        
        await self._check_input_sanitization()
        await self._check_output_encoding()
        await self._check_file_upload_validation()
    
    async def _check_input_sanitization(self):
        """Check input sanitization"""
        for file_path in self.backend_path.rglob("*.py"):
            try:
                content = file_path.read_text()
                
                # Look for user input handling
                input_patterns = [
                    r'request\.json',
                    r'request\.form',
                    r'request\.args',
                    r'request\.data',
                ]
                
                for pattern in input_patterns:
                    for match in re.finditer(pattern, content):
                        line_num = content[:match.start()].count('\n') + 1
                        
                        # Check if there's validation nearby
                        context_lines = content.split('\n')[max(0, line_num-5):line_num+5]
                        
                        if not any(validation_term in ' '.join(context_lines).lower() for validation_term in 
                                  ['validate', 'sanitize', 'clean', 'escape', 'pydantic']):
                            self._add_vulnerability(
                                "MEDIUM", "MISSING_INPUT_VALIDATION",
                                "User input without validation",
                                str(file_path.relative_to(self.project_root)), line_num, 5.5
                            )
                            
            except Exception:
                pass
    
    async def _check_output_encoding(self):
        """Check output encoding"""
        for file_path in self.frontend_path.rglob("*.tsx"):
            try:
                content = file_path.read_text()
                
                # Look for potentially unsafe output
                if 'dangerouslySetInnerHTML' in content:
                    self._add_vulnerability(
                        "HIGH", "UNSAFE_OUTPUT",
                        "dangerouslySetInnerHTML usage",
                        str(file_path.relative_to(self.project_root)), 0, 7.5
                    )
                    
            except Exception:
                pass
    
    async def _check_file_upload_validation(self):
        """Check file upload validation"""
        for file_path in self.backend_path.rglob("*.py"):
            try:
                content = file_path.read_text()
                
                if 'upload' in content.lower() or 'file' in content.lower():
                    # Look for file type validation
                    if not any(validation in content.lower() for validation in 
                             ['content-type', 'mime', 'extension', 'allowed_types']):
                        self._add_vulnerability(
                            "HIGH", "FILE_UPLOAD_BYPASS",
                            "File upload without proper validation",
                            str(file_path.relative_to(self.project_root)), 0, 7.5
                        )
                        
            except Exception:
                pass
    
    async def _scan_session_vulnerabilities(self):
        """Scan for session management vulnerabilities"""
        print("üîç Scanning Session Vulnerabilities...")
        
        # Already covered in authentication scan
        pass
    
    async def _scan_information_disclosure(self):
        """Scan for information disclosure vulnerabilities"""
        print("üîç Scanning Information Disclosure...")
        
        await self._check_error_information_disclosure()
        await self._check_debug_information()
        await self._check_source_code_disclosure()
    
    async def _check_error_information_disclosure(self):
        """Check for information disclosure in error messages"""
        for file_path in self.backend_path.rglob("*.py"):
            try:
                content = file_path.read_text()
                
                # Look for detailed error messages
                error_patterns = [
                    r'except.*:\s*return.*str\(',
                    r'except.*:\s*print\(',
                    r'raise.*\(.*\+',
                ]
                
                for pattern in error_patterns:
                    for match in re.finditer(pattern, content):
                        line_num = content[:match.start()].count('\n') + 1
                        
                        self._add_vulnerability(
                            "LOW", "ERROR_DISCLOSURE",
                            "Potential information disclosure in error handling",
                            str(file_path.relative_to(self.project_root)), line_num, 3.0
                        )
                        
            except Exception:
                pass
    
    async def _check_debug_information(self):
        """Check for debug information disclosure"""
        # Already covered in static analysis
        pass
    
    async def _check_source_code_disclosure(self):
        """Check for source code disclosure"""
        # Look for exposed source files in web directories
        web_dirs = ['static', 'public', 'assets']
        
        for web_dir in web_dirs:
            web_path = self.project_root / web_dir
            if web_path.exists():
                for file_path in web_path.rglob("*.py"):
                    self._add_vulnerability(
                        "MEDIUM", "SOURCE_DISCLOSURE",
                        f"Python source file in web directory: {file_path.name}",
                        str(file_path.relative_to(self.project_root)), 0, 5.5
                    )
    
    async def _scan_business_logic_vulnerabilities(self):
        """Scan for business logic vulnerabilities"""
        print("üîç Scanning Business Logic Vulnerabilities...")
        
        await self._check_workflow_bypass()
        await self._check_race_conditions()
        await self._check_business_rule_validation()
    
    async def _check_workflow_bypass(self):
        """Check for workflow bypass vulnerabilities"""
        for file_path in self.backend_path.rglob("*.py"):
            try:
                content = file_path.read_text()
                
                # Look for status changes without validation
                status_patterns = [
                    r'status\s*=\s*["\']completed["\']',
                    r'state\s*=\s*["\']finished["\']',
                    r'approved\s*=\s*True',
                ]
                
                for pattern in status_patterns:
                    for match in re.finditer(pattern, content):
                        line_num = content[:match.start()].count('\n') + 1
                        
                        # Check if there's proper workflow validation
                        context_lines = content.split('\n')[max(0, line_num-10):line_num+5]
                        
                        if not any(validation in ' '.join(context_lines).lower() for validation in 
                                  ['validate', 'check', 'verify', 'approve']):
                            self._add_vulnerability(
                                "MEDIUM", "WORKFLOW_BYPASS",
                                "Potential workflow bypass",
                                str(file_path.relative_to(self.project_root)), line_num, 6.0
                            )
                            
            except Exception:
                pass
    
    async def _check_race_conditions(self):
        """Check for race condition vulnerabilities"""
        for file_path in self.backend_path.rglob("*.py"):
            try:
                content = file_path.read_text()
                
                # Look for operations that might be susceptible to race conditions
                race_patterns = [
                    r'if.*count.*==.*0:',
                    r'if.*exists\(\):',
                    r'if.*balance.*>',
                ]
                
                for pattern in race_patterns:
                    for match in re.finditer(pattern, content):
                        line_num = content[:match.start()].count('\n') + 1
                        
                        # Check if there's locking or atomic operations
                        if not any(protection in content.lower() for protection in 
                                  ['lock', 'atomic', 'transaction', 'with_for_update']):
                            self._add_vulnerability(
                                "MEDIUM", "RACE_CONDITION",
                                "Potential race condition vulnerability",
                                str(file_path.relative_to(self.project_root)), line_num, 5.5
                            )
                            
            except Exception:
                pass
    
    async def _check_business_rule_validation(self):
        """Check business rule validation"""
        for file_path in self.backend_path.rglob("*.py"):
            try:
                content = file_path.read_text()
                
                # Look for business operations without validation
                business_patterns = [
                    r'price\s*=',
                    r'amount\s*=',
                    r'quantity\s*=',
                    r'discount\s*=',
                ]
                
                for pattern in business_patterns:
                    for match in re.finditer(pattern, content):
                        line_num = content[:match.start()].count('\n') + 1
                        
                        # Check if there's business rule validation
                        context_lines = content.split('\n')[max(0, line_num-5):line_num+5]
                        
                        if not any(validation in ' '.join(context_lines).lower() for validation in 
                                  ['validate', 'check', 'min', 'max', 'range']):
                            self._add_vulnerability(
                                "LOW", "BUSINESS_RULE",
                                "Business operation without validation",
                                str(file_path.relative_to(self.project_root)), line_num, 3.5
                            )
                            
            except Exception:
                pass
    
    def _has_input_validation(self, line: str) -> bool:
        """Check if line has input validation"""
        validation_indicators = [
            'validate', 'sanitize', 'escape', 'clean',
            'pydantic', 'BaseModel', 'Field',
            'strip()', 'replace()', 'filter('
        ]
        
        return any(indicator in line for indicator in validation_indicators)
    
    def _add_vulnerability(self, severity: str, vuln_type: str, description: str, 
                          file_path: str, line_number: int, cvss_score: float = 0.0):
        """Add vulnerability to scan results"""
        vulnerability = {
            "id": f"VULN-{len(self.scan_results['vulnerabilities']):04d}",
            "severity": severity,
            "type": vuln_type,
            "description": description,
            "file": file_path,
            "line": line_number,
            "cvss_score": cvss_score,
            "timestamp": datetime.now().isoformat()
        }
        
        self.scan_results["vulnerabilities"].append(vulnerability)
    
    def _calculate_statistics(self):
        """Calculate vulnerability statistics and risk score"""
        vulnerabilities = self.scan_results["vulnerabilities"]
        
        # Count by severity
        severity_counts = {"CRITICAL": 0, "HIGH": 0, "MEDIUM": 0, "LOW": 0}
        total_cvss = 0
        
        for vuln in vulnerabilities:
            severity = vuln.get("severity", "LOW")
            severity_counts[severity] += 1
            total_cvss += vuln.get("cvss_score", 0)
        
        # Count by type
        type_counts = {}
        for vuln in vulnerabilities:
            vuln_type = vuln.get("type", "UNKNOWN")
            type_counts[vuln_type] = type_counts.get(vuln_type, 0) + 1
        
        # Calculate risk score (0-100)
        risk_score = 0
        if vulnerabilities:
            # Weight by severity
            weighted_score = (
                severity_counts["CRITICAL"] * 10 +
                severity_counts["HIGH"] * 7 +
                severity_counts["MEDIUM"] * 4 +
                severity_counts["LOW"] * 1
            )
            
            # Normalize to 0-100 scale
            max_possible_score = len(vulnerabilities) * 10
            risk_score = min(100, (weighted_score / max_possible_score) * 100)
        
        self.scan_results["statistics"] = {
            "total_vulnerabilities": len(vulnerabilities),
            "severity_breakdown": severity_counts,
            "type_breakdown": type_counts,
            "average_cvss": total_cvss / len(vulnerabilities) if vulnerabilities else 0,
            "files_scanned": len(set(vuln.get("file", "") for vuln in vulnerabilities))
        }
        
        self.scan_results["risk_score"] = round(risk_score, 1)
    
    def save_scan_results(self, output_path: str):
        """Save scan results to file"""
        output_file = Path(output_path)
        output_file.parent.mkdir(parents=True, exist_ok=True)
        
        with open(output_file, 'w') as f:
            json.dump(self.scan_results, f, indent=2)
        
        print(f"‚úÖ Vulnerability scan results saved to {output_file}")

async def main():
    """Main function to run vulnerability scan"""
    project_root = "/Users/ibhunt/Documents/GitHub/FossaWorkV2-security-fixes"
    
    scanner = VulnerabilityScanner(project_root)
    results = await scanner.run_comprehensive_scan()
    
    # Save results
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    report_path = f"{project_root}/security/reports/vulnerability_scan_{timestamp}.json"
    scanner.save_scan_results(report_path)
    
    # Print summary
    stats = results["statistics"]
    print("\n" + "="*60)
    print("üîç VULNERABILITY SCAN SUMMARY")
    print("="*60)
    print(f"Risk Score: {results['risk_score']}/100")
    print(f"Total Vulnerabilities: {stats['total_vulnerabilities']}")
    print(f"Critical: {stats['severity_breakdown']['CRITICAL']}")
    print(f"High: {stats['severity_breakdown']['HIGH']}")
    print(f"Medium: {stats['severity_breakdown']['MEDIUM']}")
    print(f"Low: {stats['severity_breakdown']['LOW']}")
    print(f"Files Scanned: {stats['files_scanned']}")
    print(f"Average CVSS: {stats['average_cvss']:.1f}")
    print("="*60)

if __name__ == "__main__":
    asyncio.run(main())