/**
 * Form Automation Script
 * 
 * This script automates the process of adding AccuMeasure forms to Fossa visits
 * and filling them with dispenser information.
 */
import { chromium } from 'playwright';
import path from 'path';
import fs from 'fs';
import dotenv from 'dotenv';
import * as logger from '../utils/logger.js';
import { loginToFossa } from '../../scripts/utils/login.js';

// Load environment variables
dotenv.config();

// Status tracking
let currentStatus = {
  status: 'idle',
  message: 'Ready to process forms',
  lastStatusUpdate: new Date().toISOString()
};

// Batch status tracking
let batchStatus = {
  status: 'idle',
  message: 'Ready to process batch',
  totalVisits: 0,
  completedVisits: 0,
  currentVisit: null,
  currentVisitStatus: null,
  startTime: new Date().toISOString(),
  lastStatusUpdate: new Date().toISOString()
};

/**
 * Update the current status with a new status and message
 * @param {string} status - The new status (idle, running, completed, error)
 * @param {string} message - The status message
 */
function updateStatus(status, message) {
  currentStatus = { 
    ...currentStatus,
    status, 
    message,
    lastStatusUpdate: new Date().toISOString()
  };
  logger.info(`Status updated: ${status} - ${message}`);
}

/**
 * Update the batch status with new information
 * @param {string} status - The new status (idle, running, completed, error)
 * @param {string} message - The status message
 * @param {object} additionalProps - Additional properties to update
 */
function updateBatchStatus(status, message, additionalProps = {}) {
  batchStatus = { 
    ...batchStatus,
    status, 
    message,
    lastStatusUpdate: new Date().toISOString(),
    ...additionalProps
  };
  logger.info(`Batch status updated: ${status} - ${message}`);
}

/**
 * Add AccuMeasure form to a visit
 * @param {object} page - Playwright page
 * @param {number} formCount - Number of forms to create
 * @returns {Promise<boolean>} - Success/failure of form preparation
 */
async function prepareForm(page, dispensers, formCount = null) {
  try {
    logger.info('Preparing AccuMeasure form...');
    updateStatus('running', 'Preparing AccuMeasure form...');
    
    // Check if we're on a visit page
    const isVisitPage = await page.evaluate(() => {
      return window.location.href.includes('/visits/');
    });
    
    if (!isVisitPage) {
      throw new Error('Not on a visit page');
    }
    
    // Verify and log the available dispensers
    logger.info(`Available dispensers (${dispensers.length}):`);
    dispensers.forEach((dispenser, i) => {
      logger.info(`  ${i+1}. ${dispenser.title || 'Unknown'}`);
    });
    
    // IMPORTANT: Use formCount if provided, otherwise default to dispensers length
    // For specific dispensers case, formCount should exactly match dispensers.length
    const formsToCreate = formCount || dispensers.length || 1;
    logger.info(`Need to create exactly ${formsToCreate} AccuMeasure forms (formCount=${formCount}, dispensers.length=${dispensers.length})`);
    
    // Take a screenshot of the form page for debugging
    await page.screenshot({ path: 'debug-form-before-count.png' });
    
    // More reliable form detection - check for form entries with AccuMeasure
    const getFormCount = async () => {
      await page.waitForTimeout(300); // Brief pause to ensure DOM is updated
      return page.evaluate(() => {
        // Multiple ways to detect AccuMeasure forms
        const linkForms = Array.from(document.querySelectorAll('a.none')).filter(a => 
          a.textContent.trim().includes('AccuMeasure')
        );
        
        const spanForms = Array.from(document.querySelectorAll('span.text-sm')).filter(span => 
          span.textContent.trim().includes('AccuMeasure') && 
          span.closest('a') !== null
        );
        
        // Return the count that seems most accurate (non-zero if possible)
        return Math.max(linkForms.length, spanForms.length);
      });
    };
    
    // Get initial form count
    const existingFormCount = await getFormCount();
    logger.info(`Found ${existingFormCount} existing AccuMeasure forms`);
    
    // Take a screenshot after counting forms for debugging
    await page.screenshot({ path: 'debug-form-after-count.png' });
    
    // Calculate how many more forms we need to add
    let remainingFormsToAdd = Math.max(0, formsToCreate - existingFormCount);
    logger.info(`Need to add ${remainingFormsToAdd} more AccuMeasure forms`);
    
    // Double-check our math - NEVER exceed the number of dispensers for specific dispensers
    if (remainingFormsToAdd + existingFormCount > dispensers.length) {
      logger.warn(`CORRECTION: Would create too many forms (${remainingFormsToAdd + existingFormCount}) for available dispensers (${dispensers.length})`);
      remainingFormsToAdd = Math.max(0, dispensers.length - existingFormCount);
      logger.info(`CORRECTED: Will add only ${remainingFormsToAdd} forms for a total of ${remainingFormsToAdd + existingFormCount}`);
    }
    
    let formsCreated = false;
    
    if (remainingFormsToAdd === 0) {
      logger.info('All required forms already exist, skipping form addition');
      updateStatus('running', 'All required forms already exist, proceeding to fill forms');
      // Don't return early - continue to collect and fill form URLs
    } else {
      // Keep track of total forms added
      let totalFormsAdded = 0;
      
      // For each form we need to create
      for (let formIndex = 0; formIndex < remainingFormsToAdd; formIndex++) {
        // Check current form count before adding
        const currentCount = await getFormCount();
        
        // Stop if we've already reached or exceeded the target
        if (currentCount >= formsToCreate) {
          logger.info(`Already reached target of ${formsToCreate} forms (current: ${currentCount}), stopping`);
          break;
        }
        
        logger.info(`Adding form ${formIndex + 1} of ${remainingFormsToAdd} (current count: ${currentCount})`);
        
        // Get the current form count before adding a new one
        const beforeFormCount = currentCount;
        
        // Add the form - either "Attach" (first time) or "New" (subsequent times)
        if (formIndex === 0 && existingFormCount === 0) {
          // For the first form when no forms exist, click "Attach"
          logger.info('Adding first form using Attach button');
          
          // Using a more specific selector to target the Attach button next to AccuMeasure
          const attachLinkSelector = 'li.plain-header:has-text("AccuMeasure") a:has-text("Attach")';
          
          try {
            await page.waitForSelector(attachLinkSelector, { timeout: 5000 });
            await page.click(attachLinkSelector);
            logger.info('Clicked Attach button next to AccuMeasure');
          } catch (error) {
            logger.warn(`Could not find specific Attach button: ${error.message}`);
            
            // Try using JavaScript evaluation as a fallback
            const attached = await page.evaluate(() => {
              // Find the AccuMeasure text element
              const accuElements = Array.from(document.querySelectorAll('span.text-sm')).filter(el => 
                el.textContent.includes('AccuMeasure')
              );
              
              if (accuElements.length > 0) {
                // Find the Attach link near it
                const accuElement = accuElements[0];
                const parent = accuElement.closest('li.plain-header') || accuElement.parentElement;
                
                if (parent) {
                  const attachLink = parent.querySelector('a[title*="Attach"]') || 
                                    Array.from(parent.querySelectorAll('a')).find(a => 
                                      a.textContent.trim() === 'Attach'
                                    );
                  
                  if (attachLink) {
                    attachLink.click();
                    return true;
                  }
                }
              }
              
              return false;
            });
            
            if (!attached) {
              throw new Error('Failed to find and click Attach button');
            }
          }
        } else {
          // For subsequent forms or when forms already exist, click "New"
          logger.info('Adding additional form using New button');
          
          // Using a much more targeted approach to find the correct New button
          const buttonClicked = await page.evaluate(() => {
            // First, try to find the AccuMeasure section
            const accuElements = Array.from(document.querySelectorAll('span.text-sm, div.text-sm')).filter(el => 
              el.textContent.includes('AccuMeasure')
            );
            
            if (accuElements.length > 0) {
              // Look for the closest New button near the AccuMeasure element
              const accumeasureElement = accuElements[0];
              // Go up to find common parent
              let parent = accumeasureElement.parentElement;
              for (let i = 0; i < 5; i++) { // Go up max 5 levels
                if (!parent) break;
                
                // Look for New button or + icon in this parent or its siblings
                const newButtonsInContext = Array.from(
                  parent.querySelectorAll('a')
                ).filter(a => 
                  a.textContent.trim().includes('New') || 
                  a.querySelector('svg.fa-plus')
                );
                
                if (newButtonsInContext.length > 0) {
                  // Found the right button in context!
                  newButtonsInContext[0].click();
                    return true;
                  }
                
                // Try parent's next sibling - for cases where buttons are adjacent
                if (parent.nextElementSibling) {
                  const siblingButtons = Array.from(
                    parent.nextElementSibling.querySelectorAll('a')
                  ).filter(a => 
                    a.textContent.trim().includes('New') || 
                    a.querySelector('svg.fa-plus')
                  );
                  
                  if (siblingButtons.length > 0) {
                    siblingButtons[0].click();
                    return true;
                  }
                }
                
                parent = parent.parentElement;
              }
            }
            
            // If still not found, look specifically in the suggested forms section
            const suggestedForms = document.querySelector('div[dusk="suggested_forms"]');
            if (suggestedForms) {
              const newButtons = Array.from(
                suggestedForms.querySelectorAll('a.text-xs')
              ).filter(a => 
                a.textContent.trim().includes('New') || 
                a.querySelector('svg.fa-plus')
              );
              
              if (newButtons.length > 0) {
                newButtons[0].click();
                return true;
              }
            }
            
                return false;
          });
          
          if (!buttonClicked) {
            logger.warn('Could not find New button via targeted JavaScript, trying fallback method');
            
            // Try a direct click with very specific selectors
            try {
              // Try more specific selector first
              const specificSelectors = [
                'div[dusk="suggested_forms"] a.text-xs:has(svg.fa-plus)',
                'a.text-xs:has-text("New"):not([title])',
                '.panel-body a:has(svg.fa-plus)',
                'a.text-xs:has(svg.fa-plus)'
              ];
              
              let clicked = false;
              for (const selector of specificSelectors) {
                if (await page.$(selector)) {
                  await page.click(selector);
                  clicked = true;
                  logger.info(`Clicked using selector: ${selector}`);
                  break;
                }
              }
              
              if (!clicked) {
                throw new Error('Could not find New button with any selector');
              }
            } catch (error) {
              logger.error(`Failed to click New button: ${error.message}`);
            }
          }
        }
        
        // Wait for the loader to disappear, indicating the form is ready
        logger.info('Waiting for loader to disappear...');
        try {
          // Wait for the loader line to disappear (display:none)
          await page.waitForFunction(() => {
            const loaders = document.querySelectorAll('.loader-line');
            for (const loader of loaders) {
              if (window.getComputedStyle(loader).display !== 'none') {
                return false;
              }
            }
            return true;
          }, { timeout: 10000 });
          logger.info('Loader disappeared, form is ready');
        } catch (error) {
          logger.warn(`Loader wait timed out: ${error.message}`);
        }
        
        // Check if the form count has increased using our more reliable method
        const afterFormCount = await getFormCount();
        
        // If form count hasn't increased, retry
        if (afterFormCount <= beforeFormCount) {
          logger.warn(`Form count didn't increase (${beforeFormCount} -> ${afterFormCount}). Retrying...`);
          
          // Try clicking again using a different approach
          try {
            await page.click('a:has-text("New")');
            
            // Wait again for the loader
            await page.waitForFunction(() => {
              const loaders = document.querySelectorAll('.loader-line');
              for (const loader of loaders) {
                if (window.getComputedStyle(loader).display !== 'none') {
                  return false;
                }
              }
              return true;
            }, { timeout: 10000 });
            
            // Check form count again
            const retryFormCount = await getFormCount();
            
            if (retryFormCount <= beforeFormCount) {
              logger.error(`Failed to add form after retry (count: ${retryFormCount})`);
              formIndex--; // Try this form index again
              continue;
            } else {
              // Success after retry
              totalFormsAdded++;
            }
          } catch (error) {
            logger.error(`Error during retry: ${error.message}`);
            formIndex--; // Try this form index again
            continue;
          }
        } else {
          // Form was added successfully
          totalFormsAdded++;
          logger.info(`Form ${formIndex + 1} added successfully (count: ${afterFormCount})`);
        }
        
        // Double-check that we haven't exceeded our target
        if (afterFormCount >= formsToCreate) {
          logger.info(`Reached target of ${formsToCreate} forms (current: ${afterFormCount}), stopping`);
          break;
        }
        
        // Just a tiny pause before adding the next form
        await page.waitForTimeout(500);
      }
      
      // Final verification
      const finalFormCount = await getFormCount();
      
      logger.info(`Forms prepared successfully. Added ${totalFormsAdded} forms. Final form count: ${finalFormCount}`);
      updateStatus('running', `Forms prepared successfully. Added ${totalFormsAdded} forms (total: ${finalFormCount}), proceeding to fill forms`);
      
      formsCreated = true;
    }
    
    // Whether we added new forms or not, collect the form URLs
    logger.info('Collecting form URLs...');
    const formUrls = await page.evaluate(() => {
      const formLinks = Array.from(document.querySelectorAll('a.none')).filter(a => 
        a.textContent.trim().includes('AccuMeasure')
      );
      
      return formLinks.map(link => link.href);
    });
    
    logger.info(`Found ${formUrls.length} form URLs`);
    
    // If we have dispensers data and form URLs, fill out each form
    if (dispensers.length > 0 && formUrls.length > 0) {
      logger.info('Proceeding to fill form details');
      await fillFormDetails(page, formUrls, dispensers);
    } else {
      if (formUrls.length === 0) {
        logger.warn('No form URLs found to process');
      }
      if (dispensers.length === 0) {
        logger.warn('No dispenser data available for forms');
      }
    }
    
    return true;
  } catch (error) {
    logger.error(`Form preparation error: ${error.message}`);
    updateStatus('error', `Form preparation error: ${error.message}`);
    return false;
  }
}

/**
 * Fill out the details for each form
 * @param {object} page - Playwright page
 * @param {array} formUrls - Array of form URLs
 * @param {array} dispensers - Array of dispenser objects
 * @returns {Promise<boolean>}
 */
async function fillFormDetails(page, formUrls, dispensers) {
  try {
    logger.info('Starting to fill form details...');
    console.log('====== STARTING FORM AUTOMATION ======');
    updateStatus('running', 'Filling form details...');
    
    // Verify we have the right number of forms for our dispensers
    if (formUrls.length > dispensers.length) {
      logger.warn(`WARNING: More forms (${formUrls.length}) than dispensers (${dispensers.length}). Only the first ${dispensers.length} forms will be processed.`);
      // Truncate the formUrls to match the number of dispensers
      formUrls = formUrls.slice(0, dispensers.length);
    } else if (formUrls.length < dispensers.length) {
      logger.warn(`WARNING: Fewer forms (${formUrls.length}) than dispensers (${dispensers.length}). Only the first ${formUrls.length} dispensers will be used.`);
    }
    
    // Log dispensers to forms mapping
    logger.info(`Dispenser to Form Mapping:`);
    for (let i = 0; i < Math.min(formUrls.length, dispensers.length); i++) {
      logger.info(`Form ${i+1} → ${dispensers[i]?.title || 'Unknown dispenser'}`);
    }
    
    // Process forms in order
    for (let i = 0; i < formUrls.length; i++) {
      const formUrl = formUrls[i];
      // Use the dispenser matching this form's index, NEVER default to the first dispenser
      // Only use a dispenser if we have one at this index
      if (!dispensers[i]) {
        logger.warn(`No dispenser available for form ${i+1}, skipping this form`);
        continue;
      }
      
      const dispenser = dispensers[i];
      
      logger.info(`Processing form ${i + 1}/${formUrls.length}: ${formUrl}`);
      logger.info(`Using dispenser: ${dispenser.title}`);
      console.log(`\n>>> PROCESSING FORM ${i + 1}/${formUrls.length}`);
      console.log(`Using dispenser: ${dispenser.title}`);
      updateStatus('running', `Filling form ${i + 1}/${formUrls.length} with dispenser ${dispenser.title}`);
      
      // Navigate to the form URL
      await page.goto(formUrl);
    await page.waitForLoadState('networkidle');
    
      // Take a screenshot of the form page
      await page.screenshot({ path: `debug-form-page-${i}.png` });
      
      // Wait for the form to load
      try {
        await page.waitForSelector('.form-entry-equipment', { state: 'visible', timeout: 10000 });
        logger.info('Form page loaded successfully');
      } catch (error) {
        logger.warn(`Form page did not load as expected: ${error.message}`);
        console.log(`Form page did not load as expected: ${error.message}`);
        await page.screenshot({ path: `debug-form-load-error-${i}.png` });
        continue; // Skip to next form if this one doesn't load properly
      }
      
      // Fill the Equipment Dispenser dropdown
      logger.info(`Selecting dispenser: ${dispenser.title || 'Unknown'}`);
      console.log(`Selecting dispenser: ${dispenser.title || 'Unknown'}`);
      
      try {
        // First, check if the dropdown is already open
        const isDropdownOpen = await page.evaluate(() => {
          return document.querySelector('.ks-select-dropdown') !== null && 
                 window.getComputedStyle(document.querySelector('.ks-select-dropdown')).display !== 'none';
        });
        
        if (!isDropdownOpen) {
          // Click the dropdown to open it
          await page.click('.ks-select-selection');
          logger.info('Clicked dropdown to open it');
          
          // Wait for dropdown to appear
          await page.waitForSelector('.ks-select-dropdown', { state: 'visible', timeout: 5000 });
        }
        
        // Wait for the dropdown list to populate
        await page.waitForSelector('.autocomplete-list li', { state: 'visible', timeout: 5000 });
        
        // Take a screenshot of the open dropdown
        await page.screenshot({ path: `debug-dispenser-dropdown-${i}.png` });
        
        // Log available options in the dropdown for debugging
        const availableOptions = await page.evaluate(() => {
          const options = Array.from(document.querySelectorAll('.autocomplete-list li'));
          return options.map(option => option.textContent.trim());
        });
        logger.info(`Available dropdown options (${availableOptions.length}): ${JSON.stringify(availableOptions)}`);
        logger.info(`Looking for dispenser: "${dispenser.title}"`);
        
        // Find and click the option matching our dispenser title
        const dispenserSelected = await page.evaluate((dispenserTitle) => {
          // Get all list items
          const options = Array.from(document.querySelectorAll('.autocomplete-list li'));
          const optionTexts = options.map(opt => opt.textContent.trim());
          
          console.log(`Looking for dispenser: "${dispenserTitle}" among options:`, optionTexts);
          
          // Try exact match first
          for (const option of options) {
            const text = option.textContent.trim();
            if (text === dispenserTitle) {
              option.click();
              return { 
                success: true, 
                matchType: 'exact', 
                selected: text,
                options: optionTexts 
              };
            }
          }
          
          // Try contains match
          for (const option of options) {
            const text = option.textContent.trim();
            if (text.includes(dispenserTitle)) {
              option.click();
              return { 
                success: true, 
                matchType: 'contains', 
                selected: text,
                options: optionTexts 
              };
            }
          }
          
          // Try to match dispenser numbers regardless of format
          // Extract numbers from our target dispenser title
          const targetMatch = dispenserTitle.match(/(\d+)(?:\/|-|&|,)?(\d+)?/);
          if (targetMatch) {
            const primaryNum = targetMatch[1];
            const secondaryNum = targetMatch[2];
            
            // Look for these numbers in the options
            for (const option of options) {
              const text = option.textContent.trim();
              const optionMatch = text.match(/(\d+)(?:\/|-|&|,)?(\d+)?/);
              
              if (optionMatch) {
                const optionPrimary = optionMatch[1];
                const optionSecondary = optionMatch[2];
                
                // Check for number match - both primary and secondary if available
                if (primaryNum === optionPrimary && 
                   (!secondaryNum || !optionSecondary || secondaryNum === optionSecondary)) {
                  option.click();
                  return { 
                    success: true, 
                    matchType: 'number', 
                    selected: text,
                    options: optionTexts,
                    matched: [primaryNum, secondaryNum, optionPrimary, optionSecondary].filter(Boolean).join(',')
                  };
                }
              }
            }
          }
          
          // If no match found, return all options for debugging
          return { 
            success: false, 
            options: optionTexts, 
            targetDispenser: dispenserTitle 
          };
        }, dispenser.title);
        
        logger.info(`Selected dispenser: ${dispenserSelected.selected} (match type: ${dispenserSelected.matchType})`);
        console.log(`Selected dispenser: ${dispenserSelected.selected} (match type: ${dispenserSelected.matchType})`);
        
        logger.debug(`Dispenser selection result: ${JSON.stringify(dispenserSelected)}`);
        
        if (!dispenserSelected.success) {
          logger.warn(`Failed to select dispenser "${dispenser.title}" from dropdown. Available options: ${JSON.stringify(dispenserSelected.options)}`);
          
          // Fallback: try to select by index if we have options
          if (dispenserSelected.options && dispenserSelected.options.length > 0) {
            // Try to find index that contains numbers from our dispenser title
            const dispenserNumbers = dispenser.title.match(/\d+/g) || [];
            let bestMatchIndex = -1;
            
            if (dispenserNumbers.length > 0) {
              // Look for an option that contains all the numbers from our dispenser title
              dispenserSelected.options.forEach((option, index) => {
                if (dispenserNumbers.every(num => option.includes(num))) {
                  bestMatchIndex = index;
                }
              });
            }
            
            // If no match by numbers, just use the first option
            if (bestMatchIndex === -1 && dispenserSelected.options.length > 0) {
              bestMatchIndex = 0;
            }
            
            if (bestMatchIndex !== -1) {
              try {
                await page.click(`.autocomplete-list li:nth-child(${bestMatchIndex + 1})`);
                logger.info(`Used fallback selection method: Selected dispenser by index ${bestMatchIndex}: "${dispenserSelected.options[bestMatchIndex]}"`);
                await page.waitForTimeout(500); // Give UI time to update
              } catch (err) {
                logger.error(`Fallback selection attempt failed: ${err.message}`);
              }
            }
          }
        } else {
          logger.info(`Successfully selected dispenser "${dispenserSelected.selected}" using ${dispenserSelected.matchType} match`);
          await page.waitForTimeout(500); // Give UI time to update
        }
      } catch (error) {
        logger.warn(`Error selecting dispenser: ${error.message}`);
        console.log(`Error selecting dispenser: ${error.message}`);
      }
      
      // Select the 5 Gallon radio button
      try {
        const proverOptionExists = await page.waitForSelector('input[value="5Gal"]', { 
          timeout: 5000,
          state: 'visible'
        }).then(() => true).catch(() => false);
        
        if (proverOptionExists) {
          // Click the radio button
          await page.click('input[value="5Gal"]');
          logger.info('Clicked 5 gallon option');
          console.log('Clicked 5 gallon option');
          
          // Take screenshot after clicking
          await page.screenshot({ path: `debug-after-5gal-click-${i}.png` });
          
          // Verify the selection was actually made
          const selectionVerified = await page.evaluate(() => {
            const radioButton = document.querySelector('input[value="5Gal"]');
            return radioButton && radioButton.checked;
          });
          
          if (!selectionVerified) {
            logger.warn('5 gallon option was clicked but not selected! Retrying...');
            console.log('5 gallon option was clicked but not selected! Retrying...');
            
            // Try alternative method for selection
            const retrySuccess = await page.evaluate(() => {
              const radio = document.querySelector('input[value="5Gal"]');
              if (radio) {
                // Direct property setting
                radio.checked = true;
                
                // Create and dispatch change event
                const event = new Event('change', { bubbles: true });
                radio.dispatchEvent(event);
                
                // Create and dispatch click event
                const clickEvent = new MouseEvent('click', {
                  bubbles: true,
                  cancelable: true,
                  view: window
                });
                radio.dispatchEvent(clickEvent);
                
                return radio.checked;
              }
              return false;
            });
            
            if (retrySuccess) {
              logger.info('5 gallon option selected successfully after retry');
              console.log('5 gallon option selected successfully after retry');
            } else {
              logger.error('Failed to select 5 gallon option after multiple attempts');
              console.log('Failed to select 5 gallon option after multiple attempts');
              await page.screenshot({ path: `debug-5gal-selection-failed-${i}.png` });
              
              // If we consistently can't select this, we should not proceed to the next step
              logger.warn('Cannot proceed without 5 gallon selection confirmed');
              console.log('Cannot proceed without 5 gallon selection confirmed');
              continue; // Skip to the next form
            }
          } else {
            logger.info('5 gallon selection verified successfully');
            console.log('5 gallon selection verified successfully');
          }
        } else {
          logger.warn('5 gallon option not found');
          console.log('5 gallon option not found');
          await page.screenshot({ path: `debug-no-5gal-option-${i}.png` });
          
          // Try to find any radio buttons in case the selector changed
          const anyRadioFound = await page.evaluate(() => {
            const allRadios = document.querySelectorAll('input[type="radio"]');
            if (allRadios.length > 0) {
              // Look for one that might be for gallon selection
              for (const radio of allRadios) {
                const label = radio.closest('label');
                if (label && label.textContent.includes('Gallon')) {
                  radio.click();
    return true;
                }
              }
              // If no label with "Gallon", try the first radio as fallback
              allRadios[0].click();
              return true;
            }
            return false;
          });
          
          if (anyRadioFound) {
            logger.info('Selected a radio button as fallback');
            console.log('Selected a radio button as fallback');
            await page.screenshot({ path: `debug-radio-fallback-${i}.png` });
          } else {
            logger.error('No radio buttons found at all');
            console.log('No radio buttons found at all');
            continue; // Skip to the next form
          }
        }
  } catch (error) {
        logger.warn(`Error selecting 5 gallon option: ${error.message}`);
        console.log(`Error selecting 5 gallon option: ${error.message}`);
        continue; // Skip to next form if we can't select this critical option
      }
      
      // Click Save to save the initial form
      try {
        const saveButtonExists = await page.waitForSelector('button.save-section', {
          timeout: 5000,
          state: 'visible'
        }).then(() => true).catch(() => false);
        
        if (saveButtonExists) {
          // Take screenshot before clicking save
          await page.screenshot({ path: `debug-before-save-${i}.png` });
          
          // Click the save button
          await page.click('button.save-section');
          logger.info('Clicked save button for initial form section');
          console.log('Clicked save button for initial form section');
          
          // Wait for saving to complete - look for network activity or UI changes
          try {
            // Wait for network idle, which suggests the save request completed
            await page.waitForLoadState('networkidle', { timeout: 5000 });
            
            // Verify the save was successful by checking for save success indicators
            let saveVerified = false;
            
            // Multiple ways to verify save was successful
            const saveResult = await page.evaluate(() => {
              // Check 1: Success message - might appear briefly
              const successMessage = document.querySelector('.success-msg, .alert-success');
              if (successMessage && window.getComputedStyle(successMessage).display !== 'none') {
                return 'Success message visible';
              }
              
              // Check 2: Is there a next section/form available?
              const nextButton = document.querySelector('a.next-section');
              if (nextButton && !nextButton.classList.contains('disabled')) {
                return 'Next button enabled';
              }
              
              // Check 3: Has the form section UI changed to indicate completion?
              const formSectionHeader = document.querySelector('.panel-header');
              if (formSectionHeader && formSectionHeader.classList.contains('completed')) {
                return 'Form section marked as completed';
              }
              
    return false;
            });
            
            if (saveResult) {
              saveVerified = true;
              logger.info(`Save verified: ${saveResult}`);
              console.log(`Save verified: ${saveResult}`);
            }
            
            // If we couldn't verify the save, wait a bit longer and check again
            if (!saveVerified) {
              logger.warn('Could not immediately verify save completion, waiting longer...');
              console.log('Could not immediately verify save completion, waiting longer...');
              
              await page.waitForTimeout(2000); // Wait 2 seconds
              
              // Take a screenshot to see current state
              await page.screenshot({ path: `debug-after-save-wait-${i}.png` });
              
              // Check if we now have a next button enabled
              const nextButtonEnabled = await page.evaluate(() => {
                const nextButton = document.querySelector('a.next-section');
                return nextButton && !nextButton.classList.contains('disabled');
              });
              
              if (nextButtonEnabled) {
                saveVerified = true;
                logger.info('Save verified after additional wait: Next button enabled');
                console.log('Save verified after additional wait: Next button enabled');
              } else {
                logger.warn('Could not verify save completion even after waiting');
                console.log('Could not verify save completion even after waiting');
                
                // Let's try again to click save
                try {
                  await page.click('button.save-section');
                  logger.info('Clicked save button again as verification failed');
                  console.log('Clicked save button again as verification failed');
                  await page.waitForTimeout(1000); // Wait for save to complete
                } catch (saveRetryError) {
                  logger.warn(`Error retrying save: ${saveRetryError.message}`);
                  console.log(`Error retrying save: ${saveRetryError.message}`);
                }
              }
            }
            
            // Take a screenshot after saving
            await page.screenshot({ path: `debug-after-save-${i}.png` });
          } catch (waitError) {
            logger.warn(`Timeout waiting for save to complete: ${waitError.message}`);
            console.log(`Timeout waiting for save to complete: ${waitError.message}`);
            
            // Let's still continue - the save might have worked even if we couldn't verify
          }
          
          // Now proceed with navigating through all fuel type sections
          const fuelSectionsProcessed = await processAllFuelSections(page, dispenser);
          if (fuelSectionsProcessed) {
            logger.info(`Successfully processed all fuel sections for form ${i + 1}`);
            console.log(`Successfully processed all fuel sections for form ${i + 1}`);
          } else {
            logger.warn(`Failed to process all fuel sections for form ${i + 1}`);
            console.log(`Failed to process all fuel sections for form ${i + 1}`);
          }
        } else {
          logger.warn('Save button not found');
          console.log('Save button not found');
          await page.screenshot({ path: `debug-no-save-button-${i}.png` });
          
          // Try alternate ways to find and click save
          const alternativeSaveFound = await page.evaluate(() => {
            // Look for any button containing "Save" text
            const saveButtons = Array.from(document.querySelectorAll('button')).filter(
              button => button.textContent.includes('Save')
            );
            
            if (saveButtons.length > 0) {
              saveButtons[0].click();
              return true;
            }
            
            return false;
          });
          
          if (alternativeSaveFound) {
            logger.info('Found and clicked alternative save button');
            console.log('Found and clicked alternative save button');
            await page.waitForTimeout(1000); // Wait for save to complete
            
            // Try to proceed with the fuel sections
            const fuelSectionsProcessed = await processAllFuelSections(page, dispenser);
            if (fuelSectionsProcessed) {
              logger.info(`Successfully processed all fuel sections for form ${i + 1} after alternative save`);
              console.log(`Successfully processed all fuel sections for form ${i + 1} after alternative save`);
            }
          } else {
            logger.error('No save button found through any method - cannot proceed');
            console.log('No save button found through any method - cannot proceed');
            continue; // Skip to next form
          }
        }
      } catch (error) {
        logger.warn(`Error saving form: ${error.message}`);
        console.log(`Error saving form: ${error.message}`);
        continue; // Skip to next form if we can't save this one
      }
      
      logger.info(`Completed processing form ${i + 1}/${formUrls.length}`);
      console.log(`<<< COMPLETED FORM ${i + 1}/${formUrls.length}`);
      updateStatus('running', `Completed form ${i + 1}/${formUrls.length}, ${i < formUrls.length - 1 ? 'moving to next form' : 'finishing up'}`);
    }
    
    logger.info('Form filling complete');
    console.log('====== FORM AUTOMATION COMPLETED ======');
    updateStatus('completed', 'Form filling complete');
    return true;
  } catch (error) {
    logger.error(`Error filling form details: ${error.message}`);
    console.log(`CRITICAL ERROR: ${error.message}`);
    updateStatus('error', `Error filling form details: ${error.message}`);
    return false;
  }
}

/**
 * Process all fuel sections in a form
 * @param {object} page - Playwright page
 * @param {object} dispenser - Dispenser object containing fuel grades
 * @returns {Promise<void>}
 */
async function processAllFuelSections(page, dispenser) {
  try {
    logger.info('=== ENTERING MULTI-SECTION MODE: Starting to process all fuel sections... ===');
    console.log('=== ENTERING MULTI-SECTION MODE: Starting to process all fuel sections... ===');
    
    // Click the "Next" button to move to the first fuel type section
    try {
      const nextButtonExists = await page.waitForSelector('a.next-section', { 
        timeout: 5000,
        state: 'visible' 
      }).then(() => true).catch(() => false);
      
      if (!nextButtonExists) {
        logger.warn('Next button not found - unable to proceed to fuel sections');
        console.log('Next button not found - unable to proceed to fuel sections');
        return false;
      }
      
      logger.info('Found Next button, clicking to proceed to fuel sections...');
      console.log('Found Next button, clicking to proceed to fuel sections...');
      
      // Take screenshot before clicking the next button (for debugging)
      await page.screenshot({ path: 'debug-before-next-click.png' });
      
      // Click the next button
      await page.click('a.next-section');
      logger.info('Clicked Next button to proceed to fuel sections');
      
      // Take screenshot after clicking the next button (for debugging)
      await page.waitForTimeout(1000); // Wait for page transition
      await page.screenshot({ path: 'debug-after-next-click.png' });
    } catch (error) {
      logger.warn(`Error clicking Next button: ${error.message}`);
      console.log(`Error clicking Next button: ${error.message}`);
      return false;
    }
    
    // Load prover preferences from JSON file
    logger.info('Loading prover preferences...');
    const proverPreferences = await loadProverPreferences();
    if (!proverPreferences) {
      logger.warn('Could not load prover preferences, using default selection');
    } else {
      logger.info(`Loaded preferences for ${proverPreferences.provers.length} provers`);
    }
    
    // Extract all fuel grades from the dispenser
    let fuelGrades = [];
    if (dispenser.fields && dispenser.fields.Grade) {
      fuelGrades = dispenser.fields.Grade.split(',').map(grade => grade.trim());
    } else if (dispenser.title) {
      // Try to extract grades from title if fields are not available
      const titleParts = dispenser.title.split('-');
      if (titleParts.length > 1) {
        const gradesSection = titleParts[1].trim();
        fuelGrades = gradesSection.split(',').map(grade => grade.trim());
      }
    }
    
    logger.info(`Found ${fuelGrades.length} fuel grades to process: ${fuelGrades.join(', ')}`);
    console.log(`Found ${fuelGrades.length} fuel grades to process: ${fuelGrades.join(', ')}`);
    
    // Add detailed debugging information
    logger.info(`DEBUG - Raw fuel grades: ${JSON.stringify(fuelGrades)}`);
    console.log(`DEBUG - Raw fuel grades: ${JSON.stringify(fuelGrades)}`);
    const normalizedGrades = fuelGrades.map(grade => grade.split(':').pop().trim());
    logger.info(`DEBUG - Normalized fuel grades: ${JSON.stringify(normalizedGrades)}`);
    console.log(`DEBUG - Normalized fuel grades: ${JSON.stringify(normalizedGrades)}`);
    
    // Check for Premium and Super combination
    const hasPremium = normalizedGrades.some(grade => grade === 'Premium');
    const hasSuper = normalizedGrades.some(grade => grade === 'Super' || grade === 'Super Premium' || grade === 'Ultra');
    if (hasPremium && hasSuper) {
      logger.info(`DEBUG - Special case detected: Premium and Super variants exist together`);
      console.log(`DEBUG - Special case detected: Premium and Super variants exist together`);
    }
    
    // Take screenshot of the fuel section page (for debugging)
    await page.screenshot({ path: 'debug-fuel-sections-page.png' });
    
    // Check if there are any iterations visible
    const anyIterationsExist = await page.evaluate(() => {
      return document.querySelectorAll('[id^="iteration-"]').length > 0;
    });
    
    if (!anyIterationsExist) {
      logger.warn('No iteration sections found on the page');
      console.log('No iteration sections found on the page');
      await page.screenshot({ path: 'debug-no-iterations-found.png' });
      return false;
    }
    
    // Get total number of iterations for progress tracking
    const totalIterations = await page.evaluate(() => {
      return document.querySelectorAll('[id^="iteration-"]').length;
    });
    
    logger.info(`Found ${totalIterations} total fuel sections to process`);
    console.log(`Found ${totalIterations} total fuel sections to process`);
    updateStatus('running', `Found ${totalIterations} fuel sections to process`);
    
    // Process each fuel type section (iteration)
    let currentIteration = 0;
    let moreIterationsExist = true;
    let processedIterations = 0;
    
    while (moreIterationsExist) {
      // Check if current iteration exists
      try {
        logger.info(`Checking for iteration ${currentIteration}...`);
        console.log(`Checking for iteration ${currentIteration}...`);
        
        const iterationExists = await page.waitForSelector(`#iteration-${currentIteration}`, { 
          timeout: 5000,
          state: 'visible' 
        }).then(() => true).catch(() => false);
        
        if (!iterationExists) {
          logger.info(`No more iterations found after iteration ${currentIteration - 1}`);
          console.log(`No more iterations found after iteration ${currentIteration - 1}`);
          moreIterationsExist = false;
          break;
        }
        
        logger.info(`Found iteration ${currentIteration}, checking if expanded...`);
        console.log(`Found iteration ${currentIteration}, checking if expanded...`);
        
        // Check if iteration is already open/expanded
        const isExpanded = await page.evaluate((iterationId) => {
          const panel = document.querySelector(`#${iterationId} .panel-body`);
          return panel && window.getComputedStyle(panel).display !== 'none';
        }, `iteration-${currentIteration}`);
        
        // If not expanded, click to expand it
        if (!isExpanded) {
          logger.info(`Iteration ${currentIteration} is collapsed, expanding...`);
          console.log(`Iteration ${currentIteration} is collapsed, expanding...`);
          
          // Take screenshot before expanding
          await page.screenshot({ path: `debug-before-expand-iteration-${currentIteration}.png` });
          
          await page.click(`#iteration-${currentIteration} .panel-header a`);
          logger.info(`Expanded iteration ${currentIteration}`);
          await page.waitForTimeout(500);
          
          // Take screenshot after expanding
          await page.screenshot({ path: `debug-after-expand-iteration-${currentIteration}.png` });
        } else {
          logger.info(`Iteration ${currentIteration} is already expanded`);
        }
        
        // Get the current fuel type
        const fuelType = await page.evaluate((iterationId) => {
          const headerText = document.querySelector(`#${iterationId} .panel-header a span`);
          if (headerText) {
            return headerText.textContent.trim().replace(':', '').trim();
          }
          return null;
        }, `iteration-${currentIteration}`);
        
        if (fuelType) {
          // Update status with progress information
          processedIterations++;
          updateStatus('running', `Processing fuel type: ${fuelType} (${processedIterations}/${totalIterations})`);
          
          logger.info(`Processing fuel type: ${fuelType} (iteration ${currentIteration}, ${processedIterations}/${totalIterations})`);
          console.log(`Processing fuel type: ${fuelType} (iteration ${currentIteration}, ${processedIterations}/${totalIterations})`);
          
          // Fill out the form for this fuel type
          await fillFuelTypeForm(page, fuelType, fuelGrades, proverPreferences);
          
          // Take screenshot before saving
          await page.screenshot({ path: `debug-before-save-iteration-${currentIteration}.png` });
          
          // Click Save for this section
          try {
            const saveButtonExists = await page.waitForSelector(`#iteration-${currentIteration} button.save-section`, {
              timeout: 5000,
              state: 'visible'
            }).then(() => true).catch(() => false);
            
            if (saveButtonExists) {
              await page.click(`#iteration-${currentIteration} button.save-section`);
              logger.info(`Saved form for fuel type: ${fuelType}`);
              console.log(`Saved form for fuel type: ${fuelType}`);
              await page.waitForTimeout(1000); // Wait for save to complete
              
              // Take screenshot after saving
              await page.screenshot({ path: `debug-after-save-iteration-${currentIteration}.png` });
            } else {
              logger.warn(`Save button not found for iteration ${currentIteration}`);
              console.log(`Save button not found for iteration ${currentIteration}`);
            }
          } catch (error) {
            logger.warn(`Error saving form for fuel type ${fuelType}: ${error.message}`);
            console.log(`Error saving form for fuel type ${fuelType}: ${error.message}`);
          }
        } else {
          logger.warn(`Could not determine fuel type for iteration ${currentIteration}`);
          console.log(`Could not determine fuel type for iteration ${currentIteration}`);
        }
        
        // Move to next iteration
        currentIteration++;
        
      } catch (error) {
        logger.warn(`Error processing iteration ${currentIteration}: ${error.message}`);
        console.log(`Error processing iteration ${currentIteration}: ${error.message}`);
        moreIterationsExist = false;
      }
    }
    
    // Update status with completion information
    updateStatus('running', `Processed ${processedIterations}/${totalIterations} fuel sections, completing form`);
    
    logger.info(`=== COMPLETED MULTI-SECTION PROCESSING: Processed ${processedIterations}/${totalIterations} fuel sections ===`);
    console.log(`=== COMPLETED MULTI-SECTION PROCESSING: Processed ${processedIterations}/${totalIterations} fuel sections ===`);
    return true;
  } catch (error) {
    logger.error(`Error processing fuel sections: ${error.message}`);
    console.log(`Error processing fuel sections: ${error.message}`);
    return false;
  }
}

/**
 * Fill out a single fuel type form
 * @param {object} page - Playwright page
 * @param {string} fuelType - The current fuel type being processed
 * @param {array} allFuelTypes - All fuel types on this dispenser
 * @param {object} proverPreferences - Prover preferences loaded from JSON
 * @returns {Promise<void>}
 */
async function fillFuelTypeForm(page, fuelType, allFuelTypes, proverPreferences) {
  try {
    logger.info(`=== FILLING FUEL TYPE FORM: ${fuelType} ===`);
    console.log(`=== FILLING FUEL TYPE FORM: ${fuelType} ===`);
    
    // Take a screenshot of the current form
    await page.screenshot({ path: `debug-fuel-form-${fuelType.replace(/[/:]/g, '_')}.png` });
    
    // We intentionally skip entering fuel price as requested
    logger.info('Skipping fuel price entry as requested');
    console.log('Skipping fuel price entry as requested');
    
    // Determine if this fuel type has a meter
    const hasMeters = shouldHaveMeter(fuelType, allFuelTypes);
    logger.info(`Meter determination for ${fuelType}: ${hasMeters ? 'YES' : 'NO'}`);
    console.log(`Meter determination for ${fuelType}: ${hasMeters ? 'YES' : 'NO'}`);
    
    // Select Yes/No for Has Meter
    try {
      // Take a screenshot before attempting to click radio buttons
      await page.screenshot({ path: `debug-before-meter-selection-${fuelType.replace(/[/:]/g, '_')}.png` });
      
      logger.info(`Attempting to select '${hasMeters ? 'Yes' : 'No'}' for Has Meter (direct label click)`);
      console.log(`Attempting to select '${hasMeters ? 'Yes' : 'No'}' for Has Meter (direct label click)`);
      
      // Use the most direct approach possible - click on the label directly
      // Based on the exact HTML structure provided
      const selectedRadio = await page.evaluate((shouldHaveMeter) => {
        // Get all radio labels - using the exact structure from provided HTML
        const labels = document.querySelectorAll('label.ks-radio');
        
        // Find the Yes and No labels
        let yesLabel = null;
        let noLabel = null;
        
        for (const label of labels) {
          const labelText = label.querySelector('.ks-radio-label-wrapper');
          if (labelText && labelText.textContent.trim() === 'Yes') {
            yesLabel = label;
          } else if (labelText && labelText.textContent.trim() === 'No') {
            noLabel = label;
          }
        }
        
        // Click the appropriate label
        if (shouldHaveMeter && yesLabel) {
          console.log('Found Yes label, clicking it');
          yesLabel.click();
          return 'Yes label clicked';
        } else if (!shouldHaveMeter && noLabel) {
          console.log('Found No label, clicking it');
          noLabel.click();
          return 'No label clicked';
        }
        
        return 'Labels not found';
      }, hasMeters);
      
      logger.info(`Label selection result: ${selectedRadio}`);
      console.log(`Label selection result: ${selectedRadio}`);
      
      // Take a screenshot after the label click
      await page.waitForTimeout(500);
      await page.screenshot({ path: `debug-after-label-click-${fuelType.replace(/[/:]/g, '_')}.png` });
      
      // Verify if the radio was actually selected
      const radioSelected = await page.evaluate((shouldHaveMeter) => {
        const yesRadio = document.querySelector('input[type="radio"][value="1"]');
        const noRadio = document.querySelector('input[type="radio"][value="2"]');
        
        if (shouldHaveMeter && yesRadio && yesRadio.checked) {
          return 'Yes radio confirmed selected';
        } else if (!shouldHaveMeter && noRadio && noRadio.checked) {
          return 'No radio confirmed selected';
        }
        
        return 'Radio selection not confirmed';
      }, hasMeters);
      
      logger.info(`Radio selection verification: ${radioSelected}`);
      console.log(`Radio selection verification: ${radioSelected}`);
      
      // If the radio wasn't properly selected, try clicking directly on the input
      if (radioSelected === 'Radio selection not confirmed') {
        logger.info('Direct label click did not work, trying to click on input element directly');
        console.log('Direct label click did not work, trying to click on input element directly');
        
        // Click directly on the input element with a force option
        const directRadioSelected = await page.evaluate((shouldHaveMeter) => {
          const yesRadio = document.querySelector('input[type="radio"][value="1"]');
          const noRadio = document.querySelector('input[type="radio"][value="2"]');
          
          if (shouldHaveMeter && yesRadio) {
            console.log('Found Yes input, clicking it directly');
            yesRadio.click();
            yesRadio.checked = true;
            return 'Yes input clicked';
          } else if (!shouldHaveMeter && noRadio) {
            console.log('Found No input, clicking it directly');
            noRadio.click();
            noRadio.checked = true;
            return 'No input clicked';
          }
          
          return 'Inputs not found';
        }, hasMeters);
        
        logger.info(`Direct input selection result: ${directRadioSelected}`);
        console.log(`Direct input selection result: ${directRadioSelected}`);
        
        // Take a screenshot after the direct input click
        await page.waitForTimeout(500);
        await page.screenshot({ path: `debug-after-input-click-${fuelType.replace(/[/:]/g, '_')}.png` });
      }
      
      // One final attempt using Playwright's direct click - try the explicit selector
      const finalSelector = hasMeters ? 
        'label.ks-radio:has-text("Yes")' : 
        'label.ks-radio:has-text("No")';
        
      try {
        await page.click(finalSelector, { force: true, timeout: 2000 });
        logger.info(`Final attempt to click using Playwright selector: ${finalSelector}`);
        console.log(`Final attempt to click using Playwright selector: ${finalSelector}`);
        
        // Take a screenshot after the final click attempt
        await page.waitForTimeout(500);
        await page.screenshot({ path: `debug-after-final-click-${fuelType.replace(/[/:]/g, '_')}.png` });
      } catch (clickError) {
        logger.warn(`Final click attempt failed: ${clickError.message}`);
        console.log(`Final click attempt failed: ${clickError.message}`);
      }
    } catch (error) {
      logger.warn(`Error selecting Has Meter option: ${error.message}`);
      console.log(`Error selecting Has Meter option: ${error.message}`);
      await page.screenshot({ path: `debug-meter-error-${fuelType.replace(/[/:]/g, '_')}.png` });
    }
    
    // Type of fill - Top is default and usually pre-selected, but confirm
    try {
      const typeOfFillExists = await page.evaluate(() => {
        return document.querySelectorAll('input[name="field[4858]"]').length > 0;
      });
      
      if (!typeOfFillExists) {
        logger.warn('Type of fill radio options not found on the page');
        console.log('Type of fill radio options not found on the page');
      } else {
        const topSelected = await page.evaluate(() => {
          return document.querySelector('input[name="field[4858]"][value="1"]').checked;
        });
        
        if (!topSelected) {
          await page.click('input[name="field[4858]"][value="1"]'); // Top
          logger.info('Selected Top for Type of fill');
          console.log('Selected Top for Type of fill');
        } else {
          logger.info('Top already selected for Type of fill');
          console.log('Top already selected for Type of fill');
        }
      }
    } catch (error) {
      logger.warn(`Error selecting Type of fill: ${error.message}`);
      console.log(`Error selecting Type of fill: ${error.message}`);
    }
    
    // Only select prover if we have a preference match
    const proverId = getPreferredProver(fuelType, proverPreferences, allFuelTypes);
    
    if (proverId) {
      logger.info(`Found preferred prover ${proverId} for fuel type ${fuelType}`);
      console.log(`Found preferred prover ${proverId} for fuel type ${fuelType}`);
      
      try {
        // Check if prover dropdown exists
        const proverDropdownExists = await page.evaluate(() => {
          return document.querySelector('.ks-select-selection') !== null;
        });
        
        if (!proverDropdownExists) {
          logger.warn('Prover dropdown not found on the page');
          console.log('Prover dropdown not found on the page');
          await page.screenshot({ path: `debug-no-prover-dropdown-${fuelType.replace(/[/:]/g, '_')}.png` });
          return true;
        }
        
        // First click to open the dropdown
        await page.click('.ks-select-selection');
        logger.info('Clicked to open prover dropdown');
        console.log('Clicked to open prover dropdown');
        
        // Wait for dropdown to appear
        const dropdownVisible = await page.waitForSelector('.ks-select-dropdown', { 
          state: 'visible', 
          timeout: 5000 
        }).then(() => true).catch(() => false);
        
        if (!dropdownVisible) {
          logger.warn('Prover dropdown did not appear after click');
          console.log('Prover dropdown did not appear after click');
          await page.screenshot({ path: `debug-prover-dropdown-not-visible-${fuelType.replace(/[/:]/g, '_')}.png` });
          return true;
        }
        
        // Take screenshot of open dropdown
        await page.screenshot({ path: `debug-prover-dropdown-open-${fuelType.replace(/[/:]/g, '_')}.png` });
        
        // Find and click the option matching our prover ID
        const proverSelected = await page.evaluate((proverId) => {
          const options = Array.from(document.querySelectorAll('.autocomplete-list li'));
          console.log(`Found ${options.length} options in prover dropdown`);
          
          for (const option of options) {
            if (option.textContent.includes(proverId)) {
              option.click();
              return true;
            }
          }
          
          return false;
        }, proverId);
        
        if (proverSelected) {
          logger.info(`Selected prover: ${proverId} for fuel type: ${fuelType}`);
          console.log(`Selected prover: ${proverId} for fuel type: ${fuelType}`);
          await page.screenshot({ path: `debug-prover-selected-${fuelType.replace(/[/:]/g, '_')}.png` });
        } else {
          logger.warn(`Could not find prover with ID: ${proverId}, leaving prover unselected`);
          console.log(`Could not find prover with ID: ${proverId}, leaving prover unselected`);
          // Close the dropdown without selecting anything
          await page.keyboard.press('Escape');
          await page.screenshot({ path: `debug-prover-not-found-${fuelType.replace(/[/:]/g, '_')}.png` });
        }
      } catch (error) {
        logger.warn(`Error selecting prover: ${error.message}`);
        console.log(`Error selecting prover: ${error.message}`);
        await page.screenshot({ path: `debug-prover-error-${fuelType.replace(/[/:]/g, '_')}.png` });
      }
    } else {
      logger.info(`No preferred prover found for ${fuelType}, leaving prover unselected`);
      console.log(`No preferred prover found for ${fuelType}, leaving prover unselected`);
    }
    
    logger.info(`=== COMPLETED FILLING FUEL TYPE FORM: ${fuelType} ===`);
    console.log(`=== COMPLETED FILLING FUEL TYPE FORM: ${fuelType} ===`);
    return true;
  } catch (error) {
    logger.error(`Error filling fuel type form for ${fuelType}: ${error.message}`);
    console.log(`Error filling fuel type form for ${fuelType}: ${error.message}`);
    await page.screenshot({ path: `debug-fuel-form-error-${fuelType.replace(/[/:]/g, '_')}.png` });
    return false;
  }
}

/**
 * Determines if a fuel type should have a meter based on predefined logic
 * @param {string} fuelType - The current fuel type
 * @param {array} allFuelTypes - All fuel types on the dispenser
 * @returns {boolean} - Whether this fuel type should have a meter
 */
function shouldHaveMeter(fuelType, allFuelTypes) {
  // Extract the base fuel type (remove any text after a colon)
  const baseFuelType = fuelType.split(':').pop().trim();
  
  // Types that always have meters
  const typesWithMeters = [
    'Regular', 'Diesel', 'Super', 'Super Premium', 'Ultra', 
    'Ethanol-Free Gasoline Plus', 'Ethanol-Free', 'Rec Fuel 90', 'Race Fuel'
  ];
  
  // Types that never have meters
  const typesWithoutMeters = [
    'Plus', 'Special 88', 'Extra 89', 'Midgrade 89'
  ];
  
  // Special case for Premium
  if (baseFuelType === 'Premium') {
    // Check if Super, Super Premium, or Ultra exist on the same dispenser
    const hasSuperVariants = allFuelTypes.some(type => {
      // Normalize the type first by trimming and removing any text after a colon
      const normalizedType = type.split(':').pop().trim();
      return normalizedType === 'Super' || 
             normalizedType === 'Super Premium' || 
             normalizedType === 'Ultra';
    });
    
    // If any super variants exist, Premium doesn't have a meter
    if (hasSuperVariants) {
      logger.info('Premium with Super variant detected - selecting No for meter');
      return false;
    }
    
    // Otherwise Premium has a meter
    return true;
  }
  
  // Check if it's in the types with meters
  if (typesWithMeters.some(type => baseFuelType.includes(type))) {
    return true;
  }
  
  // Check if it's in the types without meters
  if (typesWithoutMeters.some(type => baseFuelType.includes(type))) {
    return false;
  }
  
  // Default to Yes if we're not sure
  logger.info(`Fuel type "${baseFuelType}" not in known lists, defaulting to Yes for meter`);
  return true;
}

/**
 * Load prover preferences from JSON file
 * @returns {Promise<object>} - Prover preferences object or null if error
 */
async function loadProverPreferences() {
  try {
    const preferencesPath = path.join(process.cwd(), 'data', 'prover_preferences.json');
    if (fs.existsSync(preferencesPath)) {
      const data = fs.readFileSync(preferencesPath, 'utf8');
      return JSON.parse(data);
    } else {
      logger.warn('Prover preferences file not found');
      return null;
    }
  } catch (error) {
    logger.error(`Error loading prover preferences: ${error.message}`);
    return null;
  }
}

/**
 * Get the preferred prover ID for a fuel type
 * @param {string} fuelType - The fuel type to match
 * @param {object} proverPreferences - The prover preferences object
 * @param {array} allFuelTypes - All fuel types on this dispenser
 * @returns {string} - The preferred prover ID or null if no match
 */
function getPreferredProver(fuelType, proverPreferences, allFuelTypes = []) {
  if (!proverPreferences || !proverPreferences.provers || proverPreferences.provers.length === 0) {
    return null;
  }
  
  // Extract the base fuel type
  const baseFuelType = fuelType.split(':').pop().trim();
  
  // Special case for Premium when Super/Ultra/Super Premium exists
  if (baseFuelType === 'Premium') {
    // Use exact matching for Super variants to prevent false positives
    const hasSuperVariants = allFuelTypes.some(type => {
      // Normalize the type first by trimming and removing any text after a colon
      const normalizedType = type.split(':').pop().trim();
      return normalizedType === 'Super' || 
             normalizedType === 'Ultra' || 
             normalizedType === 'Super Premium';
    });
    
    if (hasSuperVariants) {
      logger.info('Premium with Super variant detected - using same prover as Regular');
      console.log('Premium with Super variant detected - using same prover as Regular');
      
      // Find prover for Regular
      for (const prover of proverPreferences.provers) {
        if (prover.preferred_fuel_types && prover.preferred_fuel_types.includes('Regular')) {
          logger.info(`Using Regular's preferred prover ${prover.prover_id} for Premium`);
          console.log(`Using Regular's preferred prover ${prover.prover_id} for Premium`);
          return prover.prover_id;
        }
      }
    }
  }
  
  // Sort provers by priority (lower number = higher priority)
  const sortedProvers = [...proverPreferences.provers].sort((a, b) => {
    return (a.priority || 999) - (b.priority || 999);
  });
  
  // Find the first prover that lists this fuel type as preferred
  for (const prover of sortedProvers) {
    if (prover.preferred_fuel_types && prover.preferred_fuel_types.length > 0) {
      for (const preferredType of prover.preferred_fuel_types) {
        if (baseFuelType.includes(preferredType)) {
          logger.info(`Found preferred prover ${prover.prover_id} for fuel type ${baseFuelType}`);
          return prover.prover_id;
        }
      }
    }
  }
  
  // If no specific match found, return the first prover's ID as default
  logger.info(`No preferred prover found for ${baseFuelType}, using default`);
  return sortedProvers[0].prover_id;
}

/**
 * Parse work order instructions to extract specific dispenser numbers
 * @param {string} instructions - The instructions text
 * @returns {array} - Array of dispenser objects with dispenser numbers
 */
function extractSpecificDispensers(instructions) {
  if (!instructions) {
    return [];
  }

  logger.info(`Parsing instructions for specific dispensers: ${instructions}`);
  logger.info(`RAW INSTRUCTIONS: "${instructions}"`);
  
  // Normalize the instructions text for better parsing:
  // 1. Replace newlines with spaces
  // 2. Convert "Dispenser #" variations to a standard format
  // 3. Handle comma-separated numbers
  let normalizedText = instructions
    .replace(/\n/g, ' ')
    .replace(/dispenser\s*#?\s*(\d+)/gi, 'Dispenser #$1')
    .replace(/pump\s*#?\s*(\d+)/gi, 'Dispenser #$1');
  
  logger.info(`NORMALIZED: "${normalizedText}"`);
  
  const dispensers = [];
  const processedNumbers = new Set();
  
  // Step 1: First extract explicit dispenser pairs (format: #3/4 or 3/4)
  const pairRegex = /#?(\d+)\/(\d+)/g;
  let pairMatch;
  
  while ((pairMatch = pairRegex.exec(normalizedText)) !== null) {
    const firstNumber = parseInt(pairMatch[1], 10);
    const secondNumber = parseInt(pairMatch[2], 10);
    
    // Skip invalid pairs or already processed numbers
    if (isNaN(firstNumber) || isNaN(secondNumber) || 
        processedNumbers.has(firstNumber) || processedNumbers.has(secondNumber)) {
      continue;
    }
    
    // Add both numbers to processed set
    processedNumbers.add(firstNumber);
    processedNumbers.add(secondNumber);
    
    // This is a dispenser pair like "3/4"
    const dispenserTitle = `Dispenser #${firstNumber}/${secondNumber}`;
    logger.info(`Found specific dispenser pair: ${dispenserTitle}`);
    
    dispensers.push({
      title: dispenserTitle,
      fields: {
        Grade: "Unknown" // Will be filled in later if available
      }
    });
  }
  
  // Step 2: Handle comma-separated or individual dispenser numbers
  // Format: "Dispensers 1, 3, 5" or "#1, #3, #5" or "Dispensers #1, 3, and 5"
  
  // Extract comma-separated numbers or single numbers
  const numberPattern = /(?:^|[^\d\/])(\d+)(?:[^\d\/]|$)/g;
  const numbersFound = [];
  let numberMatch;
  
  // Find all numbers in the instructions
  while ((numberMatch = numberPattern.exec(normalizedText)) !== null) {
    const number = parseInt(numberMatch[1], 10);
    
    // Skip invalid numbers or already processed numbers
    if (isNaN(number) || processedNumbers.has(number)) {
      continue;
    }
    
    numbersFound.push(number);
  }
  
  // For each individual number, create the appropriate dispenser
  for (const number of numbersFound) {
    processedNumbers.add(number);
    
    // Create a pair based on the number (odd numbers pair with next even, even numbers pair with previous odd)
    const pairNumber = number % 2 === 0 ? number - 1 : number + 1;
    const dispenserTitle = `Dispenser #${Math.min(number, pairNumber)}/${Math.max(number, pairNumber)}`;
    logger.info(`Found individual dispenser: ${number}, creating pair: ${dispenserTitle}`);
    
    dispensers.push({
      title: dispenserTitle,
      fields: {
        Grade: "Unknown" // Will be filled in later if available
      }
    });
  }
  
  // Remove duplicates (in case the same dispenser is mentioned multiple times)
  const uniqueDispensers = [];
  const titles = new Set();
  
  for (const dispenser of dispensers) {
    if (!titles.has(dispenser.title)) {
      titles.add(dispenser.title);
      uniqueDispensers.push(dispenser);
    }
  }
  
  logger.info(`Extracted ${uniqueDispensers.length} unique dispensers from instructions`);
  
  // IMPORTANT DEBUG: Log each extracted dispenser
  uniqueDispensers.forEach((dispenser, i) => {
    logger.info(`Extracted dispenser ${i+1}: ${dispenser.title}`);
  });
  
  return uniqueDispensers;
}

/**
 * Process a single visit
 * @param {string} visitUrl - URL of the visit to process
 * @param {boolean} headless - Whether to run browser in headless mode
 * @param {string} workOrderId - Optional work order ID to get dispenser data
 * @returns {Promise<object>} - Result of the operation
 */
async function processVisit(visitUrl, headless = true, workOrderId = null) {
  let browser = null;
  let page = null;
  
  try {
    logger.info(`Processing visit: ${visitUrl}`);
    updateStatus('running', `Processing visit: ${visitUrl}`);
    
    // Use the improved loginToFossa function from login.js
    const loginResult = await loginToFossa({ headless });
    
    if (!loginResult.success) {
      throw new Error('Failed to login to Fossa');
    }
    
    // Get the browser and page objects from the login result
    browser = loginResult.browser;
    page = loginResult.page;
    
    // Navigate to the visit page
    logger.info(`Navigating to visit: ${visitUrl}`);
    updateStatus('running', `Navigating to visit: ${visitUrl}`);
    await page.goto(visitUrl);
    await page.waitForLoadState('networkidle');
    
    // Get dispenser data and form count
    let dispensers = [];
    let formCount = 0;
    
    if (workOrderId) {
      logger.info(`=== DISPENSER IDENTIFICATION START: ${workOrderId} ===`);
      
      // First try to load dispensers from the standard JSON data file
      let dataPath = path.join(process.cwd(), 'data', 'scraped_content.json');
      let dispensersFound = false;
      let isSpecificDispensers = false;
      let instructions = '';
      
      if (fs.existsSync(dataPath)) {
        try {
        const data = JSON.parse(fs.readFileSync(dataPath, 'utf8'));
        const workOrder = data.workOrders.find(wo => wo.id === workOrderId);
        
          if (workOrder) {
            // Save instructions for later use
            instructions = workOrder.instructions || '';
            logger.info(`Found instructions for ${workOrderId}: "${instructions}"`);
            
            // Check if this is a specific dispenser work order
            if (workOrder.services && workOrder.services.length > 0) {
              // Log all services for debugging
              workOrder.services.forEach((service, index) => {
                logger.info(`Service ${index + 1}: Type=${service.type}, Quantity=${service.quantity}, Description=${service.description}`);
              });
              
              isSpecificDispensers = workOrder.services.some(service => 
                service.description && service.description.includes('Specific Dispenser(s)')
              );
              
              if (isSpecificDispensers) {
                logger.info(`DETECTED: Work order ${workOrderId} requires specific dispensers - checking instructions`);
              } else {
                logger.info(`This is not a specific dispenser work order, will use sequential dispensers`);
              }
            }
            
            // Get dispensers if available
            if (workOrder.dispensers && workOrder.dispensers.length > 0) {
          dispensers = workOrder.dispensers;
              logger.info(`Found ${dispensers.length} dispensers for work order ${workOrderId} in scraped_content.json`);
              dispensers.forEach((dispenser, index) => {
                logger.info(`Dispenser ${index + 1}: ${dispenser.title || 'No title'}`);
              });
              dispensersFound = true;
            }
            
            // Check services for quantity
            if (workOrder.services && workOrder.services.length > 0) {
              // Get the total quantity of dispensers from services
              formCount = workOrder.services.reduce((total, service) => {
                return total + (service.quantity || 0);
              }, 0);
              
              if (formCount > 0) {
                logger.info(`Found quantity of ${formCount} in services for work order ${workOrderId}`);
              }
            }
            
            // If this is a specific dispenser work order and we have instructions but no dispensers,
            // try to extract the specific dispensers from the instructions
            if (isSpecificDispensers && instructions) {
              logger.info(`SPECIFIC DISPENSERS: Analyzing instructions to extract dispenser numbers`);
              const specificDispensers = extractSpecificDispensers(instructions);
              
              if (specificDispensers.length > 0) {
                logger.info(`SUCCESS: Extracted ${specificDispensers.length} specific dispensers from instructions`);
                
                // If we already found dispensers elsewhere, log what we're replacing
                if (dispensersFound) {
                  logger.info(`REPLACING: Overriding ${dispensers.length} previously found dispensers with ${specificDispensers.length} specific dispensers`);
                  dispensers.forEach((dispenser, index) => {
                    logger.info(`Old dispenser ${index + 1}: ${dispenser.title || 'No title'}`);
                  });
                }
                
                dispensers = specificDispensers;
                dispensersFound = true;
                
                // Log the specific dispensers we found
                dispensers.forEach((dispenser, index) => {
                  logger.info(`New specific dispenser ${index + 1}: ${dispenser.title || 'No title'}`);
                });
                
                // IMPORTANT: Always set form count to exactly match the number of specific dispensers for specific dispenser case
                // This ensures we don't create more forms than we have specific dispensers
                formCount = specificDispensers.length;
                logger.info(`STRICT UPDATE: Setting form count to exactly ${formCount} to match number of specific dispensers`);
                
                // Save these dispensers to dispenser_store.json for future use
                try {
                  const dispenserStorePath = path.join(process.cwd(), 'data', 'dispenser_store.json');
                  let dispenserStoreData = {};
                  
                  if (fs.existsSync(dispenserStorePath)) {
                    dispenserStoreData = JSON.parse(fs.readFileSync(dispenserStorePath, 'utf8'));
                  }
                  
                  // Initialize dispenserData if it doesn't exist
                  if (!dispenserStoreData.dispenserData) {
                    dispenserStoreData.dispenserData = {};
                  }
                  
                  // Add the extracted dispensers to the store
                  dispenserStoreData.dispenserData[workOrderId] = {
                    dispensers: specificDispensers,
                    timestamp: new Date().toISOString()
                  };
                  
                  // Save the updated data
                  fs.writeFileSync(dispenserStorePath, JSON.stringify(dispenserStoreData, null, 2), 'utf8');
                  logger.info(`Saved specific dispensers for work order ${workOrderId} to dispenser_store.json`);
                } catch (error) {
                  logger.warn(`Error saving dispensers to dispenser_store.json: ${error.message}`);
                }
        } else {
                logger.warn(`FAILED: Could not extract specific dispensers from instructions: "${instructions}"`);
              }
            }
          }
        } catch (error) {
          logger.warn(`Error parsing scraped_content.json: ${error.message}`);
        }
      }
      
      // If dispensers weren't found, try the dispenser_store.json file
      if (!dispensersFound) {
        logger.info(`No dispensers found in scraped_content.json, checking dispenser_store.json`);
        
        const dispenserStorePath = path.join(process.cwd(), 'data', 'dispenser_store.json');
        if (fs.existsSync(dispenserStorePath)) {
          try {
            const dispenserStoreData = JSON.parse(fs.readFileSync(dispenserStorePath, 'utf8'));
            
            // Check if the work order exists in the dispenser store data
            if (dispenserStoreData.dispenserData && dispenserStoreData.dispenserData[workOrderId]) {
              const workOrderData = dispenserStoreData.dispenserData[workOrderId];
              
              if (workOrderData.dispensers && workOrderData.dispensers.length > 0) {
                dispensers = workOrderData.dispensers;
                logger.info(`Found ${dispensers.length} dispensers for work order ${workOrderId} in dispenser_store.json`);
                dispensers.forEach((dispenser, index) => {
                  logger.info(`Dispenser from store ${index + 1}: ${dispenser.title || 'No title'}`);
                });
                dispensersFound = true;
              }
            } else {
              // If the exact work order ID is not found, check if there's a matching ID with or without the "W-" prefix
              const normalizedWorkOrderId = workOrderId.replace(/^W-/, '');
              
              for (const storeWorkOrderId of Object.keys(dispenserStoreData.dispenserData || {})) {
                const normalizedStoreWorkOrderId = storeWorkOrderId.replace(/^W-/, '');
                
                if (normalizedWorkOrderId === normalizedStoreWorkOrderId || 
                    `W-${normalizedWorkOrderId}` === storeWorkOrderId || 
                    workOrderId === `W-${normalizedStoreWorkOrderId}`) {
                  
                  const workOrderData = dispenserStoreData.dispenserData[storeWorkOrderId];
                  
                  if (workOrderData.dispensers && workOrderData.dispensers.length > 0) {
                    dispensers = workOrderData.dispensers;
                    logger.info(`Found ${dispensers.length} dispensers for work order ${workOrderId} (matched as ${storeWorkOrderId}) in dispenser_store.json`);
                    dispensers.forEach((dispenser, index) => {
                      logger.info(`Dispenser from store ${index + 1}: ${dispenser.title || 'No title'}`);
                    });
                    dispensersFound = true;
                    break;
                  }
                }
              }
            }
          } catch (error) {
            logger.warn(`Error parsing dispenser_store.json: ${error.message}`);
          }
        } else {
          logger.warn('dispenser_store.json file not found');
        }
      }
      
      // If we still didn't find any dispensers, and this is a specific dispensers case,
      // try to extract them from instructions as a last resort
      if (!dispensersFound && isSpecificDispensers && instructions) {
        logger.info(`LAST RESORT: Attempting to extract specific dispensers from instructions one more time`);
        
        const specificDispensers = extractSpecificDispensers(instructions);
        
        if (specificDispensers.length > 0) {
          dispensers = specificDispensers;
          dispensersFound = true;
          logger.info(`Created ${dispensers.length} specific dispensers from instructions (fallback method)`);
          
          // Log the specific dispensers we found
          dispensers.forEach((dispenser, index) => {
            logger.info(`Fallback specific dispenser ${index + 1}: ${dispenser.title || 'No title'}`);
          });
          
          // Update form count to match the number of specific dispensers
          formCount = dispensers.length;
          logger.info(`Updated form count to ${formCount} based on specific dispensers`);
          
          // Save these dispensers to dispenser_store.json for future use
          try {
            const dispenserStorePath = path.join(process.cwd(), 'data', 'dispenser_store.json');
            let dispenserStoreData = {};
            
            if (fs.existsSync(dispenserStorePath)) {
              dispenserStoreData = JSON.parse(fs.readFileSync(dispenserStorePath, 'utf8'));
            }
            
            // Initialize dispenserData if it doesn't exist
            if (!dispenserStoreData.dispenserData) {
              dispenserStoreData.dispenserData = {};
            }
            
            // Add the extracted dispensers to the store
            dispenserStoreData.dispenserData[workOrderId] = {
              dispensers: specificDispensers,
              timestamp: new Date().toISOString()
            };
            
            // Save the updated data
            fs.writeFileSync(dispenserStorePath, JSON.stringify(dispenserStoreData, null, 2), 'utf8');
            logger.info(`Saved specific dispensers for work order ${workOrderId} to dispenser_store.json`);
          } catch (error) {
            logger.warn(`Error saving dispensers to dispenser_store.json: ${error.message}`);
        }
      } else {
          logger.warn(`Fallback extraction also failed to find specific dispensers in instructions`);
        }
      }
      
      // If we still didn't find any dispensers, log a warning
      if (!dispensersFound) {
        logger.warn(`No dispensers found for work order ${workOrderId}`);
      }
      
      // If we couldn't find a quantity, use the number of dispensers
      if (formCount === 0 && dispensers.length > 0) {
        formCount = dispensers.length;
        logger.info(`Using dispenser count (${formCount}) as form count`);
      }
      
      logger.info(`=== DISPENSER IDENTIFICATION COMPLETE: Using ${dispensers.length} dispensers and ${formCount} forms ===`);
      
      // Final logging of the dispensers we'll be using
      if (dispensers.length > 0) {
        logger.info(`Final dispensers to be used:`);
        dispensers.forEach((dispenser, index) => {
          logger.info(`  ${index + 1}. ${dispenser.title || 'No title'}`);
        });
      }
      
      updateStatus('running', `Found ${dispensers.length} dispensers, creating ${formCount} forms for work order ${workOrderId}`);
    } else {
      logger.warn('No work order ID provided');
      updateStatus('running', 'No work order ID provided');
    }
    
    // Prepare the form with dispenser data
    const prepareSuccess = await prepareForm(page, dispensers, formCount);
    
    // Wait a moment for any final operations to complete
    await page.waitForTimeout(2000);
    
    // Return result but DON'T set status to completed here - that's already handled by fillFormDetails
    if (prepareSuccess) {
      // Check the current status - if it's still running, the form filling may not have completed properly
      if (currentStatus.status === 'running') {
        logger.warn('Form preparation reported success but status is still running - setting status to completed');
        updateStatus('completed', 'Visit processing completed, but may have encountered issues');
      }
      
      return { success: true, message: 'Visit processed successfully' };
    } else {
      updateStatus('error', 'Failed to prepare form');
      return { success: false, message: 'Failed to prepare form' };
    }
  } catch (error) {
    logger.error(`Visit processing error: ${error.message}`);
    updateStatus('error', `Visit processing error: ${error.message}`);
    return { success: false, message: `Error: ${error.message}` };
  } finally {
    if (browser) {
      await browser.close();
    }
  }
}

/**
 * Process a batch of visits from a JSON file
 * @param {string} filePath - Path to the JSON file with visit data
 * @param {boolean} headless - Whether to run browser in headless mode
 * @returns {Promise<object>} - Result of the operation
 */
async function processBatch(filePath, headless = true) {
  let browser = null;
  let page = null;
  
  try {
    logger.info(`Processing batch from: ${filePath}`);
    updateBatchStatus('running', `Starting batch processing from: ${filePath}`);
    
    // Load the data file
    const dataPath = path.join(process.cwd(), filePath);
    if (!fs.existsSync(dataPath)) {
      throw new Error(`Data file not found: ${filePath}`);
    }
    
    const data = JSON.parse(fs.readFileSync(dataPath, 'utf8'));
    
    // Extract visits that need processing
    const visitsToProcess = [];
    
    for (const workOrder of data.workOrders) {
      if (
        workOrder.visits && 
        workOrder.visits.nextVisit && 
        workOrder.visits.nextVisit.url
      ) {
        let formCount = 0;
        let dispensers = [];
        
        // Get dispensers if available
        if (workOrder.dispensers && workOrder.dispensers.length > 0) {
          dispensers = workOrder.dispensers;
        }
        
        // Check services for quantity
        if (workOrder.services && workOrder.services.length > 0) {
          // Get the total quantity of dispensers from services
          formCount = workOrder.services.reduce((total, service) => {
            return total + (service.quantity || 0);
          }, 0);
        }
        
        // If we couldn't find a quantity, use the number of dispensers
        if (formCount === 0 && dispensers.length > 0) {
          formCount = dispensers.length;
        }
        
        // Only add to processing if we have either dispensers or a form count
        if (formCount > 0 || dispensers.length > 0) {
        visitsToProcess.push({
          id: workOrder.id,
          url: `https://app.workfossa.com${workOrder.visits.nextVisit.url}`,
            dispensers: dispensers,
            formCount: formCount
        });
        }
      }
    }
    
    if (visitsToProcess.length === 0) {
      logger.warn('No valid visits found to process');
      updateBatchStatus('completed', 'No valid visits found to process', {
        totalVisits: 0,
        completedVisits: 0
      });
      return { success: false, message: 'No valid visits found to process' };
    }
    
    // Update batch status
    updateBatchStatus('running', `Found ${visitsToProcess.length} visits to process`, {
      totalVisits: visitsToProcess.length,
      completedVisits: 0
    });
    logger.info(`Found ${visitsToProcess.length} visits to process`);
    
    // Use the improved loginToFossa function from login.js
    const loginResult = await loginToFossa({ headless });
    
    if (!loginResult.success) {
      throw new Error('Failed to login to Fossa');
    }
    
    // Get the browser and page objects from the login result
    browser = loginResult.browser;
    page = loginResult.page;
    
    // Process each visit
    for (let i = 0; i < visitsToProcess.length; i++) {
      const visit = visitsToProcess[i];
      const visitStartTime = new Date();
      
      try {
        logger.info(`Processing visit ${i + 1}/${visitsToProcess.length}: ${visit.url}`);
        updateBatchStatus('running', `Processing visit ${i + 1}/${visitsToProcess.length}: Work Order ${visit.id}`, {
          currentVisit: visit.id,
          currentVisitStatus: "Starting"
        });
        
        // Navigate to the visit page
        await page.goto(visit.url);
        await page.waitForLoadState('networkidle');
        
        // Reset the current status to running before starting this visit
        updateStatus('running', `Processing visit for Work Order ${visit.id}`);
        updateBatchStatus('running', `Processing visit ${i + 1}/${visitsToProcess.length}: Work Order ${visit.id}`, {
          currentVisitStatus: `Processing visit for Work Order ${visit.id}`
        });
        
        // Prepare the form with dispenser data and form count
        await prepareForm(page, visit.dispensers, visit.formCount);
        
        // Wait for the visit processing to complete by checking the currentStatus
        let waitCount = 0;
        const maxWaitCount = 300; // Increase timeout to 5 minutes (300 seconds)
        
        while (currentStatus.status === 'running' && waitCount < maxWaitCount) {
          await page.waitForTimeout(1000);
          waitCount++;
          
          // Update batch status with current visit status
          updateBatchStatus('running', `Processing visit ${i + 1}/${visitsToProcess.length}: Work Order ${visit.id}`, {
            currentVisitStatus: currentStatus.message
          });
          
          // Every 10 seconds, log a progress update
          if (waitCount % 10 === 0) {
            const elapsedSeconds = waitCount;
            logger.info(`Still processing visit ${i + 1}/${visitsToProcess.length} (Work Order ${visit.id}) - ${elapsedSeconds}s elapsed`);
            logger.info(`Current status: ${currentStatus.message}`);
          }
        }
        
        // Check if we hit the timeout
        if (waitCount >= maxWaitCount) {
          logger.warn(`Visit processing timeout after ${maxWaitCount} seconds for Work Order ${visit.id}`);
          updateStatus('completed', `Visit processing timed out after ${maxWaitCount} seconds`);
        }
        
        // Update completed count after we're sure processing is done
        const visitEndTime = new Date();
        const visitDuration = (visitEndTime - visitStartTime) / 1000; // in seconds
        logger.info(`Completed visit ${i + 1}/${visitsToProcess.length} (Work Order ${visit.id}) in ${visitDuration.toFixed(1)} seconds`);
        
        updateBatchStatus('running', `Completed visit ${i + 1}/${visitsToProcess.length}: Work Order ${visit.id} in ${visitDuration.toFixed(1)}s`, {
          completedVisits: batchStatus.completedVisits + 1
        });
        
      } catch (error) {
        logger.error(`Error processing visit ${visit.url}: ${error.message}`);
        // Continue with the next visit even if one fails
      }
    }
    
    // Update batch status
    const endTime = new Date();
    const startTime = new Date(batchStatus.startTime);
    const totalDuration = (endTime - startTime) / 1000 / 60; // in minutes
    
    updateBatchStatus('completed', `Batch processing completed. Processed ${batchStatus.completedVisits}/${batchStatus.totalVisits} visits in ${totalDuration.toFixed(1)} minutes.`, {
      endTime: endTime.toISOString(),
      durationMinutes: totalDuration.toFixed(1),
      currentVisit: null,
      currentVisitStatus: null
    });
    
    logger.info(`Batch processing completed. Processed ${batchStatus.completedVisits}/${batchStatus.totalVisits} visits in ${totalDuration.toFixed(1)} minutes.`);
    
    return { 
      success: true, 
      message: `Batch processing completed. Processed ${batchStatus.completedVisits}/${batchStatus.totalVisits} visits in ${totalDuration.toFixed(1)} minutes.` 
    };
    
  } catch (error) {
    logger.error(`Batch processing error: ${error.message}`);
    updateBatchStatus('error', `Batch processing error: ${error.message}`, {
      endTime: new Date().toISOString()
    });
    return { success: false, message: `Error: ${error.message}` };
  } finally {
    if (browser) {
      await browser.close();
    }
  }
}

/**
 * Get the current status of form automation
 * @returns {object} - Current status
 */
function getStatus() {
  // Ensure the status object always has the required properties
  return {
    ...currentStatus,
    lastStatusUpdate: currentStatus.lastStatusUpdate || new Date().toISOString()
  };
}

/**
 * Get the current status of batch automation
 * @returns {object} - Current batch status
 */
function getBatchStatus() {
  // Ensure the batch status object always has the required properties
  return {
    ...batchStatus,
    lastStatusUpdate: batchStatus.lastStatusUpdate || new Date().toISOString()
  };
}

// Add testExtractSpecificDispensers after the extractSpecificDispensers function
/**
 * Test function to extract specific dispensers from a string
 * @param {string} instructionsText - The instructions text
 * @returns {array} - Array of dispenser objects
 */
function testExtractSpecificDispensers(instructionsText) {
  console.log(`Testing extraction of specific dispensers from: ${instructionsText}`);
  const result = extractSpecificDispensers(instructionsText);
  console.log(`Extracted ${result.length} dispensers:`, result);
  return result;
}

// ... rest of existing code ...

// At the end of the file, add the exports
export {
  processVisit,
  processBatch,
  getStatus,
  getBatchStatus,
  // Add this for testing
  testExtractSpecificDispensers
}; 