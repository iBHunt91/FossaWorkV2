/**
 * Form Automation Script
 * 
 * This script automates the process of adding AccuMeasure forms to Fossa visits
 * and filling them with dispenser information.
 */
import { chromium } from 'playwright';
import path from 'path';
import fs from 'fs';
import dotenv from 'dotenv';
import * as logger from '../utils/logger.js';
import { loginToFossa } from '../../scripts/utils/login.js';

// Load environment variables
dotenv.config();

// Status tracking
let currentStatus = {
  status: 'idle',
  message: 'Ready to process forms',
};

// Batch status tracking
let batchStatus = {
  status: 'idle',
  message: 'Ready to process batch',
  totalVisits: 0,
  completedVisits: 0,
};

/**
 * Add AccuMeasure form to a visit
 * @param {object} page - Playwright page
 * @param {number} formCount - Number of forms to create
 * @returns {Promise<boolean>} - Success/failure of form preparation
 */
async function prepareForm(page, dispensers, formCount = null) {
  try {
    logger.info('Preparing AccuMeasure form...');
    currentStatus = { status: 'running', message: 'Preparing AccuMeasure form...' };
    
    // Check if we're on a visit page
    const isVisitPage = await page.evaluate(() => {
      return window.location.href.includes('/visits/');
    });
    
    if (!isVisitPage) {
      throw new Error('Not on a visit page');
    }
    
    // Use formCount if provided, otherwise default to dispensers length
    const formsToCreate = formCount || dispensers.length || 1;
    logger.info(`Need to create ${formsToCreate} AccuMeasure forms`);
    
    // More reliable form detection - check for form entries with AccuMeasure
    const getFormCount = async () => {
      await page.waitForTimeout(300); // Brief pause to ensure DOM is updated
      return page.evaluate(() => {
        // Multiple ways to detect AccuMeasure forms
        const linkForms = Array.from(document.querySelectorAll('a.none')).filter(a => 
          a.textContent.trim().includes('AccuMeasure')
        );
        
        const spanForms = Array.from(document.querySelectorAll('span.text-sm')).filter(span => 
          span.textContent.trim().includes('AccuMeasure') && 
          span.closest('a') !== null
        );
        
        // Return the count that seems most accurate (non-zero if possible)
        return Math.max(linkForms.length, spanForms.length);
      });
    };
    
    // Get initial form count
    const existingFormCount = await getFormCount();
    logger.info(`Found ${existingFormCount} existing AccuMeasure forms`);
    
    // Calculate how many more forms we need to add
    const remainingFormsToAdd = Math.max(0, formsToCreate - existingFormCount);
    logger.info(`Need to add ${remainingFormsToAdd} more AccuMeasure forms`);
    
    let formsCreated = false;
    
    if (remainingFormsToAdd === 0) {
      logger.info('All required forms already exist, skipping form addition');
      currentStatus = { status: 'completed', message: 'All required forms already exist' };
      // Don't return early - continue to collect and fill form URLs
    } else {
      // Keep track of total forms added
      let totalFormsAdded = 0;
      
      // For each form we need to create
      for (let formIndex = 0; formIndex < remainingFormsToAdd; formIndex++) {
        // Check current form count before adding
        const currentCount = await getFormCount();
        
        // Stop if we've already reached or exceeded the target
        if (currentCount >= formsToCreate) {
          logger.info(`Already reached target of ${formsToCreate} forms (current: ${currentCount}), stopping`);
          break;
        }
        
        logger.info(`Adding form ${formIndex + 1} of ${remainingFormsToAdd} (current count: ${currentCount})`);
        
        // Get the current form count before adding a new one
        const beforeFormCount = currentCount;
        
        // Add the form - either "Attach" (first time) or "New" (subsequent times)
        if (formIndex === 0 && existingFormCount === 0) {
          // For the first form when no forms exist, click "Attach"
          logger.info('Adding first form using Attach button');
          
          // Using a more specific selector to target the Attach button next to AccuMeasure
          const attachLinkSelector = 'li.plain-header:has-text("AccuMeasure") a:has-text("Attach")';
          
          try {
            await page.waitForSelector(attachLinkSelector, { timeout: 5000 });
            await page.click(attachLinkSelector);
            logger.info('Clicked Attach button next to AccuMeasure');
          } catch (error) {
            logger.warn(`Could not find specific Attach button: ${error.message}`);
            
            // Try using JavaScript evaluation as a fallback
            const attached = await page.evaluate(() => {
              // Find the AccuMeasure text element
              const accuElements = Array.from(document.querySelectorAll('span.text-sm')).filter(el => 
                el.textContent.includes('AccuMeasure')
              );
              
              if (accuElements.length > 0) {
                // Find the Attach link near it
                const accuElement = accuElements[0];
                const parent = accuElement.closest('li.plain-header') || accuElement.parentElement;
                
                if (parent) {
                  const attachLink = parent.querySelector('a[title*="Attach"]') || 
                                    Array.from(parent.querySelectorAll('a')).find(a => 
                                      a.textContent.trim() === 'Attach'
                                    );
                  
                  if (attachLink) {
                    attachLink.click();
                    return true;
                  }
                }
              }
              
              return false;
            });
            
            if (!attached) {
              throw new Error('Failed to find and click Attach button');
            }
          }
        } else {
          // For subsequent forms or when forms already exist, click "New"
          logger.info('Adding additional form using New button');
          
          // Using a much more targeted approach to find the correct New button
          const buttonClicked = await page.evaluate(() => {
            // First, try to find the AccuMeasure section
            const accuElements = Array.from(document.querySelectorAll('span.text-sm, div.text-sm')).filter(el => 
              el.textContent.includes('AccuMeasure')
            );
            
            if (accuElements.length > 0) {
              // Look for the closest New button near the AccuMeasure element
              const accumeasureElement = accuElements[0];
              // Go up to find common parent
              let parent = accumeasureElement.parentElement;
              for (let i = 0; i < 5; i++) { // Go up max 5 levels
                if (!parent) break;
                
                // Look for New button or + icon in this parent or its siblings
                const newButtonsInContext = Array.from(
                  parent.querySelectorAll('a')
                ).filter(a => 
                  a.textContent.trim().includes('New') || 
                  a.querySelector('svg.fa-plus')
                );
                
                if (newButtonsInContext.length > 0) {
                  // Found the right button in context!
                  newButtonsInContext[0].click();
                  return true;
                }
                
                // Try parent's next sibling - for cases where buttons are adjacent
                if (parent.nextElementSibling) {
                  const siblingButtons = Array.from(
                    parent.nextElementSibling.querySelectorAll('a')
                  ).filter(a => 
                    a.textContent.trim().includes('New') || 
                    a.querySelector('svg.fa-plus')
                  );
                  
                  if (siblingButtons.length > 0) {
                    siblingButtons[0].click();
                    return true;
                  }
                }
                
                parent = parent.parentElement;
              }
            }
            
            // If still not found, look specifically in the suggested forms section
            const suggestedForms = document.querySelector('div[dusk="suggested_forms"]');
            if (suggestedForms) {
              const newButtons = Array.from(
                suggestedForms.querySelectorAll('a.text-xs')
              ).filter(a => 
                a.textContent.trim().includes('New') || 
                a.querySelector('svg.fa-plus')
              );
              
              if (newButtons.length > 0) {
                newButtons[0].click();
                return true;
              }
            }
            
            return false;
          });
          
          if (!buttonClicked) {
            logger.warn('Could not find New button via targeted JavaScript, trying fallback method');
            
            // Try a direct click with very specific selectors
            try {
              // Try more specific selector first
              const specificSelectors = [
                'div[dusk="suggested_forms"] a.text-xs:has(svg.fa-plus)',
                'a.text-xs:has-text("New"):not([title])',
                '.panel-body a:has(svg.fa-plus)',
                'a.text-xs:has(svg.fa-plus)'
              ];
              
              let clicked = false;
              for (const selector of specificSelectors) {
                if (await page.$(selector)) {
                  await page.click(selector);
                  clicked = true;
                  logger.info(`Clicked using selector: ${selector}`);
                  break;
                }
              }
              
              if (!clicked) {
                throw new Error('Could not find New button with any selector');
              }
            } catch (error) {
              logger.error(`Failed to click New button: ${error.message}`);
            }
          }
        }
        
        // Wait for the loader to disappear, indicating the form is ready
        logger.info('Waiting for loader to disappear...');
        try {
          // Wait for the loader line to disappear (display:none)
          await page.waitForFunction(() => {
            const loaders = document.querySelectorAll('.loader-line');
            for (const loader of loaders) {
              if (window.getComputedStyle(loader).display !== 'none') {
                return false;
              }
            }
            return true;
          }, { timeout: 10000 });
          logger.info('Loader disappeared, form is ready');
        } catch (error) {
          logger.warn(`Loader wait timed out: ${error.message}`);
        }
        
        // Check if the form count has increased using our more reliable method
        const afterFormCount = await getFormCount();
        
        // If form count hasn't increased, retry
        if (afterFormCount <= beforeFormCount) {
          logger.warn(`Form count didn't increase (${beforeFormCount} -> ${afterFormCount}). Retrying...`);
          
          // Try clicking again using a different approach
          try {
            await page.click('a:has-text("New")');
            
            // Wait again for the loader
            await page.waitForFunction(() => {
              const loaders = document.querySelectorAll('.loader-line');
              for (const loader of loaders) {
                if (window.getComputedStyle(loader).display !== 'none') {
                  return false;
                }
              }
              return true;
            }, { timeout: 10000 });
            
            // Check form count again
            const retryFormCount = await getFormCount();
            
            if (retryFormCount <= beforeFormCount) {
              logger.error(`Failed to add form after retry (count: ${retryFormCount})`);
              formIndex--; // Try this form index again
              continue;
            } else {
              // Success after retry
              totalFormsAdded++;
            }
          } catch (error) {
            logger.error(`Error during retry: ${error.message}`);
            formIndex--; // Try this form index again
            continue;
          }
        } else {
          // Form was added successfully
          totalFormsAdded++;
          logger.info(`Form ${formIndex + 1} added successfully (count: ${afterFormCount})`);
        }
        
        // Double-check that we haven't exceeded our target
        if (afterFormCount >= formsToCreate) {
          logger.info(`Reached target of ${formsToCreate} forms (current: ${afterFormCount}), stopping`);
          break;
        }
        
        // Just a tiny pause before adding the next form
        await page.waitForTimeout(500);
      }
      
      // Final verification
      const finalFormCount = await getFormCount();
      
      logger.info(`Forms prepared successfully. Added ${totalFormsAdded} forms. Final form count: ${finalFormCount}`);
      currentStatus = { 
        status: 'completed', 
        message: `Forms prepared successfully. Added ${totalFormsAdded} forms (total: ${finalFormCount})` 
      };
      
      formsCreated = true;
    }
    
    // Whether we added new forms or not, collect the form URLs
    logger.info('Collecting form URLs...');
    const formUrls = await page.evaluate(() => {
      const formLinks = Array.from(document.querySelectorAll('a.none')).filter(a => 
        a.textContent.trim().includes('AccuMeasure')
      );
      
      return formLinks.map(link => link.href);
    });
    
    logger.info(`Found ${formUrls.length} form URLs`);
    
    // If we have dispensers data and form URLs, fill out each form
    if (dispensers.length > 0 && formUrls.length > 0) {
      logger.info('Proceeding to fill form details');
      await fillFormDetails(page, formUrls, dispensers);
    } else {
      if (formUrls.length === 0) {
        logger.warn('No form URLs found to process');
      }
      if (dispensers.length === 0) {
        logger.warn('No dispenser data available for forms');
      }
    }
    
    return true;
  } catch (error) {
    logger.error(`Form preparation error: ${error.message}`);
    currentStatus = { status: 'error', message: `Form preparation error: ${error.message}` };
    return false;
  }
}

/**
 * Fill out the details for each form
 * @param {object} page - Playwright page
 * @param {array} formUrls - Array of form URLs
 * @param {array} dispensers - Array of dispenser objects
 * @returns {Promise<void>}
 */
async function fillFormDetails(page, formUrls, dispensers) {
  try {
    logger.info('Starting to fill form details...');
    currentStatus = { status: 'running', message: 'Filling form details...' };
    
    // Process forms in order
    for (let i = 0; i < formUrls.length; i++) {
      const formUrl = formUrls[i];
      // Use the dispenser matching this form's index, or the first dispenser if we run out
      const dispenser = dispensers[i] || dispensers[0];
      
      logger.info(`Processing form ${i + 1}/${formUrls.length}: ${formUrl}`);
      currentStatus = { 
        status: 'running', 
        message: `Filling form ${i + 1}/${formUrls.length} with dispenser data` 
      };
      
      // Navigate to the form URL
      await page.goto(formUrl);
      await page.waitForLoadState('networkidle');
      
      // Wait for the form to load
      await page.waitForSelector('.form-entry-equipment', { state: 'visible', timeout: 10000 });
      
      // Fill the Equipment Dispenser dropdown
      logger.info(`Selecting dispenser: ${dispenser.title || 'Unknown'}`);
      
      try {
        // First, check if the dropdown is already open
        const isDropdownOpen = await page.evaluate(() => {
          return document.querySelector('.ks-select-dropdown') !== null && 
                 window.getComputedStyle(document.querySelector('.ks-select-dropdown')).display !== 'none';
        });
        
        if (!isDropdownOpen) {
          // Click the dropdown to open it
          await page.click('.ks-select-selection');
          logger.info('Clicked dropdown to open it');
          
          // Wait for dropdown to appear
          await page.waitForSelector('.ks-select-dropdown', { state: 'visible', timeout: 5000 });
        }
        
        // Wait for the dropdown list to populate
        await page.waitForSelector('.autocomplete-list li', { state: 'visible', timeout: 5000 });
        
        // Find and click the option matching our dispenser title
        const dispenserSelected = await page.evaluate((dispenserTitle) => {
          // Get all list items
          const options = Array.from(document.querySelectorAll('.autocomplete-list li'));
          
          // Find the one with our dispenser title
          for (const option of options) {
            if (option.textContent.trim().includes(dispenserTitle)) {
              option.click();
              return true;
            }
          }
          
          return false;
        }, dispenser.title);
        
        if (dispenserSelected) {
          logger.info(`Selected dispenser: ${dispenser.title}`);
        } else {
          logger.warn(`Could not find dispenser with title: ${dispenser.title}`);
        }
      } catch (error) {
        logger.warn(`Error selecting dispenser: ${error.message}`);
      }
      
      // Select the 5 Gallon radio button
      try {
        logger.info('Selecting 5 Gallon prover size');
        
        // Directly target the first radio button using the HTML structure
        const radioSelected = await page.evaluate(() => {
          // Find all radio groups
          const radioGroups = document.querySelectorAll('.ks-radio-group');
          
          // Look for the one with "5 Gallon" text
          for (const group of radioGroups) {
            const radioLabels = group.querySelectorAll('.ks-radio');
            
            for (const label of radioLabels) {
              if (label.textContent.trim() === '5 Gallon') {
                // Click the input inside this label
                const radioInput = label.querySelector('input[type="radio"]');
                if (radioInput) {
                  radioInput.click();
                  return true;
                }
              }
            }
          }
          
          // Try by input name and value if label approach didn't work
          const inputs = document.querySelectorAll('input[type="radio"]');
          for (const input of inputs) {
            const label = input.closest('label');
            if (label && label.textContent.trim() === '5 Gallon') {
              input.click();
              return true;
            }
          }
          
          return false;
        });
        
        if (radioSelected) {
          logger.info('Selected 5 Gallon radio button');
        } else {
          logger.warn('Could not find 5 Gallon radio button by label text');
          
          // Try a more direct approach
          const found = await page.evaluate(() => {
            // Try matching by position (first radio in group)
            const radioGroups = document.querySelectorAll('.ks-radio-group');
            for (const group of radioGroups) {
              const firstRadio = group.querySelector('input[type="radio"]');
              if (firstRadio) {
                firstRadio.click();
                return true;
              }
            }
            
            // Try by specific name attribute
            const radiosByName = document.querySelectorAll('input[name^="field"][type="radio"]');
            if (radiosByName.length > 0) {
              // Get all radios with the same name as the first one
              const name = radiosByName[0].name;
              const sameNameRadios = document.querySelectorAll(`input[name="${name}"][type="radio"]`);
              // Click the first one in this group
              if (sameNameRadios.length > 0) {
                sameNameRadios[0].click();
                return true;
              }
            }
            
            return false;
          });
          
          if (found) {
            logger.info('Selected 5 Gallon radio button by position');
          } else {
            logger.warn('Failed to select any radio button');
          }
        }
      } catch (error) {
        logger.warn(`Error selecting 5 Gallon: ${error.message}`);
      }
      
      // Click the Save button
      try {
        logger.info('Saving form');
        
        // Use the exact save button selector from the HTML
        const saveButtonSelector = '.button.vault-button.save-section';
        const saveButtonExists = await page.$(saveButtonSelector);
        
        if (saveButtonExists) {
          await page.click(saveButtonSelector);
          logger.info('Clicked Save button');
        } else {
          // Try alternative methods
          const saveClicked = await page.evaluate(() => {
            // Try various selector approaches
            const saveButtons = [
              ...document.querySelectorAll('button.button.vault-button'),
              ...document.querySelectorAll('button:has-text("Save")'),
              ...document.querySelectorAll('input[type="submit"]'),
              ...document.querySelectorAll('a.button')
            ].filter(el => {
              const text = el.textContent.trim().toLowerCase();
              return text === 'save' || text.includes('save');
            });
            
            if (saveButtons.length > 0) {
              saveButtons[0].click();
              return true;
            }
            
            return false;
          });
          
          if (saveClicked) {
            logger.info('Clicked Save using JavaScript evaluation');
          } else {
            logger.warn('Could not find Save button');
          }
        }
        
        // Wait for save to complete - either by network activity completing
        // or by the error message appearing (which indicates the form processed)
        logger.info('Waiting for form submission to complete...');
        
        try {
          // First wait for network activity to settle
          await page.waitForLoadState('networkidle', { timeout: 5000 });
          
          // Then try to detect the error message which indicates the form was processed
          const errorDetected = await Promise.race([
            page.waitForSelector('.error-msg.show-msg', { timeout: 5000 })
              .then(() => {
                logger.info('Form processed - validation error detected');
                return true;
              })
              .catch(() => false),
            new Promise(resolve => setTimeout(() => resolve(false), 5000))
          ]);
          
          if (errorDetected) {
            logger.info('Form was processed successfully (with validation errors)');
          } else {
            logger.info('Form appears to be saved without validation errors');
          }
        } catch (waitError) {
          logger.warn(`Wait error: ${waitError.message}`);
        }
        
        // Additional short wait to ensure everything is settled
        await page.waitForTimeout(1000);
      } catch (error) {
        logger.warn(`Error saving form: ${error.message}`);
      }
      
      // Wait briefly before processing the next form
      await page.waitForTimeout(2000);
    }
    
    logger.info('Form details filled successfully');
    currentStatus = { status: 'completed', message: 'Form details filled successfully' };
  } catch (error) {
    logger.error(`Error filling form details: ${error.message}`);
    currentStatus = { status: 'error', message: `Error filling form details: ${error.message}` };
  }
}

/**
 * Process a single visit
 * @param {string} visitUrl - URL of the visit to process
 * @param {boolean} headless - Whether to run browser in headless mode
 * @param {string} workOrderId - Optional work order ID to get dispenser data
 * @returns {Promise<object>} - Result of the operation
 */
async function processVisit(visitUrl, headless = true, workOrderId = null) {
  let browser = null;
  let page = null;
  
  try {
    logger.info(`Processing visit: ${visitUrl}`);
    currentStatus = { status: 'running', message: `Processing visit: ${visitUrl}` };
    
    // Use the improved loginToFossa function from login.js
    const loginResult = await loginToFossa({ headless });
    
    if (!loginResult.success) {
      throw new Error('Failed to login to Fossa');
    }
    
    // Get the browser and page objects from the login result
    browser = loginResult.browser;
    page = loginResult.page;
    
    // Navigate to the visit page
    logger.info(`Navigating to visit: ${visitUrl}`);
    currentStatus = { status: 'running', message: `Navigating to visit: ${visitUrl}` };
    await page.goto(visitUrl);
    await page.waitForLoadState('networkidle');
    
    // Get dispenser data and form count
    let dispensers = [];
    let formCount = 0;
    
    if (workOrderId) {
      // First try to load dispensers from the standard JSON data file
      let dataPath = path.join(process.cwd(), 'data', 'scraped_content.json');
      let dispensersFound = false;
      
      if (fs.existsSync(dataPath)) {
        try {
          const data = JSON.parse(fs.readFileSync(dataPath, 'utf8'));
          const workOrder = data.workOrders.find(wo => wo.id === workOrderId);
          
          if (workOrder) {
            // Get dispensers if available
            if (workOrder.dispensers && workOrder.dispensers.length > 0) {
              dispensers = workOrder.dispensers;
              logger.info(`Found ${dispensers.length} dispensers for work order ${workOrderId} in scraped_content.json`);
              dispensersFound = true;
            }
            
            // Check services for quantity
            if (workOrder.services && workOrder.services.length > 0) {
              // Get the total quantity of dispensers from services
              formCount = workOrder.services.reduce((total, service) => {
                return total + (service.quantity || 0);
              }, 0);
              
              if (formCount > 0) {
                logger.info(`Found quantity of ${formCount} in services for work order ${workOrderId}`);
              }
            }
          }
        } catch (error) {
          logger.warn(`Error parsing scraped_content.json: ${error.message}`);
        }
      }
      
      // If dispensers weren't found, try the dispenser_store.json file
      if (!dispensersFound) {
        const dispenserStorePath = path.join(process.cwd(), 'data', 'dispenser_store.json');
        if (fs.existsSync(dispenserStorePath)) {
          try {
            const dispenserStoreData = JSON.parse(fs.readFileSync(dispenserStorePath, 'utf8'));
            
            // Check if the work order exists in the dispenser store data
            if (dispenserStoreData.dispenserData && dispenserStoreData.dispenserData[workOrderId]) {
              const workOrderData = dispenserStoreData.dispenserData[workOrderId];
              
              if (workOrderData.dispensers && workOrderData.dispensers.length > 0) {
                dispensers = workOrderData.dispensers;
                logger.info(`Found ${dispensers.length} dispensers for work order ${workOrderId} in dispenser_store.json`);
                dispensersFound = true;
              }
            } else {
              // If the exact work order ID is not found, check if there's a matching ID with or without the "W-" prefix
              const normalizedWorkOrderId = workOrderId.replace(/^W-/, '');
              
              for (const storeWorkOrderId of Object.keys(dispenserStoreData.dispenserData || {})) {
                const normalizedStoreWorkOrderId = storeWorkOrderId.replace(/^W-/, '');
                
                if (normalizedWorkOrderId === normalizedStoreWorkOrderId || 
                    `W-${normalizedWorkOrderId}` === storeWorkOrderId || 
                    workOrderId === `W-${normalizedStoreWorkOrderId}`) {
                  
                  const workOrderData = dispenserStoreData.dispenserData[storeWorkOrderId];
                  
                  if (workOrderData.dispensers && workOrderData.dispensers.length > 0) {
                    dispensers = workOrderData.dispensers;
                    logger.info(`Found ${dispensers.length} dispensers for work order ${workOrderId} (matched as ${storeWorkOrderId}) in dispenser_store.json`);
                    dispensersFound = true;
                    break;
                  }
                }
              }
            }
          } catch (error) {
            logger.warn(`Error parsing dispenser_store.json: ${error.message}`);
          }
        } else {
          logger.warn('dispenser_store.json file not found');
        }
      }
      
      // If we still didn't find any dispensers, log a warning
      if (!dispensersFound) {
        logger.warn(`No dispensers found for work order ${workOrderId}`);
      }
      
      // If we couldn't find a quantity, use the number of dispensers
      if (formCount === 0 && dispensers.length > 0) {
        formCount = dispensers.length;
        logger.info(`Using dispenser count (${formCount}) as form count`);
      }
      
      currentStatus = { 
        status: 'running', 
        message: `Found ${dispensers.length} dispensers, creating ${formCount} forms for work order ${workOrderId}` 
      };
    } else {
      logger.warn('No work order ID provided');
      currentStatus = { 
        status: 'running', 
        message: 'No work order ID provided' 
      };
    }
    
    // Prepare the form with dispenser data
    const prepareSuccess = await prepareForm(page, dispensers, formCount);
    
    // Wait a moment to ensure everything is saved
    await page.waitForTimeout(1000);
    
    // Return result
    if (prepareSuccess) {
      currentStatus = { status: 'completed', message: 'Visit processed successfully' };
      return { success: true, message: 'Visit processed successfully' };
    } else {
      return { success: false, message: 'Failed to prepare form' };
    }
  } catch (error) {
    logger.error(`Visit processing error: ${error.message}`);
    currentStatus = { status: 'error', message: `Visit processing error: ${error.message}` };
    return { success: false, message: `Error: ${error.message}` };
  } finally {
    if (browser) {
      await browser.close();
    }
  }
}

/**
 * Process a batch of visits from a JSON file
 * @param {string} filePath - Path to the JSON file with visit data
 * @param {boolean} headless - Whether to run browser in headless mode
 * @returns {Promise<object>} - Result of the operation
 */
async function processBatch(filePath, headless = true) {
  let browser = null;
  let page = null;
  
  try {
    logger.info(`Processing batch from: ${filePath}`);
    batchStatus = { 
      status: 'running', 
      message: `Starting batch processing from: ${filePath}`,
      totalVisits: 0,
      completedVisits: 0
    };
    
    // Load the data file
    const dataPath = path.join(process.cwd(), filePath);
    if (!fs.existsSync(dataPath)) {
      throw new Error(`Data file not found: ${filePath}`);
    }
    
    const data = JSON.parse(fs.readFileSync(dataPath, 'utf8'));
    
    // Extract visits that need processing
    const visitsToProcess = [];
    
    for (const workOrder of data.workOrders) {
      if (
        workOrder.visits && 
        workOrder.visits.nextVisit && 
        workOrder.visits.nextVisit.url
      ) {
        let formCount = 0;
        let dispensers = [];
        
        // Get dispensers if available
        if (workOrder.dispensers && workOrder.dispensers.length > 0) {
          dispensers = workOrder.dispensers;
        }
        
        // Check services for quantity
        if (workOrder.services && workOrder.services.length > 0) {
          // Get the total quantity of dispensers from services
          formCount = workOrder.services.reduce((total, service) => {
            return total + (service.quantity || 0);
          }, 0);
        }
        
        // If we couldn't find a quantity, use the number of dispensers
        if (formCount === 0 && dispensers.length > 0) {
          formCount = dispensers.length;
        }
        
        // Only add to processing if we have either dispensers or a form count
        if (formCount > 0 || dispensers.length > 0) {
          visitsToProcess.push({
            id: workOrder.id,
            url: `https://app.workfossa.com${workOrder.visits.nextVisit.url}`,
            dispensers: dispensers,
            formCount: formCount
          });
        }
      }
    }
    
    if (visitsToProcess.length === 0) {
      logger.warn('No valid visits found to process');
      batchStatus = { 
        status: 'completed', 
        message: 'No valid visits found to process',
        totalVisits: 0,
        completedVisits: 0
      };
      return { success: false, message: 'No valid visits found to process' };
    }
    
    // Update batch status
    batchStatus.totalVisits = visitsToProcess.length;
    batchStatus.message = `Found ${visitsToProcess.length} visits to process`;
    logger.info(`Found ${visitsToProcess.length} visits to process`);
    
    // Use the improved loginToFossa function from login.js
    const loginResult = await loginToFossa({ headless });
    
    if (!loginResult.success) {
      throw new Error('Failed to login to Fossa');
    }
    
    // Get the browser and page objects from the login result
    browser = loginResult.browser;
    page = loginResult.page;
    
    // Process each visit
    for (let i = 0; i < visitsToProcess.length; i++) {
      const visit = visitsToProcess[i];
      
      try {
        logger.info(`Processing visit ${i + 1}/${visitsToProcess.length}: ${visit.url}`);
        batchStatus.message = `Processing visit ${i + 1}/${visitsToProcess.length}: Work Order ${visit.id}`;
        
        // Navigate to the visit page
        await page.goto(visit.url);
        await page.waitForLoadState('networkidle');
        
        // Prepare the form with dispenser data and form count
        await prepareForm(page, visit.dispensers, visit.formCount);
        
        // Wait a moment to ensure everything is saved
        await page.waitForTimeout(1000);
        
        // Update completed count
        batchStatus.completedVisits++;
        
      } catch (error) {
        logger.error(`Error processing visit ${visit.url}: ${error.message}`);
        // Continue with the next visit even if one fails
      }
    }
    
    // Update batch status
    batchStatus.status = 'completed';
    batchStatus.message = `Batch processing completed. Processed ${batchStatus.completedVisits}/${batchStatus.totalVisits} visits.`;
    
    logger.info(`Batch processing completed. Processed ${batchStatus.completedVisits}/${batchStatus.totalVisits} visits.`);
    
    return { 
      success: true, 
      message: `Batch processing completed. Processed ${batchStatus.completedVisits}/${batchStatus.totalVisits} visits.` 
    };
    
  } catch (error) {
    logger.error(`Batch processing error: ${error.message}`);
    batchStatus.status = 'error';
    batchStatus.message = `Batch processing error: ${error.message}`;
    return { success: false, message: `Error: ${error.message}` };
  } finally {
    if (browser) {
      await browser.close();
    }
  }
}

/**
 * Get the current status of form automation
 * @returns {object} - Current status
 */
function getStatus() {
  return currentStatus;
}

/**
 * Get the current status of batch automation
 * @returns {object} - Current batch status
 */
function getBatchStatus() {
  return batchStatus;
}

export {
  processVisit,
  processBatch,
  getStatus,
  getBatchStatus
}; 