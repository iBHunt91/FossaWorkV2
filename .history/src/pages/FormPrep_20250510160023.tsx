import React, { useState, useEffect } from 'react';\nimport { \n  FiPlay, FiCheck, FiX, FiUpload, FiInfo, \n  FiExternalLink, FiFileText, FiClipboard, FiSearch, \n  FiChevronDown, FiEye, FiRefreshCw, FiFilter,\n  FiClock, FiMapPin, FiCheckCircle, FiXCircle\n} from 'react-icons/fi';\n// Import work order data from the local data file\nimport workOrderData from '../data/scraped_content.json';\nimport { useToast } from '../context/ToastContext';\nimport { useTheme } from '../context/ThemeContext';\n// Import form service\nimport { \n  processSingleVisit, \n  getFormAutomationStatus, \n  processBatchVisits, \n  getBatchAutomationStatus,\n  cancelFormAutomation,\n  openUrlWithDebugMode\n} from '../services/formService';\nimport { ENDPOINTS } from '../config/api';\n\n// Add service for retrieving dispenser information\nimport { getDispensersForWorkOrder } from '../services/dispenserService';\n\n// Storage keys for localStorage\nconst STORAGE_KEYS = {\n  FORM_JOBS: 'form_prep_jobs',\n  SINGLE_JOB_ID: 'form_prep_single_job_id',\n  BATCH_JOB_ID: 'form_prep_batch_job_id',\n  IS_POLLING_SINGLE: 'form_prep_is_polling_single',\n  LAST_STATUS_UPDATE: 'form_prep_last_status_update',\n  VISIT_URL: 'form_prep_visit_url'\n};\n\n// Helper functions for localStorage\nconst saveToStorage = (key: string, data: any) => {\n  try {\n    localStorage.setItem(key, JSON.stringify(data));\n  } catch (error) {\n    console.error(`Error saving to localStorage (${key}):`, error);\n  }\n};\n\nconst getFromStorage = (key: string, defaultValue: any) => {\n  try {\n    const value = localStorage.getItem(key);\n    return value ? JSON.parse(value) : defaultValue;\n  } catch (error) {\n    console.error(`Error reading from localStorage (${key}):`, error);\n    return defaultValue;\n  }\n};\n\ninterface FormJob {\n  url: string;\n  status: 'idle' | 'running' | 'completed' | 'error';\n  message?: string;\n  timestamp?: string;\n  headless: boolean;\n  storeName?: string;\n  visitNumber?: string;\n  dispenserCount?: number;\n  startTime?: number; // Timestamp when automation started\n  endTime?: number;   // Timestamp when automation completed\n  // Flags for tracking state changes for toast notifications\n  _statusChanged?: boolean;\n  _completed?: boolean;\n  _error?: boolean;\n  jobId?: string; // Optional job ID\n}\n\ninterface BatchJob {\n  filePath: string;\n  timestamp: string;\n  status: 'idle' | 'running' | 'completed' | 'error';\n  message: string;\n  totalVisits: number;\n  completedVisits: number;\n  headless: boolean;\n  jobId?: string; // Add optional job ID field to match usage in the code\n}\n\n// Add type definitions for service function returns\ninterface SingleProcessResult {\n  success: boolean;\n  message: string;\n  jobId: string;\n}\n\ninterface BatchProcessResult {\n  success: boolean;\n  message: string;\n  jobId: string;\n  totalVisits?: number;\n}\n\ninterface WorkOrder {\n  id: string;\n  customer: {\n    name: string;\n    storeNumber: string;\n    address: {\n      street: string;\n      intersection: string;\n      cityState: string;\n      county: string;\n    };\n  };\n  services?: Array<{\n    type: string;\n    quantity: number;\n    description: string;\n    code: string;\n  }>;\n  visits: {\n    nextVisit: {\n      visitId: string;\n      date: string;\n      time: string;\n      url: string;\n    };\n  };\n  dispensers?: Array<{\n    title?: string;\n    serial?: string;\n    make?: string;\n    model?: string;\n    fields?: {\n      [key: string]: string | undefined;\n    };\n  }>;\n}\n\nconst FormPrep: React.FC<{}> = () => {\n  const { isDarkMode } = useTheme();\n  // Initialize empty work orders array, it will be populated via API\n  const [workOrders, setWorkOrders] = useState<WorkOrder[]>([]);\n  const [isLoading, setIsLoading] = useState<boolean>(true);\n  const [visitUrl, setVisitUrl] = useState<string>(() => \n    getFromStorage(STORAGE_KEYS.VISIT_URL, ''));\n  const [batchFilePath, setBatchFilePath] = useState<string>('data/scraped_content.json');\n  // Use localStorage for persistent state between navigations\n  const [formJobs, setFormJobs] = useState<FormJob[]>(() => \n    getFromStorage(STORAGE_KEYS.FORM_JOBS, []));\n  const [batchJobs, setBatchJobs] = useState<BatchJob[]>([]);\n  const [activeTab, setActiveTab] = useState<'single' | 'batch'>('single');\n  const [isProcessing, setIsProcessing] = useState<boolean>(false);\n  const [statusMessage, setStatusMessage] = useState<string>('Ready');\n  const [searchTerm, setSearchTerm] = useState<string>('');\n  const [selectedWorkOrder, setSelectedWorkOrder] = useState<WorkOrder | null>(null);\n  const [showDropdown, setShowDropdown] = useState<boolean>(false);\n  const [isHeadless, setIsHeadless] = useState<boolean>(true);\n  const [batchJobId, setBatchJobId] = useState<string | null>(() => \n    getFromStorage(STORAGE_KEYS.BATCH_JOB_ID, null));\n  const [polling, setPolling] = useState<NodeJS.Timeout | null>(null);\n  const [singleJobId, setSingleJobId] = useState<string | null>(() => \n    getFromStorage(STORAGE_KEYS.SINGLE_JOB_ID, null));\n  const [pollingSingle, setPollingSingle] = useState<boolean>(() => \n    getFromStorage(STORAGE_KEYS.IS_POLLING_SINGLE, false));\n  const [currentWeekIndex, setCurrentWeekIndex] = useState<number>(0);\n  // New state variables for enhanced batch processing\n  const [previewData, setPreviewData] = useState<any[]>([]);\n  const [selectedVisits, setSelectedVisits] = useState<string[]>([]);\n  const [groupBy, setGroupBy] = useState<string>('none');\n  const [lastFailedBatch, setLastFailedBatch] = useState<BatchJob | null>(null);\n  const [resumeBatch, setResumeBatch] = useState<boolean>(false);\n  // New state for storing dispenser details \n  const [dispenserDetails, setDispenserDetails] = useState<Record<string, any>>({});\n  const { addToast } = useToast();\n  \n  // Persist state to localStorage when it changes\n  useEffect(() => {\n    saveToStorage(STORAGE_KEYS.FORM_JOBS, formJobs);\n  }, [formJobs]);\n  \n  useEffect(() => {\n    saveToStorage(STORAGE_KEYS.SINGLE_JOB_ID, singleJobId);\n  }, [singleJobId]);\n  \n  useEffect(() => {\n    saveToStorage(STORAGE_KEYS.BATCH_JOB_ID, batchJobId);\n  }, [batchJobId]);\n  \n  useEffect(() => {\n    saveToStorage(STORAGE_KEYS.IS_POLLING_SINGLE, pollingSingle);\n  }, [pollingSingle]);\n  \n  useEffect(() => {\n    saveToStorage(STORAGE_KEYS.VISIT_URL, visitUrl);\n  }, [visitUrl]);\n  \n  // Persistent background polling system using intervals\n  useEffect(() => {\n    // Only set up continuous polling if we have an active job ID\n    if (singleJobId && pollingSingle) {\n      console.log('Starting continuous background polling:', singleJobId);\n      \n      // Check status immediately on mount\n      getFormAutomationStatus().then(status => {\n        if (status) {\n          updateJobStatus(status);\n        }\n      }).catch(error => {\n        console.error('Error getting initial status:', error);\n      });\n      \n      // Set up polling interval that persists across navigations\n      const intervalId = setInterval(async () => {\n        try {\n          // Check if we need to continue polling\n          const currentJobId = getFromStorage(STORAGE_KEYS.SINGLE_JOB_ID, null);\n          const isCurrentlyPolling = getFromStorage(STORAGE_KEYS.IS_POLLING_SINGLE, false);\n          \n          if (!currentJobId || !isCurrentlyPolling) {\n            console.log('Stopping polling interval as job is no longer active');\n            clearInterval(intervalId);\n            return;\n          }\n          \n          // Save timestamp of polling attempt\n          saveToStorage(STORAGE_KEYS.LAST_STATUS_UPDATE, new Date().toISOString());\n          \n          // Get current status from server\n          const status = await getFormAutomationStatus();\n          \n          // Only process if we still have an active polling state\n          if (status) {\n            // Store the latest status in storage for persistence\n            updateJobStatus(status);\n            \n            // If job is completed or errored, stop polling\n            if (status.status === 'completed' || status.status === 'error') {\n              saveToStorage(STORAGE_KEYS.IS_POLLING_SINGLE, false);\n              saveToStorage(STORAGE_KEYS.SINGLE_JOB_ID, null);\n              clearInterval(intervalId);\n            }\n          }\n        } catch (error) {\n          console.error('Error in background polling:', error);\n          // Don't stop polling on network errors\n        }\n      }, 2000); // Poll every 2 seconds\n      \n      // Clean up\n      return () => {\n        clearInterval(intervalId);\n      };\n    }\n  }, [singleJobId, pollingSingle]);\n  \n  // Function to update job status across localStorage and state\n  const updateJobStatus = (status: any) => {\n    if (!status) return;\n    \n    // Get the stored jobs and update the relevant one\n    const storedJobs = getFromStorage(STORAGE_KEYS.FORM_JOBS, []);\n    const activeJobIndex = storedJobs.findIndex((job: FormJob) => job.status === 'running');\n    \n    if (activeJobIndex !== -1) {\n      const updatedJobs = [...storedJobs];\n      const jobToUpdate = updatedJobs[activeJobIndex];\n      \n      // Ensure we have a proper dispenser count if missing\n      let dispenserCount = jobToUpdate.dispenserCount || 0;\n      if (!dispenserCount) {\n        // Try to extract the work order ID from the URL\n        const url = jobToUpdate.url;\n        const urlParts = url.split('/');\n        const workUrlIndex = urlParts.findIndex((part: string) => part === 'work');\n        const workOrderId = workUrlIndex >= 0 && workUrlIndex + 1 < urlParts.length \n          ? `W-${urlParts[workUrlIndex + 1]}` \n          : null;\n        \n        if (workOrderId) {\n          dispenserCount = getDispenserCountDirect(workOrderId);\n          console.log(`Updated missing dispenser count for job: ${dispenserCount}`);\n        }\n      }\n      \n      // Format message for display (reuse existing message formatting logic)\n      let formattedMessage = status.message || '';\n      \n      if (status.status === 'running') {\n        // Default message if none provided\n        if (!formattedMessage || formattedMessage.trim() === '') {\n          formattedMessage = 'Processing form...';\n        }\n        \n        // Apply fuel type formatting if applicable\n        const fuelTypeRegex = /processing fuel type:\s*([a-zA-Z0-9\s-]+)\s*\((\d+)\/(\d+)\)/i;\n        const fuelTypeMatch = formattedMessage.match(fuelTypeRegex);\n        \n        if (fuelTypeMatch && fuelTypeMatch[1] && fuelTypeMatch[2] && fuelTypeMatch[3]) {\n          const fuelType = fuelTypeMatch[1].trim();\n          const current = fuelTypeMatch[2];\n          const total = fuelTypeMatch[3];\n          \n          // Check if there's dispenser info\n          const dispenserRegex = /dispenser(?:[\s#]+)(\d+)(?:[^\d]+(\d+)|)/i;\n          const dispenserMatch = formattedMessage.match(dispenserRegex);\n          \n          if (dispenserMatch && dispenserMatch[1]) {\n            const dispenserNum = dispenserMatch[1];\n            // If there's a second capture group, use it, otherwise use the job's dispenser count\n            // This ensures we always have the most accurate total dispenser count\n            const dispenserTotal = dispenserMatch[2] || jobToUpdate.dispenserCount || '?';\n            formattedMessage = `Processing ${fuelType} (${current}/${total}) - Dispenser #${dispenserNum}/${dispenserTotal}`;\n          } else {\n            formattedMessage = `Processing ${fuelType} (${current}/${total})`;\n          }\n        }\n      }\n      \n      // Simplify completion messages\n      if (status.status === 'completed') {\n        if (formattedMessage.includes(jobToUpdate.url)) {\n          formattedMessage = `Form completed successfully`;\n        } else if (formattedMessage.includes('Successfully')) {\n          formattedMessage = `Form completed successfully`;\n        }\n      }\n      \n      // Update the job\n      const endTime = (status.status === 'completed' || status.status === 'error') ? Date.now() : undefined;\n      \n      updatedJobs[activeJobIndex] = {\n        ...jobToUpdate,\n        status: status.status,\n        message: formattedMessage,\n        endTime: endTime || jobToUpdate.endTime,\n        _statusChanged: jobToUpdate.status !== status.status,\n        _completed: status.status === 'completed' && jobToUpdate.status !== 'completed',\n        _error: status.status === 'error' && jobToUpdate.status !== 'error',\n        // Preserve dispenser count in the job object\n        dispenserCount: dispenserCount > 0 ? dispenserCount : jobToUpdate.dispenserCount || 0\n      };\n      \n      // Save to localStorage\n      saveToStorage(STORAGE_KEYS.FORM_JOBS, updatedJobs);\n      \n      // Update state if component is mounted\n      setFormJobs(updatedJobs);\n      \n      // Show completion/error toast if status just changed\n      if (status.status === 'completed' && jobToUpdate.status !== 'completed') {\n        addToast('success', 'Form processing completed successfully');\n        \n        // Clear job state on completion\n        setPollingSingle(false);\n        setSingleJobId(null);\n        setIsProcessing(false);\n      } else if (status.status === 'error' && jobToUpdate.status !== 'error') {\n        addToast('error', status.message || 'An error occurred during form processing');\n        \n        // Clear job state on error\n        setPollingSingle(false);\n        setSingleJobId(null);\n        setIsProcessing(false);\n      }\n    }\n  };\n  \n  // Sync component state with localStorage on mount\n  useEffect(() => {\n    // When component mounts, check for existing jobs and status in localStorage\n    const storedJobs = getFromStorage(STORAGE_KEYS.FORM_JOBS, []);\n    const storedSingleJobId = getFromStorage(STORAGE_KEYS.SINGLE_JOB_ID, null);\n    const storedIsPolling = getFromStorage(STORAGE_KEYS.IS_POLLING_SINGLE, false);\n    \n    // Update component state with stored values\n    setFormJobs(storedJobs);\n    setSingleJobId(storedSingleJobId);\n    setPollingSingle(storedIsPolling);\n    \n    // Set processing flag if we have an active job\n    if (storedSingleJobId && storedIsPolling) {\n      setIsProcessing(true);\n      \n      // Get current status\n      getFormAutomationStatus()\n        .then(status => {\n          if (status) {\n            updateJobStatus(status);\n            \n            // If job completed while away, update state\n            if (status.status === 'completed' || status.status === 'error') {\n              setPollingSingle(false);\n              setSingleJobId(null);\n              setIsProcessing(false);\n            }\n          }\n        })\n        .catch(error => {\n          console.error('Error getting status on mount:', error);\n        });\n    }\n    \n    // Load work orders from API\n    let isMounted = true;\n    \n    const fetchWorkOrders = async () => {\n      setIsLoading(true);\n      \n      try {\n        // First try to load data from the API\n        const response = await fetch('/api/workorders');\n        \n        if (!response.ok) {\n          throw new Error(`Failed to load work orders: ${response.status}`);\n        }\n        \n        const data = await response.json();\n        \n        if (data.workOrders && Array.isArray(data.workOrders)) {\n          if (isMounted) {\n            console.log('Successfully loaded', data.workOrders.length, 'work orders from API');\n            setWorkOrders(data.workOrders);\n          }\n        } else {\n          throw new Error('Invalid API data format');\n        }\n      } catch (error) {\n        console.error('Error loading work order data:', error);\n        \n        try {\n          // Fall back to local JSON file\n          console.log('Trying to load local JSON file as fallback');\n          const fileResponse = await fetch('/src/data/scraped_content.json');\n          \n          if (!fileResponse.ok) {\n            throw new Error(`Failed to load local data: ${fileResponse.status}`);\n          }\n          \n          const fileData = await fileResponse.json();\n          \n          if (isMounted && fileData.workOrders) {\n            console.log('Successfully loaded', fileData.workOrders.length, 'work orders from local file');\n            setWorkOrders(fileData.workOrders);\n          }\n        } catch (localError) {\n          console.error('Error loading local work order data:', localError);\n          \n          // Fall back to imported data\n          if (isMounted) {\n            console.warn('Using static imported data as final fallback');\n            setWorkOrders(workOrderData.workOrders);\n          }\n        }\n      } finally {\n        if (isMounted) {\n          setIsLoading(false);\n        }\n      }\n    };\n    \n    fetchWorkOrders();\n    \n    return () => {\n      isMounted = false;\n    };\n  }, []);\n  \n  // Effect to resume polling for active jobs when component remounts\n  useEffect(() => {\n    // Log existing state on mount to help debug\n    console.log('FormPrep mounted with state:', {\n      formJobs: formJobs.length,\n      batchJobs: batchJobs.length,\n      singleJobId,\n      pollingSingle,\n      activeJobs: formJobs.filter(job => job.status === 'running').length\n    });\n    \n    // Check if we have active single job\n    if (singleJobId && !pollingSingle) {\n      console.log('Resuming polling for previous active single job:', singleJobId);\n      \n      // Find the job URL from formJobs\n      const activeJob = formJobs.find(job => job.status === 'running');\n      const activeJobUrl = activeJob?.url || '';\n      \n      if (!activeJobUrl) {\n        console.warn('Unable to find active job URL for resuming polling');\n        return;\n      }\n      \n      // First, get the current status immediately to catch up on any missed updates\n      getFormAutomationStatus()\n        .then(currentStatus => {\n          console.log('Current automation status on resume:', currentStatus);\n          \n          // Update form job with current status immediately\n          if (currentStatus) {\n            setFormJobs(prev => {\n              const updatedJobs = [...prev];\n              const jobIndex = updatedJobs.findIndex(job => \n                job.url === activeJobUrl && job.status === 'running');\n              \n              if (jobIndex !== -1) {\n                const jobToUpdate = updatedJobs[jobIndex];\n                const updatedJob = {\n                  ...jobToUpdate,\n                  status: currentStatus.status,\n                  message: currentStatus.message || jobToUpdate.message,\n                  _statusChanged: jobToUpdate.status !== currentStatus.status,\n                  _completed: currentStatus.status === 'completed' && jobToUpdate.status !== 'completed',\n                  _error: currentStatus.status === 'error' && jobToUpdate.status !== 'error'\n                };\n                \n                // Set end time if job has completed or errored\n                if ((currentStatus.status === 'completed' || currentStatus.status === 'error') && !jobToUpdate.endTime) {\n                  updatedJob.endTime = Date.now();\n                }\n                \n                updatedJobs[jobIndex] = updatedJob;\n              }\n              \n              return updatedJobs;\n            });\n            \n            // If the job is already completed/error, don't start polling\n            if (currentStatus.status === 'completed' || currentStatus.status === 'error') {\n              console.log('Job already completed, not starting polling');\n              setSingleJobId(null); // Clear the job ID\n              setPollingSingle(false);\n              return;\n            }\n          }\n          \n          // Set polling flag to true to avoid duplicate polling\n          setPollingSingle(true);\n          \n          // Then resume polling for this job\n          pollingManager.current.startPolling(\n            singleJobId,\n            (status) => {\n              // Update status handler (same as in handleSingleVisit)\n              if (status) {\n                setFormJobs(prev => {\n                  const updatedJobs = [...prev];\n                  const jobIndex = updatedJobs.findIndex(job => \n                    job.url === activeJobUrl && job.status === 'running');\n                  \n                  if (jobIndex !== -1) {\n                    const jobToUpdate = updatedJobs[jobIndex];\n                    const updatedJob = {\n                      ...jobToUpdate,\n                      status: status.status,\n                      message: status.message || jobToUpdate.message,\n                      _statusChanged: jobToUpdate.status !== status.status,\n                      _completed: status.status === 'completed' && jobToUpdate.status !== 'completed',\n                      _error: status.status === 'error' && jobToUpdate.status !== 'error'\n                    };\n                    \n                    // Set end time if job has completed or errored\n                    if ((status.status === 'completed' || status.status === 'error') && !jobToUpdate.endTime) {\n                      updatedJob.endTime = Date.now();\n                    }\n                    \n                    updatedJobs[jobIndex] = updatedJob;\n                  }\n                  \n                  return updatedJobs;\n                });\n              }\n            },\n            () => {\n              // Complete handler\n              setPollingSingle(false);\n              setSingleJobId(null);\n            },\n            (error) => {\n              // Error handler\n              console.error('Error resuming form automation:', error);\n              setPollingSingle(false);\n              setSingleJobId(null);\n              addToast(\n                'error',\n                error instanceof Error ? error.message : 'An unknown error occurred'\n              );\n            },\n            activeJobUrl // Pass the URL for context\n          );\n        })\n        .catch(error => {\n          console.error('Error getting current automation status:', error);\n        });\n    }\n    \n    // Check for active batch jobs\n    if (batchJobId) {\n      // Similar implementation for batch jobs if needed\n      getBatchAutomationStatus(batchJobId)\n        .then(currentStatus => {\n          // Update based on current status\n          // Then resume polling for batch jobs\n        })\n        .catch(error => {\n          console.error('Error getting current batch status:', error);\n        });\n    }\n    \n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  \n  // Effect to update visit URL when a work order is selected\n  useEffect(() => {\n    if (selectedWorkOrder && selectedWorkOrder.visits?.nextVisit?.url) {\n      // Construct the full URL if it's relative\n      const url = selectedWorkOrder.visits.nextVisit.url;\n      const fullUrl = url.startsWith('http') ? url : `https://app.workfossa.com${url}`;\n      setVisitUrl(fullUrl);\n    } else if (!selectedWorkOrder) {\n      // Optionally clear the URL if no work order is selected\n      // setVisitUrl(''); \n    }\n  }, [selectedWorkOrder]);\n  \n  // Polling manager that persists between renders and handles all polling logic\n  const pollingManager = React.useRef({\n    activePolls: {} as Record<string, {\n      interval: NodeJS.Timeout | null,\n      firstTimeout: NodeJS.Timeout | null,\n      secondTimeout: NodeJS.Timeout | null,\n      finalTimeout: NodeJS.Timeout | null,\n      startTime: number,\n      lastStatusUpdate: number,\n      forceComplete: boolean,\n      lastMessage: string,\n      messageUpdateTime: number,\n      // Add these properties to track the context\n      url: string,\n      onUpdate: (status: any) => void,\n      onComplete: () => void,\n      onError: (error: any) => void,\n      isPaused: boolean,\n      resumeTime: number | null\n    }>,\n    \n    // Start polling for a specific job ID\n    startPolling: function(\n      jobId: string, \n      onUpdate: (status: any) => void, \n      onComplete: () => void,\n      onError: (error: any) => void,\n      url: string = ''\n    ) {\n      // Don't start polling if it's already active\n      if (this.activePolls[jobId]) {\n        console.log(`üîç Already polling for job ID: ${jobId}, ignoring duplicate start request`);\n        \n        // If it was paused, resume it\n        if (this.activePolls[jobId].isPaused) {\n          console.log(`üîç Resuming previously paused poll for job ID: ${jobId}`);\n          this.activePolls[jobId].isPaused = false;\n          this.activePolls[jobId].resumeTime = Date.now();\n          this.activePolls[jobId].onUpdate = onUpdate;\n          this.activePolls[jobId].onComplete = onComplete;\n          this.activePolls[jobId].onError = onError;\n          \n          // Start a new interval for polling since the old one was cleared\n          this._startPollingInterval(jobId);\n        }\n        \n        return;\n      }\n      \n      console.log('üîç Starting status polling for job ID:', jobId, 'at', new Date().toISOString());\n      \n      const startTime = Date.now();\n      const lastStatusUpdate = Date.now();\n      \n      // First activity check after 15 seconds\n      const firstTimeout = setTimeout(() => {\n        console.log('üîç 15-second check - monitoring job progress');\n        \n        if (!this.activePolls[jobId]) return;\n        \n        // Only log progress, never force completion on first check\n        const poll = this.activePolls[jobId];\n        console.log('üîç Job progress at 15 seconds:', poll.lastMessage);\n      }, 15000);\n      \n      // Activity monitoring every 30 seconds\n      const secondTimeout = setTimeout(() => {\n        // This starts the activity monitoring system\n        console.log('üîç Starting activity monitoring for job');\n        \n        // Create a recurring check that runs every 30 seconds\n        const activityInterval = setInterval(() => {\n          if (!this.activePolls[jobId]) {\n            clearInterval(activityInterval);\n            return;\n          }\n          \n          const poll = this.activePolls[jobId];\n          const lastMessage = poll.lastMessage || '';\n          const now = Date.now();\n          const timeSinceLastChange = now - poll.messageUpdateTime;\n          \n          // Log current activity for debugging\n          console.log(`üîç Activity check: ${lastMessage}`);\n          console.log(`üîç Time since last activity: ${Math.round(timeSinceLastChange/1000)}s`);\n          \n          // Check for signs of active automation\n          const isClosingBrowser = lastMessage.includes('Closing browser');\n          const isFillingForms = lastMessage.includes('filling') || lastMessage.includes('entering');\n          const isProcessingFuel = lastMessage.includes('Processing fuel type');\n          const isNavigating = lastMessage.includes('navigating') || lastMessage.includes('next form');\n          const isActive = isClosingBrowser || isFillingForms || isProcessingFuel || isNavigating;\n          \n          // Is the message updating frequently?\n          const messageIsRecent = timeSinceLastChange < 45000; // 45 seconds\n          \n          if (isActive || messageIsRecent) {\n            // Automation is still active, don't force completion\n            console.log('üîç Automation is still active, continuing');\n            return;\n          }\n          \n          // Check for a long inactive period (2+ minutes with no change)\n          if (timeSinceLastChange > 120000) {\n            console.log('üîç No activity for 2 minutes, assuming completion');\n            this.activePolls[jobId].forceComplete = true;\n            onUpdate({\n              status: 'completed',\n              message: lastMessage || 'Processing completed'\n            });\n            \n            // Clean up polling\n            this.stopPolling(jobId);\n            onComplete();\n            return;\n          }\n          \n          // Between 45s and 120s without change, just wait and check next time\n          console.log('üîç Limited activity detected, but not forcing completion yet');\n          \n        }, 30000); // Check every 30 seconds\n        \n        // Store this interval for cleanup\n        // @ts-ignore\n        this.activePolls[jobId].activityInterval = activityInterval;\n        \n      }, 30000);\n      \n      // Final backup (only used if the browser truly hangs)\n      const finalTimeout = setTimeout(() => {\n        console.log('üîç 5-minute maximum check');\n        \n        if (!this.activePolls[jobId]) return;\n        \n        // Check if browser is still active\n        const poll = this.activePolls[jobId];\n        const lastMessage = poll.lastMessage || '';\n        const timeSinceLastMessageChange = Date.now() - poll.messageUpdateTime;\n        \n        const isClosingBrowser = lastMessage.includes('Closing browser');\n        const messageRecentlyChanged = timeSinceLastMessageChange < 60000; // Last minute\n        \n        // If still actively closing or changed in the last minute, give more time\n        if (isClosingBrowser || messageRecentlyChanged) {\n          console.log('üîç Still active at 5 minutes, giving a bit more time');\n          return;\n        }\n        \n        console.log('üîç Reached 5-minute maximum, forcing completion');\n        this.activePolls[jobId].forceComplete = true;\n        onUpdate({\n          status: 'completed',\n          message: lastMessage || 'Processing completed (maximum duration reached)'\n        });\n        \n        // Clean up polling\n        this.stopPolling(jobId);\n        onComplete();\n      }, 300000); // 5 minutes max\n      \n      // Store all the timers and state\n      this.activePolls[jobId] = {\n        interval: null, // We'll set this after creating the poll object\n        firstTimeout,\n        secondTimeout,\n        finalTimeout,\n        startTime,\n        lastStatusUpdate,\n        forceComplete: false,\n        lastMessage: '',\n        messageUpdateTime: Date.now(),\n        // Store context for resuming\n        url,\n        onUpdate,\n        onComplete,\n        onError,\n        isPaused: false,\n        resumeTime: null\n      };\n      \n      // Start the interval for polling\n      this._startPollingInterval(jobId);\n    },\n    \n    // Private method to start/restart the polling interval\n    _startPollingInterval: function(jobId: string) {\n      if (!this.activePolls[jobId]) return;\n      \n      // Set up the regular polling interval\n      const interval = setInterval(async () => {\n        // Skip if polling has been stopped or paused\n        if (!this.activePolls[jobId] || this.activePolls[jobId].isPaused) {\n          clearInterval(interval);\n          return;\n        }\n        \n        // Skip if we've already forced completion\n        if (this.activePolls[jobId]?.forceComplete) {\n          this.stopPolling(jobId);\n          return;\n        }\n        \n        try {\n          // API call to check status\n          const status = await getFormAutomationStatus();\n          const now = Date.now();\n          \n          // Make sure the poll still exists before updating\n          if (!this.activePolls[jobId]) {\n            clearInterval(interval);\n            return;\n          }\n          \n          const poll = this.activePolls[jobId];\n          \n          // Update message timestamp if the message changed\n          if (status.message !== poll.lastMessage) {\n            // Update the polling state\n            poll.messageUpdateTime = now;\n            poll.lastMessage = status.message;\n            poll.lastStatusUpdate = now;\n          } else {\n            // Just update the lastStatusUpdate\n            poll.lastStatusUpdate = now;\n          }\n          \n          // Update status in the UI via callback\n          poll.onUpdate(status);\n          \n          // Check if we're done or errored\n          if (status.status === 'completed' || status.status === 'error') {\n            // Make sure we still have a reference before stopping\n            if (this.activePolls[jobId]) {\n              this.stopPolling(jobId);\n              \n              if (status.status === 'error') {\n                poll.onError(new Error(status.message || 'Unknown error'));\n              } else {\n                poll.onComplete();\n              }\n            }\n          }\n        } catch (error) {\n          console.error('Error polling for status:', error);\n          // Don't stop polling on network errors, let the timeouts handle it\n        }\n      }, 1000); // Poll every second\n      \n      // Store the interval for cleanup\n      if (this.activePolls[jobId]) {\n        this.activePolls[jobId].interval = interval;\n      }\n    },\n    \n    // Pause polling but keep the job information (used when component unmounts)\n    pausePolling: function(jobId: string) {\n      console.log('üîç Pausing polling for job ID:', jobId);\n      \n      if (!this.activePolls[jobId]) {\n        console.log(`üîç No active polling found for job ID: ${jobId}`);\n        return;\n      }\n      \n      const poll = this.activePolls[jobId];\n      \n      // Clear the interval but keep the poll data\n      if (poll.interval) {\n        clearInterval(poll.interval);\n        poll.interval = null;\n      }\n      \n      // Mark as paused\n      poll.isPaused = true;\n    },\n    \n    // Stop polling for a specific job ID\n    stopPolling: function(jobId: string) {\n      console.log('üîç Stopping polling for job ID:', jobId);\n      \n      if (!this.activePolls[jobId]) {\n        console.log(`üîç No active polling found for job ID: ${jobId}`);\n        return;\n      }\n      \n      // Make a copy of the poll data before we delete it\n      const pollData = { ...this.activePolls[jobId] };\n      \n      // Remove from active polls first to prevent race conditions\n      delete this.activePolls[jobId];\n      \n      // Then clean up all timers\n      try {\n        // Clear main interval\n        if (pollData.interval) {\n          clearInterval(pollData.interval);\n        }\n        \n        // Clear all timeouts\n        if (pollData.firstTimeout) {\n          clearTimeout(pollData.firstTimeout);\n        }\n        \n        if (pollData.secondTimeout) {\n          clearTimeout(pollData.secondTimeout);\n        }\n        \n        if (pollData.finalTimeout) {\n          clearTimeout(pollData.finalTimeout);\n        }\n        \n        // Clear any additional intervals\n        // @ts-ignore\n        if (pollData.activityInterval) {\n          // @ts-ignore\n          clearInterval(pollData.activityInterval);\n        }\n        \n        // @ts-ignore\n        if (pollData.finalExtendedTimeout) {\n          // @ts-ignore\n          clearTimeout(pollData.finalExtendedTimeout);\n        }\n      } catch (e) {\n        console.error('Error clearing timeouts:', e);\n      }\n    },\n    \n    // Stop all active polls\n    stopAll: function() {\n      console.log('üîç Stopping all active polls');\n      \n      // Clean up each poll\n      Object.keys(this.activePolls).forEach(jobId => {\n        this.stopPolling(jobId);\n      });\n    },\n    \n    // Pause all active polls without removing them\n    pauseAll: function() {\n      console.log('üîç Pausing all active polls');\n      \n      Object.keys(this.activePolls).forEach(jobId => {\n        this.pausePolling(jobId);\n      });\n    }\n  });\n  \n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      // Instead of stopping all polls, pause them so they can be resumed\n      pollingManager.current.pauseAll();\n    };\n  }, []);\n  \n  // Group work orders by week\n  const groupedWorkOrders = React.useMemo(() => {\n    if (!workOrders.length) return [];\n    \n    const groups: { week: string; orders: WorkOrder[] }[] = [];\n    const ordersByWeek = new Map<string, WorkOrder[]>();\n    \n    // Sort orders by date first\n    const sortedOrders = [...workOrders].sort((a, b) => {\n      const dateA = a.visits.nextVisit.date ? new Date(a.visits.nextVisit.date) : new Date();\n      const dateB = b.visits.nextVisit.date ? new Date(b.visits.nextVisit.date) : new Date();\n      return dateA.getTime() - dateB.getTime();\n    });\n    \n    // Group by week\n    sortedOrders.forEach(order => {\n      let weekLabel = 'No Date';\n      \n      if (order.visits.nextVisit.date) {\n        const date = new Date(order.visits.nextVisit.date);\n        const year = date.getFullYear();\n        const month = date.getMonth() + 1;\n        \n        // Format date range for the week\n        const firstDayOfWeek = new Date(date);\n        firstDayOfWeek.setDate(date.getDate() - date.getDay()); // Start with Sunday\n        \n        const lastDayOfWeek = new Date(firstDayOfWeek);\n        lastDayOfWeek.setDate(firstDayOfWeek.getDate() + 6); // End with Saturday\n        \n        // Format as Month/Day - Month/Day without year\n        const firstMonth = firstDayOfWeek.getMonth() + 1;\n        const lastMonth = lastDayOfWeek.getMonth() + 1;\n        const firstDay = firstDayOfWeek.getDate();\n        const lastDay = lastDayOfWeek.getDate();\n        \n        if (firstMonth === lastMonth) {\n          // Same month - always show month in both dates\n          weekLabel = `${firstMonth}/${firstDay} - ${firstMonth}/${lastDay}`;\n        } else {\n          // Different months\n          weekLabel = `${firstMonth}/${firstDay} - ${lastMonth}/${lastDay}`;\n        }\n      }\n      \n      if (!ordersByWeek.has(weekLabel)) {\n        ordersByWeek.set(weekLabel, []);\n      }\n      \n      ordersByWeek.get(weekLabel)?.push(order);\n    });\n    \n    // Convert map to array\n    ordersByWeek.forEach((orders, week) => {\n      groups.push({ week, orders });\n    });\n    \n    return groups;\n  }, [workOrders]);\n  \n  // Filter work orders based on search term\n  const filteredWorkOrders = React.useMemo(() => {\n    if (!searchTerm) {\n      return groupedWorkOrders.length > 0 && currentWeekIndex < groupedWorkOrders.length\n        ? groupedWorkOrders[currentWeekIndex].orders\n        : [];\n    }\n    \n    const searchTermLower = searchTerm.toLowerCase();\n    \n    return groupedWorkOrders.length > 0 && currentWeekIndex < groupedWorkOrders.length\n      ? groupedWorkOrders[currentWeekIndex].orders.filter(order => \n          order.customer.name.toLowerCase().includes(searchTermLower) ||\n          order.customer.storeNumber.toLowerCase().includes(searchTermLower) ||\n          (order.id && order.id.toLowerCase().includes(searchTermLower))\n        )\n      : [];\n  }, [groupedWorkOrders, currentWeekIndex, searchTerm]);\n  \n  // Navigation functions\n  const goToPreviousWeek = () => {\n    if (currentWeekIndex > 0) {\n      setCurrentWeekIndex(currentWeekIndex - 1);\n    }\n  };\n  \n  const goToNextWeek = () => {\n    if (currentWeekIndex < groupedWorkOrders.length - 1) {\n      setCurrentWeekIndex(currentWeekIndex + 1);\n    }\n  };\n  \n  const goToCurrentWeek = () => {\n    // Find the current week or the next upcoming week\n    const today = new Date();\n    \n    // Get the current week's Sunday-Saturday range\n    const currentSunday = new Date(today);\n    currentSunday.setDate(today.getDate() - today.getDay()); // Move to Sunday\n    \n    const currentSaturday = new Date(currentSunday);\n    currentSaturday.setDate(currentSunday.getDate() + 6); // Move to Saturday\n    \n    // Format the same way we do in our grouping function\n    const firstMonth = currentSunday.getMonth() + 1;\n    const firstDay = currentSunday.getDate();\n    const lastMonth = currentSaturday.getMonth() + 1;\n    const lastDay = currentSaturday.getDate();\n    \n    let currentWeekLabel;\n    if (firstMonth === lastMonth) {\n      // Same month - always show month in both dates\n      currentWeekLabel = `${firstMonth}/${firstDay} - ${firstMonth}/${lastDay}`;\n    } else {\n      currentWeekLabel = `${firstMonth}/${firstDay} - ${lastMonth}/${lastDay}`;\n    }\n    \n    const weekIndex = groupedWorkOrders.findIndex(group => group.week === currentWeekLabel);\n    \n    if (weekIndex !== -1) {\n      setCurrentWeekIndex(weekIndex);\n    } else {\n      // If current week not found, find the next upcoming week\n      const today = new Date();\n      const todayTimestamp = today.getTime();\n      \n      // Sort weeks by start date\n      const futureWeeks = groupedWorkOrders\n        .map((group, index) => {\n          if (group.week === 'No Date') return { index, timestamp: Infinity };\n          \n          // Parse the week string to get the first date\n          const [startPart] = group.week.split(' - ');\n          const [month, day] = startPart.split('/').map(Number);\n          \n          // Create date object (use current year)\n          const date = new Date();\n          date.setMonth(month - 1);\n          date.setDate(day);\n          \n          return { index, timestamp: date.getTime() };\n        })\n        .filter(week => week.timestamp >= todayTimestamp)\n        .sort((a, b) => a.timestamp - b.timestamp);\n      \n      if (futureWeeks.length > 0) {\n        setCurrentWeekIndex(futureWeeks[0].index);\n      } else {\n        // If no future weeks, go to the last week\n        setCurrentWeekIndex(groupedWorkOrders.length - 1);\n      }\n    }\n  };\n  \n  // Extract visit number from URL\n  const extractVisitNumber = (url: string): string => {\n    const match = url.match(/visits\/(\d+)/);\n    return match ? match[1] : '';\n  };\n  \n  // Extract store name and other info from a visit URL for display\n  const extractVisitInfo = (url: string): { storeName: string; visitNumber: string; dispenserCount: number } => {\n    // Default values\n    const defaultInfo = { \n      storeName: "Unknown Store", \n      visitNumber: extractVisitNumber(url) || "Unknown", \n      dispenserCount: 0 \n    };\n    \n    if (!url) return defaultInfo;\n    \n    try {\n      // Extract visit ID from URL\n      const visitNumber = extractVisitNumber(url);\n      \n      if (!visitNumber) return defaultInfo;\n      \n      // Extract work order ID from URL if available\n      const urlParts = url.split('/');\n      const workUrlIndex = urlParts.findIndex(part => part === 'work');\n      const workOrderId = workUrlIndex >= 0 && workUrlIndex + 1 < urlParts.length \n        ? `W-${urlParts[workUrlIndex + 1]}` \n        : null;\n      \n      // First try with the work order ID extracted from URL\n      if (workOrderId) {\n        const dispenserCount = getDispenserCountDirect(workOrderId);\n        // If we found a direct work order ID and it has dispensers, use it\n        if (dispenserCount > 0) {\n          // Attempt to find the matching work order to get the store name\n          const matchingOrder = workOrders.find(order => order.id === workOrderId);\n          return {\n            storeName: matchingOrder?.customer?.name || "Unknown Store",\n            visitNumber,\n            dispenserCount\n          };\n        }\n      }\n      \n      // Fallback: try to find matching work order by visit number\n      for (const order of workOrders) {\n        const orderVisitNumber = extractVisitNumber(order.visits.nextVisit.url);\n        \n        if (orderVisitNumber === visitNumber) {\n          // Get accurate dispenser count using the better method\n          const dispenserCount = getDispenserCountDirect(order.id);\n          \n          return {\n            storeName: order.customer.name,\n            visitNumber,\n            dispenserCount\n          };\n        }\n      }\n      \n      return { \n        ...defaultInfo,\n        visitNumber\n      };\n    } catch (error) {\n      console.error('Error extracting visit info:', error);\n      return defaultInfo;\n    }\n  };\n  \n  // Update getDispenserCountDirect to retrieve from dispenserDetails if available\n  const getDispenserCountDirect = (workOrderId: string): number => {\n    // First check if we already have the dispenser details loaded\n    if (dispenserDetails && dispenserDetails[workOrderId] && dispenserDetails[workOrderId].dispensers) {\n      return dispenserDetails[workOrderId].dispensers.length;\n    }\n    \n    // Then check if dispensers array is available in the work order\n    const workOrder = workOrders.find(order => order.id === workOrderId);\n    \n    // First check if dispensers array is available and has content\n    if (workOrder?.dispensers && workOrder.dispensers.length > 0) {\n      // Filter out any incomplete/invalid dispensers that might inflate the count\n      const validDispensers = workOrder.dispensers.filter(\n        dispenser => dispenser.serial || dispenser.make || dispenser.model\n      );\n      return validDispensers.length > 0 ? validDispensers.length : workOrder.dispensers.length;\n    }\n    \n    // Fallback to services if dispensers array is empty/missing\n    if (workOrder?.services) {\n      // Look for meter calibration services as fallback\n      const meterCalibrationService = workOrder.services.find(\n        service => service.type === "Meter Calibration" || \n                   service.description?.toLowerCase().includes("dispenser") ||\n                   service.description?.toLowerCase().includes("meter")\n      );\n      \n      if (meterCalibrationService?.quantity) {\n        return meterCalibrationService.quantity;\n      }\n    }\n    \n    // No dispenser info available\n    return 0;\n  };\n  \n  const getStoreStyles = (storeName: string) => {\n    // Default styles\n    const defaultStyles = {\n      bg: 'bg-gray-100 dark:bg-gray-700/50',\n      border: 'border-gray-500',\n      icon: 'text-gray-600 dark:text-gray-400'\n    };\n    \n    // Normalize store name to lowercase for comparison\n    const normalizedName = storeName.toLowerCase();\n    \n    // Define style mappings for different store names\n    const styleMap: Record<string, typeof defaultStyles> = {\n      // Gas stations\n      'shell': {\n        bg: 'bg-yellow-100 dark:bg-yellow-900/20',\n        border: 'border-yellow-500',\n        icon: 'text-yellow-600 dark:text-yellow-400'\n      },\n      'chevron': {\n        bg: 'bg-blue-100 dark:bg-blue-900/20',\n        border: 'border-blue-500',\n        icon: 'text-blue-600 dark:text-blue-400'\n      },\n      'exxon': {\n        bg: 'bg-red-100 dark:bg-red-900/20',\n        border: 'border-red-500',\n        icon: 'text-red-600 dark:text-red-400'\n      },\n      'mobil': {\n        bg: 'bg-red-100 dark:bg-red-900/20',\n        border: 'border-red-500',\n        icon: 'text-red-600 dark:text-red-400'\n      },\n      'bp': {\n        bg: 'bg-green-100 dark:bg-green-900/20',\n        border: 'border-green-500',\n        icon: 'text-green-600 dark:text-green-400'\n      },\n      'texaco': {\n        bg: 'bg-red-100 dark:bg-red-900/20',\n        border: 'border-red-500',\n        icon: 'text-red-600 dark:text-red-400'\n      },\n      'arco': {\n        bg: 'bg-blue-100 dark:bg-blue-900/20',\n        border: 'border-blue-500',\n        icon: 'text-blue-600 dark:text-blue-400'\n      },\n      'valero': {\n        bg: 'bg-green-100 dark:bg-green-900/20',\n        border: 'border-green-500',\n        icon: 'text-green-600 dark:text-green-400'\n      },\n      'marathon': {\n        bg: 'bg-red-100 dark:bg-red-900/20',\n        border: 'border-red-500',\n        icon: 'text-red-600 dark:text-red-400'\n      },\n      'circle k': {\n        bg: 'bg-red-100 dark:bg-red-900/20',\n        border: 'border-red-500',\n        icon: 'text-red-600 dark:text-red-400'\n      },\n      '7-eleven': {\n        bg: 'bg-green-100 dark:bg-green-900/20',\n        border: 'border-green-500',\n        icon: 'text-green-600 dark:text-green-400'\n      },\n      'sunoco': {\n        bg: 'bg-blue-100 dark:bg-blue-900/20',\n        border: 'border-blue-500',\n        icon: 'text-blue-600 dark:text-blue-400'\n      },\n      'costco': {\n        bg: 'bg-red-100 dark:bg-red-900/20',\n        border: 'border-red-500',\n        icon: 'text-red-600 dark:text-red-400'\n      },\n      'sams': {\n        bg: 'bg-blue-100 dark:bg-blue-900/20',\n        border: 'border-blue-500',\n        icon: 'text-blue-600 dark:text-blue-400'\n      },\n      'sam': {\n        bg: 'bg-blue-100 dark:bg-blue-900/20',\n        border: 'border-blue-500',\n        icon: 'text-blue-600 dark:text-blue-400'\n      },\n      'speedway': {\n        bg: 'bg-red-100 dark:bg-red-900/20',\n        border: 'border-red-500',\n        icon: 'text-red-600 dark:text-red-400'\n      },\n      'caseys': {\n        bg: 'bg-red-100 dark:bg-red-900/20',\n        border: 'border-red-500',\n        icon: 'text-red-600 dark:text-red-400'\n      },\n      'wawa': {\n        bg: 'bg-yellow-100 dark:bg-yellow-900/20',\n        border: 'border-yellow-500',\n        icon: 'text-yellow-600 dark:text-yellow-400'\n      },\n      'sheetz': {\n        bg: 'bg-red-100 dark:bg-red-900/20',\n        border: 'border-red-500',\n        icon: 'text-red-600 dark:text-red-400'\n      },\n      'maverik': {\n        bg: 'bg-blue-100 dark:bg-blue-900/20',\n        border: 'border-blue-500',\n        icon: 'text-blue-600 dark:text-blue-400'\n      },\n      'kwik': {\n        bg: 'bg-red-100 dark:bg-red-900/20',\n        border: 'border-red-500',\n        icon: 'text-red-600 dark:text-red-400'\n      },\n      'quick': {\n        bg: 'bg-blue-100 dark:bg-blue-900/20',\n        border: 'border-blue-500',\n        icon: 'text-blue-600 dark:text-blue-400'\n      },\n      'love': {\n        bg: 'bg-red-100 dark:bg-red-900/20',\n        border: 'border-red-500',\n        icon: 'text-red-600 dark:text-red-400'\n      },\n      'pilot': {\n        bg: 'bg-blue-100 dark:bg-blue-900/20',\n        border: 'border-blue-500',\n        icon: 'text-blue-600 dark:text-blue-400'\n      },\n      'flying j': {\n        bg: 'bg-blue-100 dark:bg-blue-900/20',\n        border: 'border-blue-500',\n        icon: 'text-blue-600 dark:text-blue-400'\n      },\n      'ta': {\n        bg: 'bg-red-100 dark:bg-red-900/20',\n        border: 'border-red-500',\n        icon: 'text-red-600 dark:text-red-400'\n      }\n    };\n    \n    // Find a matching style\n    for (const [key, styles] of Object.entries(styleMap)) {\n      if (normalizedName.includes(key)) {\n        return styles;\n      }\n    }\n    \n    // Return default styles if no match\n    return defaultStyles;\n  };\n  \n  // Logic to handle single visit processing\n  const handleSingleVisit = async () => {\n    try {\n      setIsProcessing(true);\n      \n      // Create a timestamp\n      const timestamp = new Date().toLocaleTimeString();\n      const startTime = Date.now();\n      \n      // Extract the work order ID from the URL if possible\n      const urlParts = visitUrl.split('/');\n      const workUrlIndex = urlParts.findIndex(part => part === 'work');\n      const workOrderId = workUrlIndex >= 0 && workUrlIndex + 1 < urlParts.length \n        ? `W-${urlParts[workUrlIndex + 1]}` \n        : selectedWorkOrder?.id;\n      \n      // Get the store name and visit number from the URL\n      const { storeName, visitNumber, dispenserCount: visitDispenserCount } = extractVisitInfo(visitUrl);\n      \n      // Get the dispenser count from the store data using the correct work order ID\n      let dispenserCount = 0;\n      if (workOrderId) {\n        dispenserCount = getDispenserCountDirect(workOrderId);\n        console.log('üîç Work order ID for dispenser count:', workOrderId);\n      } else if (selectedWorkOrder) {\n        dispenserCount = getDispenserCountDirect(selectedWorkOrder.id);\n      }\n      \n      // If still no dispenser count, use the one from visit info as fallback\n      if (!dispenserCount && visitDispenserCount) {\n        dispenserCount = visitDispenserCount;\n      }\n      \n      console.log('üîç Final dispenser count:', dispenserCount);\n      \n      // Add a new job to the list with the dispenser count\n      const newJob: FormJob = {\n        url: visitUrl,\n        status: 'running',\n        message: 'Initializing automation...',\n        timestamp,\n        headless: isHeadless,\n        startTime,\n        dispenserCount  // Store dispenser count in the job\n      };\n      \n      // Add the job to state (at the beginning of the array)\n      const updatedJobs = [newJob, ...formJobs];\n      setFormJobs(updatedJobs);\n      saveToStorage(STORAGE_KEYS.FORM_JOBS, updatedJobs);\n      \n      // Call API to process the visit\n      const result = await processSingleVisit(visitUrl, isHeadless, visitNumber);\n      \n      console.log('Process visit API response:', result);\n      \n      // Save the job ID from the response\n      if (result.jobId) {\n        console.log(`Received job ID from server: ${result.jobId}`);\n        setSingleJobId(result.jobId);\n        saveToStorage(STORAGE_KEYS.SINGLE_JOB_ID, result.jobId);\n        \n        // Also update the job in the jobs list with the ID\n        const jobsWithId = [...updatedJobs];\n        if (jobsWithId.length > 0) {\n          jobsWithId[0] = {\n            ...jobsWithId[0],\n            jobId: result.jobId,\n            status: 'running',\n            message: 'Processing started...',\n            storeName,\n            visitNumber,\n            dispenserCount\n          };\n          \n          setFormJobs(jobsWithId);\n          saveToStorage(STORAGE_KEYS.FORM_JOBS, jobsWithId);\n        }\n                    } else {\n        console.warn('No job ID received from server');\n      }\n      \n      // Start polling for status updates\n      startPolling();\n            \n            // Show success toast\n            addToast(\n              'success',\n        `Processing started for ${storeName || 'visit'}`\n            );\n    } catch (error) {\n      console.error('Error processing visit:', error);\n      \n        // Update the job status to error\n      const errorJobs = [...formJobs];\n      if (errorJobs.length > 0) {\n        errorJobs[0] = {\n          ...errorJobs[0],\n              status: 'error',\n          message: error instanceof Error ? error.message : 'An unknown error occurred',\n              endTime: Date.now()\n            };\n        \n        setFormJobs(errorJobs);\n        saveToStorage(STORAGE_KEYS.FORM_JOBS, errorJobs);\n      }\n      \n      // Show error toast\n      addToast(\n        'error',\n        error instanceof Error ? error.message : 'An unknown error occurred'\n      );\n    } finally {\n      setIsProcessing(false);\n    }\n  };\n  \n  // Logic to cancel form automation\n  const handleStopProcessing = async () => {\n    try {\n      setIsProcessing(true); // Show processing state during cancellation\n        \n      // Get the running job to ensure we have the correct job ID\n      const runningJob = formJobs.find(job => job.status === 'running');\n          \n      if (!runningJob && !singleJobId) {\n        throw new Error('No running job found to cancel');\n      }\n      \n      // Debug info for job ID tracking\n      console.log('Cancellation request details:', {\n        singleJobId,\n        runningJobDetails: runningJob ? {\n          url: runningJob.url,\n          status: runningJob.status,\n          jobId: runningJob.jobId || 'No Job ID'\n        } : 'No running job in formJobs'\n      });\n      \n      // Use the jobId from the running job record if available, otherwise fall back to singleJobId\n      const jobIdToCancel = runningJob?.jobId || singleJobId;\n      \n      if (!jobIdToCancel) {\n        throw new Error('No job ID available for cancellation');\n      }\n      \n      // Call API to cancel the automation with the job ID\n      console.log(`Using job ID for cancellation: ${jobIdToCancel}`);\n      const result = await cancelFormAutomation(jobIdToCancel);\n      \n      // Validate cancellation was successful\n      if (!result || !result.success) {\n        throw new Error(result?.message || 'Failed to cancel automation process');\n      }\n      \n      console.log('Cancellation API reported success');\n      \n      // Update the job status in localStorage and state\n      const updatedJobs = [...formJobs];\n      const jobIndex = updatedJobs.findIndex(job => job.status === 'running');\n              \n              if (jobIndex !== -1) {\n                updatedJobs[jobIndex] = {\n                  ...updatedJobs[jobIndex],\n          status: 'error',\n          message: 'Processing stopped by user',\n          endTime: Date.now()\n                };\n                \n        // Update both state and localStorage\n        setFormJobs(updatedJobs);\n        saveToStorage(STORAGE_KEYS.FORM_JOBS, updatedJobs);\n      }\n      \n      // Clear all active intervals\n      if (polling) {\n        clearInterval(polling);\n        setPolling(null);\n      }\n      \n      // Reset state\n      setSingleJobId(null);\n      setPollingSingle(false);\n            setIsProcessing(false);\n      \n      // Update localStorage to reflect stopped state\n      saveToStorage(STORAGE_KEYS.SINGLE_JOB_ID, null);\n            \n            // Show success toast\n            addToast(\n              'success',\n        result.message || 'Processing stopped successfully'\n      );\n    } catch (error) {\n      console.error('Error stopping automation:', error);\n      setIsProcessing(false);\n      \n      // Show error toast\n      addToast(\n        'error',\n        error instanceof Error ? error.message : 'An unknown error occurred'\n      );\n    }\n  };\n  \n  // Preview batch file contents\n  const handlePreviewBatch = async () => {\n    try {\n      setIsProcessing(true);\n      \n      // Call API to preview the batch file\n      const url = await ENDPOINTS.FORM_AUTOMATION_PREVIEW_BATCH();\n      const response = await fetch(url, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          filePath: batchFilePath\n        }),\n      });\n      \n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.error || 'Failed to preview batch file');\n      }\n      \n      const data = await response.json();\n      \n      if (data && Array.isArray(data.visits)) {\n        setPreviewData(data.visits);\n        // Select all visits by default\n        setSelectedVisits(data.visits.map((visit: any) => visit.id));\n      } else {\n        throw new Error('Invalid response format from preview API');\n      }\n    } catch (error) {\n      console.error('Error previewing batch file:', error);\n      \n      // Show error toast\n      addToast(\n        'error',\n        error instanceof Error ? error.message : 'An unknown error occurred'\n      );\n    } finally {\n      setIsProcessing(false);\n    }\n  };\n  \n  // Select all visits\n  const handleSelectAll = () => {\n    setSelectedVisits(previewData.map(visit => visit.id));\n  };\n  \n  // Deselect all visits\n  const handleDeselectAll = () => {\n    setSelectedVisits([]);\n  };\n  \n  // Toggle a visit selection\n  const handleToggleVisit = (visitId: string) => {\n    setSelectedVisits(prev => {\n      if (prev.includes(visitId)) {\n        return prev.filter(id => id !== visitId);\n      } else {\n        return [...prev, visitId];\n      }\n    });\n  };\n  \n  // Add useEffect to automatically preview when batchFilePath changes\n  useEffect(() => {\n    if (activeTab === 'batch' && batchFilePath) {\n      handlePreviewBatch();\n    }\n  }, [batchFilePath, activeTab]);\n  \n  // Get week label from date\n  const getWeekLabel = (dateStr: string): string => {\n    if (!dateStr) return 'No Date';\n    \n    const date = new Date(dateStr);\n    \n    // Format date range for the week\n    const firstDayOfWeek = new Date(date);\n    firstDayOfWeek.setDate(date.getDate() - date.getDay()); // Start with Sunday\n    \n    const lastDayOfWeek = new Date(firstDayOfWeek);\n    lastDayOfWeek.setDate(firstDayOfWeek.getDate() + 6); // End with Saturday\n    \n    // Format as Month/Day - Month/Day without year\n    const firstMonth = firstDayOfWeek.getMonth() + 1;\n    const lastMonth = lastDayOfWeek.getMonth() + 1;\n    const firstDay = firstDayOfWeek.getDate();\n    const lastDay = lastDayOfWeek.getDate();\n    \n    if (firstMonth === lastMonth) {\n      // Same month - always show month in both dates\n      return `${firstMonth}/${firstDay} - ${firstMonth}/${lastDay}`;\n    } else {\n      // Different months\n      return `${firstMonth}/${firstDay} - ${lastMonth}/${lastDay}`;\n    }\n  };\n  \n  // Render visits grouped by selected criteria\n  const renderGroupedVisits = () => {\n    if (previewData.length === 0) {\n      return (\n        <div className="p-6 flex flex-col items-center justify-center text-center">\n          <svg className="w-12 h-12 text-gray-400 dark:text-gray-500 mb-3" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">\n            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />\n          </svg>\n          <div className="text-gray-500 dark:text-gray-400">No visit data available</div>\n          <p className="text-xs text-gray-400 dark:text-gray-500 mt-1">Please wait while we load the visit information</p>\n        </div>\n      );\n    }\n    \n    // Table format for all visits regardless of grouping\n    const renderVisitTable = (visits: any[]) => {\n      return (\n        <table className="min-w-full divide-y divide-gray-200 dark:divide-gray-700">\n          <thead className="bg-gray-50 dark:bg-gray-800">\n            <tr>\n              <th scope="col" className="px-4 py-2 text-left">\n                <div className="flex items-center">\n                  <input\n                    type="checkbox"\n                    className="form-checkbox h-4 w-4 text-primary-600 rounded border-gray-300 dark:border-gray-600 focus:ring-primary-500 focus:ring-offset-gray-100 dark:focus:ring-offset-gray-800 mr-2"\n                    checked={visits.every((v: any) => selectedVisits.includes(v.id))}\n                    onChange={() => {\n                      const visitIds = visits.map((v: any) => v.id);\n                      const allSelected = visitIds.every((id: string) => selectedVisits.includes(id));\n                      \n                      if (allSelected) {\n                        // Deselect all\n                        setSelectedVisits(prev => prev.filter((id: string) => !visitIds.includes(id)));\n                      } else {\n                        // Select all\n                        setSelectedVisits(prev => {\n                          const newSelected = [...prev];\n                          visitIds.forEach((id: string) => {\n                            if (!newSelected.includes(id)) {\n                              newSelected.push(id);\n                            }\n                          });\n                          return newSelected;\n                        });\n                      }\n                    }}\n                  />\n                  <span className="text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Store</span>\n                </div>\n              </th>\n              <th scope="col" className="px-4 py-2 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">\n                Visit #\n              </th>\n              <th scope="col" className="px-4 py-2 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">\n                Date\n              </th>\n              <th scope="col" className="px-4 py-2 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">\n                Dispensers\n              </th>\n            </tr>\n          </thead>\n          <tbody className="bg-white dark:bg-gray-800 divide-y divide-gray-200 dark:divide-gray-700">\n            {visits.map(visit => {\n              const storeStyles = getStoreStyles(visit.storeName || '');\n              return (\n                <tr \n                  key={visit.id}\n                  className={`hover:bg-gray-50 dark:hover:bg-gray-700/50 cursor-pointer transition-colors ${\n                    selectedVisits.includes(visit.id) ? `${storeStyles.bg} border-l-4 ${storeStyles.border}` : ''\n                  }`}\n                  onClick={(e) => {\n                    // Prevent toggle if clicking on the checkbox itself (to avoid double-toggle)\n                    if (!(e.target as HTMLElement).closest('input[type="checkbox"]')) {\n                      handleToggleVisit(visit.id);\n                    }\n                  }}\n                >\n                  <td className="px-4 py-3 whitespace-nowrap">\n                    <div className="flex items-center">\n                      <input\n                        type="checkbox"\n                        className="form-checkbox h-5 w-5 text-primary-600 rounded border-gray-300 dark:border-gray-600 focus:ring-primary-500 focus:ring-offset-gray-100 dark:focus:ring-offset-gray-800 mr-3"\n                        checked={selectedVisits.includes(visit.id)}\n                        onChange={() => handleToggleVisit(visit.id)}\n                        id={`visit-${visit.id}`}\n                      />\n                      <div className={`flex-shrink-0 w-8 h-8 flex items-center justify-center rounded-full ${storeStyles.bg} mr-3`}>\n                        <FiMapPin className={`${storeStyles.icon}`} />\n                      </div>\n                      <div>\n                        <div className="font-medium">{visit.storeName || 'Unknown Store'}</div>\n                        <div className="text-xs text-gray-500 dark:text-gray-400">\n                          {visit.storeId ? `ID: ${visit.storeId}` : 'No ID'}\n                        </div>\n                      </div>\n                    </div>\n                  </td>\n                  <td className="px-4 py-3 font-mono whitespace-nowrap">\n                    {visit.visitId || extractVisitNumber(visit.visitUrl) || 'N/A'}\n                  </td>\n                  <td className="px-4 py-3 whitespace-nowrap">\n                    {formatDate(visit.date)}\n                  </td>\n                  <td className="px-4 py-3 text-center whitespace-nowrap">\n                    <span className="inline-flex items-center justify-center w-8 h-8 rounded-full bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 font-medium">\n                      {visit.dispenserCount || '0'}\n                    </span>\n                  </td>\n                </tr>\n              );\n            })}\n          </tbody>\n        </table>\n      );\n    };\n\n    // No grouping, render all visits in table format\n    if (groupBy === 'none') {\n      return (\n        <div className="overflow-hidden">\n          {renderVisitTable(previewData)}\n        </div>\n      );\n    }\n    \n    // For other groupings, build the groups but still use table format for each group\n    const groupedVisits: Record<string, any[]> = {};\n    \n    previewData.forEach(visit => {\n      let groupKey = 'Unknown';\n      \n      if (groupBy === 'date') {\n        groupKey = formatDate(visit.date) || 'Unknown Date';\n      } else if (groupBy === 'week') {\n        groupKey = getWeekLabel(visit.date) || 'Unknown Week';\n      }\n      \n      if (!groupedVisits[groupKey]) {\n        groupedVisits[groupKey] = [];\n      }\n      \n      groupedVisits[groupKey].push(visit);\n    });\n    \n    // Sort group keys\n    const sortedGroups = Object.keys(groupedVisits).sort((a, b) => {\n      // For dates, sort chronologically\n      if (groupBy === 'date' || groupBy === 'week') {\n        const dateA = new Date(groupedVisits[a][0].date);\n        const dateB = new Date(groupedVisits[b][0].date);\n        return dateA.getTime() - dateB.getTime();\n      }\n      // For other groups, sort alphabetically\n      return a.localeCompare(b);\n    });\n    \n    // Render the groups with tables\n    return (\n      <div className="divide-y divide-gray-200 dark:divide-gray-700">\n        {sortedGroups.map(groupName => {\n          const visits = groupedVisits[groupName];\n          return (\n            <div key={groupName} className="group">\n              <div className="bg-gray-100 dark:bg-gray-700 px-4 py-2 flex items-center justify-between sticky top-0 z-10">\n                <h4 className="font-medium text-sm text-gray-700 dark:text-gray-100 flex items-center">\n                  {(groupBy === 'date' || groupBy === 'week') && <FiClock className="mr-2 h-4 w-4 text-gray-500 dark:text-gray-400" />}\n                  {groupName}\n                  <span className="ml-2 bg-gray-200 dark:bg-gray-600 text-gray-700 dark:text-gray-300 text-xs rounded-full px-2 py-0.5">\n                    {visits.length}\n                  </span>\n                </h4>\n                <div className="flex items-center space-x-2">\n                  <button\n                    onClick={() => {\n                      const groupVisitIds = visits.map(v => v.id);\n                      const allSelected = groupVisitIds.every(id => selectedVisits.includes(id));\n                      \n                      if (allSelected) {\n                        // Deselect all in this group\n                        setSelectedVisits(prev => prev.filter(id => !groupVisitIds.includes(id)));\n                      } else {\n                        // Select all in this group\n                        setSelectedVisits(prev => {\n                          const newSelected = [...prev];\n                          groupVisitIds.forEach(id => {\n                            if (!newSelected.includes(id)) {\n                              newSelected.push(id);\n                            }\n                          });\n                          return newSelected;\n                        });\n                      }\n                    }}\n                    className="text-xs text-primary-600 dark:text-primary-400 hover:text-primary-700 dark:hover:text-primary-300 font-medium"\n                  >\n                    {visits.every(v => selectedVisits.includes(v.id)) ? 'Deselect All' : 'Select All'}\n                  </button>\n                </div>\n              </div>\n              <div>\n                {renderVisitTable(visits)}\n              </div>\n            </div>\n          );\n        })}\n      </div>\n    );\n  };\n  \n  // Helper function to get status icon\n  const getStatusIcon = (status: 'idle' | 'running' | 'completed' | 'error') => {\n    switch (status) {\n      case 'running': return <FiRefreshCw className="h-4 w-4 text-primary-500 animate-spin" />;\n      case 'completed': return <FiCheck className="h-4 w-4 text-green-500" />;\n      case 'error': return <FiX className="h-4 w-4 text-red-500" />;\n      default: return <FiClock className="h-4 w-4 text-gray-400" />;\n    }\n  };\n  \n  // Format date for display\n  const formatDate = (dateStr: string) => {\n    const date = new Date(dateStr);\n    return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });\n  };\n  \n  // Format automation duration in a readable format\n  const formatDuration = (startTime?: number, endTime?: number): string => {\n    if (!startTime) return "N/A";\n    \n    const end = endTime || Date.now();\n    const durationMs = end - startTime;\n    \n    // If less than a minute, show seconds\n    if (durationMs < 60000) {\n      return `${Math.round(durationMs / 1000)}s`;\n    }\n    \n    // If less than an hour, show minutes and seconds\n    if (durationMs < 3600000) {\n      const minutes = Math.floor(durationMs / 60000);\n      const seconds = Math.round((durationMs % 60000) / 1000);\n      return `${minutes}m ${seconds}s`;\n    }\n    \n    // Show hours, minutes, and seconds\n    const hours = Math.floor(durationMs / 3600000);\n    const minutes = Math.floor((durationMs % 3600000) / 60000);\n    const seconds = Math.round((durationMs % 60000) / 1000);\n    return `${hours}h ${minutes}m ${seconds}s`;\n  };\n  \n  // Open URL with auto-login\n  const openUrlWithLogin = async (url: string) => {\n    try {\n      // Call the API to open the URL with login\n      const response = await fetch('/api/open-url', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({ url })\n      });\n      \n      if (!response.ok) {\n        throw new Error(`Failed to open URL: ${response.status}`);\n      }\n      \n      const data = await response.json();\n      \n      if (!data.success) {\n        throw new Error(data.message || 'Failed to open URL');\n      }\n      \n      // Show success toast\n      addToast(\n        'info',\n        'The URL has been opened in a new window'\n      );\n    } catch (error) {\n      console.error('Error opening URL:', error);\n      \n      // Show error toast\n      addToast(\n        'error',\n        error instanceof Error ? error.message : 'An unknown error occurred'\n      );\n    }\n  };\n  \n  // Establish a global interval to keep localStorage and state in sync\n  useEffect(() => {\n    // Set up an interval that runs periodically regardless of component focus\n    const syncInterval = setInterval(() => {\n      // Get latest stored state\n      const storedJobId = getFromStorage(STORAGE_KEYS.SINGLE_JOB_ID, null);\n      const storedIsPolling = getFromStorage(STORAGE_KEYS.IS_POLLING_SINGLE, false);\n      \n      // Only proceed if we have an active job\n      if (storedJobId && storedIsPolling) {\n        console.log('Background sync checking status...');\n        \n        // Fetch current status from server\n        getFormAutomationStatus()\n          .then(status => {\n            if (!status) return;\n            \n            // Update status in localStorage directly\n            const storedJobs = getFromStorage(STORAGE_KEYS.FORM_JOBS, []);\n            const activeJobIndex = storedJobs.findIndex((job: FormJob) => job.status === 'running');\n            \n            if (activeJobIndex !== -1) {\n              // Update the job in storage\n              updateJobStatus(status);\n            }\n          })\n          .catch(error => {\n            console.error('Error in background sync:', error);\n          });\n      }\n    }, 5000); // Check every 5 seconds, separate from the main polling interval\n    \n    // Clean up\n    return () => {\n      clearInterval(syncInterval);\n    };\n  }, []);\n  \n  // Register a beforeunload handler to ensure localStorage is updated when leaving the page\n  useEffect(() => {\n    const handleBeforeUnload = () => {\n      // Make sure the most current state is saved to localStorage before unloading\n      saveToStorage(STORAGE_KEYS.FORM_JOBS, formJobs);\n      saveToStorage(STORAGE_KEYS.SINGLE_JOB_ID, singleJobId);\n      saveToStorage(STORAGE_KEYS.IS_POLLING_SINGLE, pollingSingle);\n      saveToStorage(STORAGE_KEYS.BATCH_JOB_ID, batchJobId);\n    };\n    \n    window.addEventListener('beforeunload', handleBeforeUnload);\n    \n    return () => {\n      window.removeEventListener('beforeunload', handleBeforeUnload);\n    };\n  }, [formJobs, singleJobId, pollingSingle, batchJobId]);\n\n  // Start polling for status updates\n  const startPolling = () => {\n    // Set the polling flag\n    setPollingSingle(true);\n    \n    // Create a polling interval if one doesn't exist\n    if (!polling) {\n      const newInterval = setInterval(async () => {\n        try {\n          const status = await getFormAutomationStatus();\n          console.log('Polling: Form automation status:', status);\n          \n          // Update all jobs with status changes\n          setFormJobs(prev => {\n            const updatedJobs = [...prev];\n            // Find the job that's currently running\n            const jobIndex = updatedJobs.findIndex(job => job.status === 'running' && job.jobId === singleJobId);\n            \n            if (jobIndex !== -1) {\n              const prevStatus = updatedJobs[jobIndex].status;\n              const endTime = (status.status === 'completed' || status.status === 'error') \n                ? Date.now() \n                : undefined;\n              \n              // Update the job with the new status\n              updatedJobs[jobIndex] = {\n                ...updatedJobs[jobIndex],\n                status: status.status,\n                message: status.message || updatedJobs[jobIndex].message,\n                endTime: endTime || updatedJobs[jobIndex].endTime,\n                // Set flags for status changes (for toast notifications)\n                _statusChanged: prevStatus !== status.status,\n                _completed: status.status === 'completed' && prevStatus !== 'completed',\n                _error: status.status === 'error' && prevStatus !== 'error'\n              };\n              \n              // Also save to localStorage to persist across page navigations\n              saveToStorage(STORAGE_KEYS.FORM_JOBS, updatedJobs);\n              \n              // If the job completed or errored, stop polling\n              if (status.status === 'completed' || status.status === 'error') {\n                console.log('Job completed or errored, stopping polling');\n                clearInterval(newInterval);\n                setPolling(null);\n                setPollingSingle(false);\n                setSingleJobId(null);\n                saveToStorage(STORAGE_KEYS.SINGLE_JOB_ID, null);\n              }\n            }\n            \n            return updatedJobs;\n          });\n        } catch (error) {\n          console.error('Error polling for status:', error);\n        }\n      }, 2000); // Poll every 2 seconds\n      \n      // Save the interval ID so we can clear it later\n      setPolling(newInterval);\n    }\n  };\n\n  // Add a useEffect to load dispenser details when a work order is selected\n  useEffect(() => {\n    if (selectedWorkOrder?.id) {\n      // Try to load dispenser details for the selected work order\n      getDispensersForWorkOrder(selectedWorkOrder.id)\n        .then((data: any) => {\n          if (data && data.dispensers) {\n            setDispenserDetails(prev => ({\n              ...prev,\n              [selectedWorkOrder.id]: data\n            }));\n            console.log(`Loaded ${data.dispensers.length} dispensers for ${selectedWorkOrder.id}`);\n          }\n        })\n        .catch((error: Error) => {\n          console.error('Error loading dispenser details:', error);\n        });\n    }\n  }, [selectedWorkOrder]);\n\n  // Function to handle batch processing\n  const handleBatchProcess = async () => {\n    if (selectedVisits.length === 0) {\n      addToast('warning', 'Please select at least one visit to process');\n      return;\n    }\n\n    try {\n      setIsProcessing(true);\n      \n      // Prepare the batch processing request with the correct parameters\n      const result = await processBatchVisits(\n        batchFilePath, \n        isHeadless,\n        { \n          selectedVisits: selectedVisits,\n          resumeFromBatchId: resumeBatch && lastFailedBatch ? lastFailedBatch.jobId : undefined \n        }\n      );\n      \n      // Add success property to match BatchProcessResult interface\n      const batchResult: BatchProcessResult = { ...result, success: true };\n      \n      setBatchJobId(batchResult.jobId);\n      saveToStorage(STORAGE_KEYS.BATCH_JOB_ID, batchResult.jobId);\n      \n      // Add a new batch job to the history\n      const newBatchJob: BatchJob = {\n        filePath: 'Selected visits',\n        timestamp: new Date().toLocaleString(),\n        status: 'running',\n        message: batchResult.message || 'Processing batch visits...',\n        totalVisits: batchResult.totalVisits || selectedVisits.length,\n        completedVisits: 0,\n        headless: isHeadless\n      };\n      \n      setBatchJobs(prev => [newBatchJob, ...prev]);\n      addToast('success', `Batch processing started with ${selectedVisits.length} visits`);\n      \n      // Start polling for batch status\n      startBatchPolling();\n    } catch (error) {\n      console.error('Error starting batch process:', error);\n      setIsProcessing(false);\n      addToast('error', error instanceof Error ? error.message : 'Failed to start batch processing');\n    }\n  };\n  \n  // Function to start polling for batch status\n  const startBatchPolling = () => {\n    const pollInterval = setInterval(async () => {\n      try {\n        // Find the currently running job to get its ID\n        let currentRunningJobId: string | null = null;\n        setBatchJobs(prev => {\n          const runningJob = prev.find(job => job.status === 'running');\n          if (runningJob && runningJob.jobId) {\n            currentRunningJobId = runningJob.jobId;\n          }\n          return prev; // No actual state change, just reading\n        });\n\n        if (currentRunningJobId) {\n          const status = await getBatchAutomationStatus(currentRunningJobId);\n        \n          if (status) {\n            // Update batch jobs with the current status\n            setBatchJobs(prev => {\n              const updatedJobs = [...prev];\n              const jobIndex = updatedJobs.findIndex(job => job.status === 'running');\n              \n              if (jobIndex !== -1) {\n                updatedJobs[jobIndex] = {\n                  ...updatedJobs[jobIndex],\n                  status: status.status,\n                  message: status.message || updatedJobs[jobIndex].message,\n                  completedVisits: status.completedVisits || updatedJobs[jobIndex].completedVisits\n                };\n                \n                // If batch completed or errored, save it and stop polling\n                if (status.status === 'completed' || status.status === 'error') {\n                  // If it errored, save as the last failed batch\n                  if (status.status === 'error') {\n                    setLastFailedBatch(updatedJobs[jobIndex]);\n                  }\n                  \n                  clearInterval(pollInterval);\n                  setIsProcessing(false);\n                  setBatchJobId(null);\n                  saveToStorage(STORAGE_KEYS.BATCH_JOB_ID, null);\n                  \n                  // Show appropriate toast\n                  if (status.status === 'completed') {\n                    addToast('success', 'Batch processing completed successfully');\n                  } else {\n                    addToast('error', status.message || 'An error occurred during batch processing');\n                  }\n                }\n              }\n              \n              return updatedJobs;\n            });\n          }\n        }\n      } catch (error) {\n        console.error('Error polling batch status:', error);\n      }\n    }, 3000);\n    // No return statement, to avoid type errors\n  };\n\n  return (\n    <>\n    <div className="min-h-screen bg-gray-50 dark:bg-gray-900">\n      <div className="p-6 max-w-7xl mx-auto">\n        <div className="space-y-6 animate-fadeIn">\n          {/* Page header - updated to match Dashboard Header style */}\n          <div className="bg-gradient-to-r from-gray-800 to-gray-900 dark:from-gray-900 dark:to-gray-950 text-white rounded-xl shadow-lg mb-6 flex flex-col overflow-hidden border border-gray-700 dark:border-gray-800">\n            <div className="p-5 flex flex-col md:flex-row md:items-center justify-between gap-4">\n              <div className="flex items-center">\n                <div className="h-10 w-10 rounded-lg bg-blue-50 dark:bg-blue-900/30 flex items-center justify-center text-blue-600 dark:text-blue-400 mr-3">\n                  <FiFileText className="h-5 w-5" />\n                </div>\n                <div>\n                  <h1 className="text-xl font-semibold text-white mb-0">Form Prep</h1>\n                  <p className="text-sm text-gray-300 mt-0.5">Automate form completion for service visits</p>\n                </div>\n              </div>\n              \n              <div className="relative z-10">\n                {/* Decorative element */}\n                <div className="absolute top-0 right-0 w-32 h-32 -mt-8 -mr-8 bg-gradient-to-br from-primary-400/20 to-primary-600/10 rounded-full blur-xl"></div>\n                \n                {/* Tab buttons - updated to match Dashboard Action Buttons */}\n                <div className="flex items-center space-x-2 relative z-10">\n                  <button\n                    onClick={() => setActiveTab('single')}\n                    className={`px-4 py-2 rounded-md flex items-center gap-2 transition-colors ${activeTab === 'single' ? 'bg-blue-600 text-white' : 'bg-[#2d3c55] text-gray-300 hover:bg-[#3a4a66]'}`}\n                  >\n                    <FiFileText className="h-4 w-4" />\n                    Single Visit\n                  </button>\n                  <button\n                    onClick={() => setActiveTab('batch')}\n                    className={`px-4 py-2 rounded-md flex items-center gap-2 transition-colors ${activeTab === 'batch' ? 'bg-blue-600 text-white' : 'bg-[#2d3c55] text-gray-300 hover:bg-[#3a4a66]'}`}\n                  >\n                    <FiUpload className="h-4 w-4" />\n                    Batch Mode\n                  </button>\n                </div>\n              </div>\n            </div>\n          </div>\n\n          {activeTab === 'single' && (\n            <div className="space-y-6">\n              {/* Work Order Selection Panel */}\n              <div className="panel">\n                <div className="panel-header">\n                  <h2 className="panel-title flex items-center space-x-2 mb-0">\n                    <FiClipboard />\n                    <span>Select Work Order</span>\n                  </h2>\n                </div>\n                \n                <div className="mt-4">\n                  <div className="flex items-center justify-between mb-4">\n                    {selectedWorkOrder && (\n                      <div className="flex items-center">\n                        <div className="badge badge-primary flex items-center space-x-1 py-1 px-3">\n                          <span>{selectedWorkOrder?.customer?.name}</span>\n                          <span className="font-mono text-xs ml-1">({extractVisitNumber(selectedWorkOrder?.visits?.nextVisit?.url || '')})</span>\n                        </div>\n                      </div>\n                    )}\n                  </div>\n                  \n                  <div className="border rounded-lg overflow-hidden border-gray-200 dark:border-gray-700 shadow-sm">\n                    <div className="flex items-center justify-between px-4 py-3 bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700">\n                      <button \n                        className="btn btn-sm btn-icon text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300"\n                        onClick={goToPreviousWeek}\n                        disabled={currentWeekIndex <= 0}\n                      >\n                        <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">\n                          <path fillRule="evenodd" d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z" clipRule="evenodd" />\n                        </svg>\n                      </button>\n                      \n                      <div className="flex items-center">\n                        <h3 className="text-md font-semibold text-gray-700 dark:text-gray-300">\n                          {groupedWorkOrders.length > 0 && currentWeekIndex < groupedWorkOrders.length ? \n                            `Week of ${groupedWorkOrders[currentWeekIndex].week}` : 'No work orders'}\n                        </h3>\n                        <span className="ml-2 badge badge-secondary py-1 px-2 text-xs">\n                          {groupedWorkOrders.length > 0 && currentWeekIndex < groupedWorkOrders.length ? \n                            groupedWorkOrders[currentWeekIndex].orders.length : 0} orders\n                        </span>\n                      </div>\n                      \n                      <div className="flex items-center space-x-2">\n                        <button \n                          className="btn btn-sm bg-primary-50 hover:bg-primary-100 text-primary-600 border border-primary-200 dark:bg-primary-900/20 dark:hover:bg-primary-900/30 dark:text-primary-400 dark:border-primary-800"\n                          onClick={goToCurrentWeek}\n                        >\n                          Today\n                        </button>\n                        <button \n                          className="btn btn-sm btn-icon text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300"\n                          onClick={goToNextWeek}\n                          disabled={currentWeekIndex >= groupedWorkOrders.length - 1}\n                        >\n                          <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">\n                            <path fillRule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clipRule="evenodd" />\n                          </svg>\n                        </button>\n                      </div>\n                    </div>\n                  \n                    <div className="overflow-x-auto">\n                      {filteredWorkOrders.length === 0 ? (\n                        <div className="p-6 text-center">\n                          <div className="inline-flex items-center justify-center w-16 h-16 rounded-full bg-gray-100 dark:bg-gray-800 mb-4">\n                            <FiClipboard className="h-6 w-6 text-gray-400" />\n                          </div>\n                          <h3 className="text-md font-medium text-gray-700 dark:text-gray-300 mb-1">No work orders found</h3>\n                          <p className="text-sm text-gray-500 dark:text-gray-400">There are no work orders available for this period.</p>\n                        </div>\n                      ) : groupedWorkOrders.length === 0 ? (\n                        <div className="p-6 text-center">\n                          <div className="inline-flex items-center justify-center w-16 h-16 rounded-full bg-gray-100 dark:bg-gray-800 mb-4">\n                            <FiClipboard className="h-6 w-6 text-gray-400" />\n                          </div>\n                          <h3 className="text-md font-medium text-gray-700 dark:text-gray-300 mb-1">No work orders found</h3>\n                          <p className="text-sm text-gray-500 dark:text-gray-400">There are no work orders available for any week.</p>\n                        </div>\n                      ) : (\n                        <div>\n                          {currentWeekIndex < groupedWorkOrders.length && (\n                            <div className="bg-white dark:bg-gray-800">\n                              <table className="min-w-full divide-y divide-gray-200 dark:divide-gray-700">\n                                <thead className="bg-gray-50 dark:bg-gray-800">\n                                  <tr>\n                                    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Store</th>\n                                    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Visit #</th>\n                                    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Date</th>\n                                    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Dispensers</th>\n                                  </tr>\n                                </thead>\n                                <tbody className="bg-white dark:bg-gray-800 divide-y divide-gray-200 dark:divide-gray-700">\n                                  {groupedWorkOrders[currentWeekIndex].orders.map((order) => {\n                                    const storeStyles = getStoreStyles(order.customer.name);\n                                    const dispenserCount = getDispenserCountDirect(order.id);\n                                    return (\n                                      <tr\n                                        key={order.id}\n                                        className={`hover:bg-gray-50 dark:hover:bg-gray-700/50 cursor-pointer transition-colors ${\n                                          selectedWorkOrder?.id === order.id ? \n                                          `${storeStyles.bg} border-l-4 ${storeStyles.border}` : \n                                          ''\n                                        }`}\n                                        onClick={() => {\n                                          setSelectedWorkOrder(order);\n                                        }}\n                                      >\n                                        <td className="px-4 py-3 whitespace-nowrap">\n                                          <div className="flex items-center">\n                                            <div className={`flex-shrink-0 w-8 h-8 flex items-center justify-center rounded-full ${storeStyles.bg} mr-3`}>\n                                              <FiMapPin className={`${storeStyles.icon}`} />\n                                            </div>\n                                            <div>\n                                              <div className="font-medium">{order.customer.name}</div>\n                                              <div className="text-xs text-gray-500 dark:text-gray-400">\n                                                ID: {order.id}\n                                              </div>\n                                            </div>\n                                          </div>\n                                        </td>\n                                        <td className="px-4 py-3 font-mono whitespace-nowrap">\n                                          {extractVisitNumber(order.visits.nextVisit.url)}\n                                        </td>\n                                        <td className="px-4 py-3 whitespace-nowrap">\n                                          {order.visits.nextVisit.date || 'Not scheduled'}\n                                        </td>\n                                        <td className="px-4 py-3 text-center whitespace-nowrap">\n                                          <span className="inline-flex items-center justify-center w-8 h-8 rounded-full bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 font-medium">\n                                            {dispenserCount || '-'}\n                                          </span>\n                                        </td>\n                                      </tr>\n                                    );\n                                  })}\n                                </tbody>\n                              </table>\n                            </div>\n                          )}\n                        </div>\n                      )}\n                    </div>\n                  </div>\n                </div>\n              </div>\n              \n              {/* Visit URL & Process Form Panel */}\n              <div className="panel">\n                <div className="panel-header">\n                  <h2 className="panel-title flex items-center space-x-2 mb-0">\n                    <FiExternalLink />\n                    <span>Process Work Order Visit</span>\n                  </h2>\n                </div>\n                \n                <div className="mt-4 space-y-4">\n                  <div>\n                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">\n                      Visit URL\n                    </label>\n                    <div className="relative flex-1">\n                      <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">\n                        <FiExternalLink className="h-4 w-4 text-gray-400 dark:text-gray-500" />\n                      </div>\n                      <input\n                        type="text"\n                        className="block w-full rounded-lg border-gray-300 dark:border-gray-600 shadow-sm bg-white dark:bg-gray-700 text-gray-700 dark:text-gray-200 pl-10 py-2.5 focus:ring-primary-500 focus:border-primary-500 text-sm"\n                        placeholder="https://app.workfossa.com/visit/..."\n                        value={visitUrl}\n                        onChange={(e) => setVisitUrl(e.target.value)}\n                      />\n                      <div className="absolute inset-y-0 right-0 flex py-1.5 pr-1.5">\n                        <button \n                          className="inline-flex items-center px-3 rounded-md border border-gray-300 dark:border-gray-600 bg-gray-100 hover:bg-gray-200 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-700 dark:text-gray-300 text-sm font-medium"\n                          onClick={() => {\n                            if (visitUrl) {\n                              openUrlWithLogin(visitUrl);\n                            }\n                          }}\n                          disabled={!visitUrl}\n                        >\n                          <FiEye className="mr-1.5 h-4 w-4" />\n                          <span>View</span>\n                        </button>\n                      </div>\n                    </div>\n                  </div>\n                  \n                  <div className="mt-5 bg-gray-50 dark:bg-gray-800/50 rounded-lg p-4 border border-gray-100 dark:border-gray-700">\n                    <h3 className="text-sm font-medium text-gray-800 dark:text-gray-200 mb-3">Automation Options</h3>\n                    <div className="flex items-center">\n                      <label className="flex items-center cursor-pointer">\n                        <input\n                          type="checkbox"\n                          className="form-checkbox h-5 w-5 text-primary-600 rounded border-gray-300 dark:border-gray-600 focus:ring-primary-500"\n                          checked={!isHeadless}\n                          onChange={() => setIsHeadless(!isHeadless)}\n                        />\n                        <span className="ml-2 text-gray-700 dark:text-gray-300">Show browser during automation (debug mode)</span>\n                      </label>\n                    </div>\n                  </div>\n                  \n                  <div className="flex justify-end mt-6 space-x-3">\n                    {pollingSingle ? (\n                      <button\n                        className="btn bg-red-600 hover:bg-red-700 text-white dark:bg-red-600 dark:hover:bg-red-700 flex items-center space-x-2"\n                        onClick={handleStopProcessing}\n                      >\n                        <FiX className="h-4 w-4" />\n                        <span>Stop Processing</span>\n                      </button>\n                    ) : (\n                      <button\n                        className="btn btn-primary flex items-center space-x-2"\n                        onClick={handleSingleVisit}\n                        disabled={isProcessing || !visitUrl}\n                      >\n                        <FiPlay className="h-4 w-4" />\n                        <span>Process Visit Form</span>\n                      </button>\n                    )}\n                  </div>\n                </div>\n              </div>\n              \n              {/* Recent Jobs Panel */}\n              {formJobs.length > 0 && (\n                <div className="panel">\n                  <div className="panel-header">\n                    <h2 className="panel-title flex items-center space-x-2 mb-0">\n                      <FiClipboard />\n                      <span>Recent Form Jobs</span>\n                      {/* Add job status counter badges */}\n                      <div className="flex items-center space-x-1 ml-2">\n                        {formJobs.filter(job => job.status === 'running').length > 0 && (\n                          <span className="bg-primary-100 text-primary-700 dark:bg-primary-800/50 dark:text-primary-400 text-xs rounded-full px-2 py-0.5 flex items-center">\n                            <span className="w-1.5 h-1.5 bg-primary-500 rounded-full animate-pulse mr-1"></span>\n                            {formJobs.filter(job => job.status === 'running').length} Running\n                          </span>\n                        )}\n                        {formJobs.filter(job => job.status === 'completed').length > 0 && (\n                          <span className="bg-green-100 text-green-700 dark:bg-green-800/50 dark:text-green-400 text-xs rounded-full px-2 py-0.5 flex items-center">\n                            <FiCheck className="w-3 h-3 mr-1" />\n                            {formJobs.filter(job => job.status === 'completed').length} Completed\n                          </span>\n                        )}\n                        {formJobs.filter(job => job.status === 'error').length > 0 && (\n                          <span className="bg-red-100 text-red-700 dark:bg-red-800/50 dark:text-red-400 text-xs rounded-full px-2 py-0.5 flex items-center">\n                            <FiX className="w-3 h-3 mr-1" />\n                            {formJobs.filter(job => job.status === 'error').length} Failed\n                          </span>\n                        )}\n                      </div>\n                    </h2>\n                    <div className="flex items-center space-x-2">\n                      {/* Filter options */}\n                      <div className="mr-2">\n                        <select\n                          className="form-select rounded-md border-gray-300 dark:border-gray-600 text-gray-700 dark:text-gray-300 text-xs px-2 py-1 bg-white dark:bg-gray-800 focus:ring-primary-500 focus:border-primary-500"\n                          onChange={(e) => {\n                            // Here we would implement filtering logic\n                            // For now just show a toast indicating the filter was applied\n                            if (e.target.value !== 'all') {\n                              addToast('info', `Filtered to show ${e.target.value} jobs`);\n                            }\n                          }}\n                          defaultValue="all"\n                        >\n                          <option value="all">All Jobs</option>\n                          <option value="running">Running</option>\n                          <option value="completed">Completed</option>\n                          <option value="error">Failed</option>\n                        </select>\n                      </div>\n                      <button\n                        onClick={() => {\n                          // Clear all form jobs and update storage\n                          setFormJobs([]);\n                          saveToStorage(STORAGE_KEYS.FORM_JOBS, []);\n                          addToast('info', 'Recent form jobs cleared');\n                        }}\n                        className="btn btn-sm btn-outline-danger flex items-center space-x-1 px-3 py-1 text-xs"\n                        title="Clear all job history"\n                      >\n                        <svg className="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">\n                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />\n                        </svg>\n                        <span>Clear All</span>\n                      </button>\n                    </div>\n                  </div>\n                  \n                  <div className="mt-4">\n                    <div className="overflow-hidden rounded-lg border border-gray-200 dark:border-gray-700 shadow-sm">\n                      <table className="min-w-full divide-y divide-gray-200 dark:divide-gray-700">\n                        <thead className="bg-gray-100 dark:bg-gray-800/80 text-gray-600 dark:text-gray-300">\n                          <tr>\n                            <th className="px-4 py-3 text-left text-xs font-medium uppercase tracking-wider w-[50%]">\n                              Status\n                            </th>\n                            <th className="px-4 py-3 text-left text-xs font-medium uppercase tracking-wider w-[20%]">\n                              Store & Visit\n                            </th>\n                            <th className="px-4 py-3 text-left text-xs font-medium uppercase tracking-wider w-[15%]">\n                              Timestamp\n                            </th>\n                            <th className="px-4 py-3 text-left text-xs font-medium uppercase tracking-wider w-[15%]">\n                              Mode\n                            </th>\n                          </tr>\n                        </thead>\n                        <tbody className="bg-white dark:bg-gray-800 divide-y divide-gray-200 dark:divide-gray-700">\n                          {formJobs.map((job, index) => {\n                            // Extract visit info if not already stored in the job\n                            const visitInfo = job.storeName && job.visitNumber ? \n                                { storeName: job.storeName, visitNumber: job.visitNumber, dispenserCount: job.dispenserCount || 0 } : \n                                extractVisitInfo(job.url);\n                            \n                            // Remove the ‚ö° symbol from the store name if it exists\n                            const cleanStoreName = visitInfo.storeName.replace(/‚ö°/g, '').trim();\n                            \n                            return (\n                              <tr \n                                key={index}\n                                className={`\n                                  ${job.status === 'running' \n                                    ? 'bg-primary-50 dark:bg-primary-900/20 border-l-2 border-primary-500 shadow-sm' \n                                    : job.status === 'completed' \n                                      ? 'bg-accent-green-50 dark:bg-accent-green-900/20 border-l-2 border-green-500' \n                                      : job.status === 'error' \n                                        ? 'bg-red-50 dark:bg-red-900/20 border-l-2 border-red-500'\n                                        : index % 2 === 1 ? 'bg-gray-50 dark:bg-gray-800/50' : ''\n                                  }\n                                  hover:bg-gray-100 dark:hover:bg-gray-700/50 transition-all duration-150\n                                  cursor-pointer group relative\n                                `}\n                                onClick={() => {\n                                  // No action needed - details removed as requested\n                                  // if (job.url) {\n                                  //   addToast('info', `Viewing details for ${visitInfo.storeName} (${job.status})`);\n                                  // }\n                                }}\n                              >\n                              <td className="px-4 py-3 whitespace-nowrap">\n                                <div className="flex items-center">\n                                  <div className={`flex items-center justify-center w-8 h-8 rounded-full \n                                    ${job.status === 'running' ? 'bg-primary-100 dark:bg-primary-800/50 text-primary-600 dark:text-primary-400 animate-pulse' :\n                                      job.status === 'completed' ? 'bg-green-100 dark:bg-green-800/50 text-green-600 dark:text-green-400' :\n                                      job.status === 'error' ? 'bg-red-100 dark:bg-red-800/50 text-red-600 dark:text-red-400' :\n                                      'bg-gray-100 dark:bg-gray-800 text-gray-500 dark:text-gray-400'\n                                    } mr-2`}>\n                                    {job.status === 'running' && (\n                                      <svg className="w-4 h-4 animate-spin" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">\n                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />\n                                      </svg>\n                                    )}\n                                    {job.status === 'completed' && (\n                                      <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">\n                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />\n                                      </svg>\n                                    )}\n                                    {job.status === 'error' && (\n                                      <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">\n                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />\n                                      </svg>\n                                    )}\n                                    {job.status === 'idle' && (\n                                      <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">\n                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />\n                                      </svg>\n                                    )}\n                                  </div>\n                                  <span className={`font-medium text-sm capitalize\n                                    ${job.status === 'running' ? 'text-primary-700 dark:text-primary-400' :\n                                      job.status === 'completed' ? 'text-green-700 dark:text-green-400' :\n                                      job.status === 'error' ? 'text-red-700 dark:text-red-400' :\n                                      'text-gray-700 dark:text-gray-300'\n                                    }`}>\n                                    {job.status}\n                                  </span>\n                                </div>\n                                \n                                {/* Job progress timeline estimate (only for running jobs) */}\n                                {job.status === 'running' && job.startTime && (\n                                  <div className="mt-1.5 ml-10 flex items-center text-xs text-gray-500 dark:text-gray-400">\n                                    <svg className="w-3.5 h-3.5 mr-1 text-primary-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">\n                                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />\n                                    </svg>\n                                    {(() => {\n                                      // Show elapsed time instead of trying to estimate remaining time\n                                      const elapsedMs = Date.now() - job.startTime;\n                                      const elapsedMinutes = Math.floor(elapsedMs / 60000);\n                                      const elapsedSeconds = Math.floor((elapsedMs % 60000) / 1000);\n                                      \n                                      return `Running for ${elapsedMinutes > 0 ? `${elapsedMinutes}m ` : ''}${elapsedSeconds}s`;\n                                    })()}\n                                  </div>\n                                )}\n                                \n                                {job.message && (\n                                  <div className="text-xs text-gray-500 dark:text-gray-400 mt-1 min-h-[3.75rem]">\n                                    {/* Format messages by type */}\n                                    {job.status === 'completed' \n                                      ? <span className="font-medium text-green-600 dark:text-green-400">Form completed successfully</span>\n                                      : job.status === 'idle' || job.status === 'running'\n                                        ? (() => {\n                                            // Extract Premium and Dispenser info for better display\n                                            let premium = "";\n                                            let dispenser = "";\n                                            let premiumCurrent = 0;\n                                            let premiumTotal = 0;\n                                            let dispenserCurrent = 0;\n                                            let dispenserTotal = 0;\n                                            \n                                            // Try to extract values from different formats of messages\n                                            // Example: "Processing Premium (3/3) - Dispenser #1/2"\n                                            // Or: "Premium: 3/3, Dispenser: #7/8"\n                                            if (job.message) {\n                                              // Check for premium or other fuel types (improved regex)\n                                              const fuelTypes = ['premium', 'regular', 'plus', 'diesel', 'supreme', 'unleaded', 'mid-grade', 'midgrade', 'super', 'ethanol-free', 'ethanol free', 'fuel type', 'fuel grade'];\n                                              const fuelTypePattern = fuelTypes.join('|');\n                                              const premiumRegex = new RegExp(`(?:processing\\s+)?(${fuelTypePattern})(?:[^\\(]*)?\\s*\\(?([0-9]+)\\/([0-9]+)\\)?`, 'i');\n                                              const premiumMatch = job.message.match(premiumRegex);\n                                              \n                                              if (premiumMatch && premiumMatch[1] && premiumMatch[2] && premiumMatch[3]) {\n                                                // Extract the properly capitalized fuel type name\n                                                const matchedType = premiumMatch[1].trim().toLowerCase();\n                                                \n                                                // Always display "Fuel Grade" and append the specific grade if known\n                                                let hasSpecificGrade = false;\n                                                premium = "Fuel Grade";\n                                                \n                                                // Add the specific grade if it's not already "fuel grade" or "fuel type"\n                                                if (matchedType !== 'fuel grade' && matchedType !== 'fuel type') {\n                                                  hasSpecificGrade = true;\n                                                  // Special handling for common fuel types\n                                                  let specificGrade = "";\n                                                  if (matchedType.includes('ethanol')) {\n                                                    specificGrade = 'Ethanol-Free';\n                                                  }\n                                                  else if (matchedType === 'midgrade' || matchedType === 'mid-grade') {\n                                                    specificGrade = 'Mid-Grade';\n                                                  }\n                                                  else {\n                                                    // Standard capitalization for other fuel types\n                                                    specificGrade = matchedType.charAt(0).toUpperCase() + matchedType.slice(1);\n                                                  }\n                                                  \n                                                  // Append the specific grade to "Fuel Grade"\n                                                  premium = `Fuel Grade: ${specificGrade}`;\n                                                }\n                                                \n                                                // Only set the current/total numbers if we have a specific grade\n                                                if (hasSpecificGrade) {\n                                                  premiumCurrent = parseInt(premiumMatch[2]);\n                                                  premiumTotal = parseInt(premiumMatch[3]);\n                                                } else {\n                                                  // Reset to defaults when no specific grade is being processed\n                                                  premiumCurrent = 0;\n                                                  premiumTotal = 0;\n                                                }\n                                                \n                                                // Log for debugging\n                                                // console.log(`Detected fuel grade: "${premium}" from "${premiumMatch[1]}" (${premiumCurrent}/${premiumTotal})`);\n                                              } \n                                              // Fallback to a simpler regex if the complex one fails\n                                              else if (job.message.match(/\b\d+\s*\/\s*\d+\b/)) {\n                                                const simpleMatch = job.message.match(/\b(\d+)\s*\/\s*(\d+)\b/);\n                                                if (simpleMatch && simpleMatch[1] && simpleMatch[2]) {\n                                                  // Look for fuel type words near the numbers\n                                                  const nearbyText = job.message.substring(\n                                                    Math.max(0, job.message.indexOf(simpleMatch[0]) - 20),\n                                                    Math.min(job.message.length, job.message.indexOf(simpleMatch[0]) + simpleMatch[0].length + 20)\n                                                  );\n                                                  \n                                                  // Check if any fuel type is mentioned nearby\n                                                  let detectedType = null;\n                                                  for (const type of fuelTypes) {\n                                                    if (type !== 'fuel type' && type !== 'fuel grade' && nearbyText.toLowerCase().includes(type)) {\n                                                      detectedType = type;\n                                                      break;\n                                                    }\n                                                  }\n                                                  \n                                                  if (detectedType) {\n                                                    premium = detectedType.charAt(0).toUpperCase() + detectedType.slice(1);\n                                                  } else {\n                                                    premium = "Fuel Grade"; // Default name if type can't be detected\n                                                  }\n                                                  \n                                                  premiumCurrent = parseInt(simpleMatch[1]);\n                                                  premiumTotal = parseInt(simpleMatch[2]);\n                                                }\n                                              }\n                                              \n                                              // Check for dispenser (improved regex)\n                                              const dispenserRegex = /(?:dispenser|pump|meter)(?:[\s#:]+)(\d+)(?:[^\d]+(\d+)|)/i;\n                                              const dispenserMatch = job.message.match(dispenserRegex);\n                                              \n                                              if (dispenserMatch && dispenserMatch[1]) {\n                                                dispenser = "Dispenser";\n                                                dispenserCurrent = parseInt(dispenserMatch[1]);\n                                                \n                                                // Always prioritize the job's dispenserCount when calculating percentage\n                                                // This ensures consistent progress indication throughout the process\n                                                if (job.dispenserCount) {\n                                                  dispenserTotal = job.dispenserCount;\n                                                } \n                                                // Fall back to parsed value if job.dispenserCount is not available\n                                                else if (dispenserMatch[2]) {\n                                                  dispenserTotal = parseInt(dispenserMatch[2]);\n                                                }\n                                                // Provide a minimum fallback value to prevent divide-by-zero errors\n                                                else {\n                                                  dispenserTotal = 1;\n                                                }\n                                                \n                                                // Extract work order ID if available to get actual dispenser labels\n                                                const workOrderId = job.url?.match(/\/work\/(\w+)/)?.[1];\n                                                if (workOrderId && dispenserDetails[`W-${workOrderId}`]) {\n                                                  const dispensersData = dispenserDetails[`W-${workOrderId}`].dispensers;\n                                                  \n                                                  // More robust dispenser index calculation\n                                                  if (dispensersData && dispensersData.length > 0) {\n                                                    // Try to find the closest matching dispenser by number\n                                                    let dispenserIndex = dispenserCurrent - 1; // Default 0-indexed position\n                                                    \n                                                    // Safety check to prevent array out of bounds\n                                                    if (dispenserIndex >= dispensersData.length) {\n                                                      // If the current dispenser number is too high, use the last dispenser\n                                                      dispenserIndex = dispensersData.length - 1;\n                                                    } else if (dispenserIndex < 0) {\n                                                      // If somehow negative, use the first dispenser\n                                                      dispenserIndex = 0;\n                                                    }\n                                                    \n                                                    const dispenserData = dispensersData[dispenserIndex];\n                                                    if (dispenserData?.title) {\n                                                      // Extract the dispenser number from the title (e.g., "1/2" from "1/2 - Regular...")\n                                                      const dispenserNumber = dispenserData.title.split(' - ')[0];\n                                                      dispenser = `Dispenser ${dispenserNumber}`;\n                                                      \n                                                      // Keep a consistent count of total dispensers\n                                                      dispenserTotal = dispensersData.length;\n                                                    }\n                                                  }\n                                                }\n                                              }\n                                            }\n                                            // Always show dispenser block if current dispenser is detected\n                                            // This ensures consistent UI even if we don't have all dispenser information yet\n                                            if (dispenserCurrent > 0 && !dispenser) {\n                                              dispenser = "Dispenser";\n                                              dispenserTotal = job.dispenserCount || 1;\n                                            }\n                                            \n                                            // Calculate percentages for progress bars\n                                            const premiumPercent = premiumTotal > 0 ? Math.round((premiumCurrent / premiumTotal) * 100) : 0;\n                                            \n                                            // For dispensers, prioritize using the job's known dispenser count for more accuracy\n                                            const authoritativeTotalForPercent = job.dispenserCount || dispenserTotal || 1;\n                                            \n                                            // Fix the percentage calculation to ensure it reaches 100% at the last dispenser\n                                            // Instead of 0% for first dispenser, calculate based on progress through the dispensers\n                                            let dispenserPercent = 0;\n                                            if (dispenserCurrent && authoritativeTotalForPercent) {\n                                              // Start at a base percentage (not 0%) for the first dispenser\n                                              // This indicates we're working on this first dispenser\n                                              if (authoritativeTotalForPercent === 1) {\n                                                // If there's only one dispenser, use percentage based on whether it's started (50%) or not\n                                                dispenserPercent = job.status === 'running' ? 50 : 0;\n                                              } else {\n                                                // For multiple dispensers:\n                                                // - First dispenser starts at a base percentage (not 0%)\n                                                // - Last dispenser = 100% when complete\n                                                \n                                                // Calculate as: (current-1 + progressOnCurrent) / total * 100\n                                                // Where progressOnCurrent is 0.5 (halfway) by default, but can be refined later\n                                                // This gives an even distribution across all dispensers\n                                                \n                                                // Each dispenser gets an equal portion of the 100%\n                                                const percentPerDispenser = 100 / authoritativeTotalForPercent;\n                                                \n                                                // Calculate completed dispensers (current-1)\n                                                const completedProgress = (dispenserCurrent - 1) * percentPerDispenser;\n                                                \n                                                // Add half of the current dispenser's percentage (assuming work is ~halfway through)\n                                                const currentDispenserProgress = percentPerDispenser * 0.5;\n                                                \n                                                // Total progress is the sum of the two\n                                                dispenserPercent = Math.round(completedProgress + currentDispenserProgress);\n                                                \n                                                // Cap at 100% to prevent overflow\n                                                dispenserPercent = Math.min(dispenserPercent, 100);\n                                              }\n                                            }\n                                            \n                                            // The old calculation was:\n                                            // const dispenserPercent = Math.round((dispenserCurrent / authoritativeTotalForPercent) * 100);\n                                            \n                                            // Determine color based on progress\n                                            const getPremiumColor = () => {\n                                              if (premiumPercent < 30) return 'bg-blue-400';\n                                              if (premiumPercent < 70) return 'bg-blue-500';\n                                              return 'bg-blue-600';\n                                            };\n                                            \n                                            const getDispenserColor = () => {\n                                              if (dispenserPercent < 30) return 'bg-amber-400';\n                                              if (dispenserPercent < 70) return 'bg-amber-500';\n                                              return 'bg-amber-600';\n                                            };\n                                            \n                                            // Pulse animation class for running jobs\n                                            const pulseAnimation = job.status === 'running' ? 'animate-pulse' : '';\n                                            \n                                            // Fixed height container for progress bars\n                                            return (\n                                              <div className="flex flex-col h-24 justify-center">\n                                                {/* Always render the dispenser block - with placeholder when no data yet */}\n                                                <div className="relative h-8 mb-3">\n                                                  <div className="flex items-center justify-between mb-1">\n                                                    <span className="flex items-center font-medium text-amber-600 dark:text-amber-400 text-xs">\n                                                      <svg className="w-3.5 h-3.5 mr-1" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">\n                                                        <path fillRule="evenodd" d="M6 2a2 2 0 00-2 2v12a2 2 0 002 2h8a2 2 0 002-2V4a2 2 0 00-2-2H6zm1 2a1 1 0 000 2h6a1 1 0 100-2H7zm6 7a1 1 0 011 1v3a1 1 0 11-2 0v-3a1 1 0 011-1zm-3 3a1 1 0 000 2h.01a1 1 0 100-2H10zm-4 1a1 1 0 011-1h.01a1 1 0 110 2H7a1 1 0 01-1-1zm1-4a1 1 0 000 2h.01a1 1 0 000-2H7zm2 1a1 1 0 011-1h.01a1 1 0 110 2H10a1 1 0 01-1-1zm4-4a1 1 0 100 2h.01a1 1 0 100-2H13zM9 9a1 1 0 011-1h.01a1 1 0 110 2H10a1 1 0 01-1-1zM7 8a1 1 0 000 2h.01a1 1 0 000-2H7z" clipRule="evenodd" />\n                                                      </svg>\n                                                      <span className="font-semibold">{dispenser || "Dispenser"}</span>\n                                                    </span>\n                                                    <div className="flex items-center space-x-2">\n                                                      {dispenserCurrent > 0 ? (\n                                                        <span className="text-xs font-mono bg-gray-100 dark:bg-gray-700 px-1.5 py-0.5 rounded text-gray-700 dark:text-gray-300">\n                                                          {(dispenser && dispenser !== "Dispenser") ? \n                                                            dispenser.replace("Dispenser ", "") : `#${dispenserCurrent}`}\n                                                        </span>\n                                                      ) : (\n                                                        <span className="text-xs font-mono bg-gray-100 dark:bg-gray-700 px-1.5 py-0.5 rounded text-gray-500 dark:text-gray-500">\n                                                          Loading...\n                                                        </span>\n                                                      )}\n                                                      <span className={`text-xs font-mono px-1.5 py-0.5 rounded-full \n                                                        ${dispenserCurrent > 0 ? \n                                                          (dispenserPercent >= 75 ? 'bg-green-100 text-green-700 dark:bg-green-800/40 dark:text-green-400' : \n                                                          dispenserPercent >= 25 ? 'bg-amber-100 text-amber-700 dark:bg-amber-800/40 dark:text-amber-400' : \n                                                          'bg-gray-100 text-gray-700 dark:bg-gray-800/40 dark:text-gray-400') :\n                                                          'bg-gray-100 text-gray-500 dark:bg-gray-800/40 dark:text-gray-500'}`}>\n                                                            {dispenserCurrent > 0 ? `${dispenserPercent}%` : 'Waiting...'}\n                                                        </span>\n                                                    </div>\n                                                  </div>\n                                                  <div className="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2 overflow-hidden">\n                                                    {dispenserCurrent > 0 ? (\n                                                      <div \n                                                        className={`${getDispenserColor()} h-2 rounded-full transition-all duration-500 ease-in-out ${pulseAnimation}`}\n                                                        style={{ width: `${dispenserPercent}%` }}\n                                                      ></div>\n                                                    ) : (\n                                                      <div className="flex w-full h-2 animate-pulse">\n                                                        <div className="w-1/5 h-2 bg-amber-300 dark:bg-amber-700/50 rounded-l-full"></div>\n                                                        <div className="w-4/5 h-2 bg-gray-300 dark:bg-gray-600/50 rounded-r-full"></div>\n                                                      </div>\n                                                    )}\n                                                  </div>\n                                                </div>\n                                                \n                                                {/* Always render the premium block with conditional visibility */}\n                                                <div className={`relative ${premium ? 'opacity-100' : 'opacity-0'} h-8`}>\n                                                  <div className="flex items-center justify-between mb-1">\n                                                    <span className="flex items-center font-medium text-blue-600 dark:text-blue-400 text-xs">\n                                                      <svg className="w-3.5 h-3.5 mr-1" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">\n                                                        <path fillRule="evenodd" d="M5 17a2 2 0 01-2-2V5a2 2 0 012-2h10a2 2 0 012 2v10a2 2 0 01-2 2H5zm12-10a1 1 0 00-1-1h-3a1 1 0 00-1 1v6a1 1 0 001 1h3a1 1 0 001-1V7z" clipRule="evenodd" />\n                                                        </svg>\n                                                        <span className="font-semibold">{premium}</span>\n                                                      </span>\n                                                      <div className="flex items-center space-x-2">\n                                                        <span className="text-xs font-mono bg-gray-100 dark:bg-gray-700 px-1.5 py-0.5 rounded text-gray-700 dark:text-gray-300">\n                                                          {/* Only show numbers if we have a specific grade, otherwise show a placeholder */}\n                                                          {premium && premium !== "Fuel Grade" ? \n                                                            `${premiumCurrent}/${premiumTotal}` : \n                                                            "Ready"\n                                                          }\n                                                        </span>\n                                                        <span className={`text-xs font-mono px-1.5 py-0.5 rounded-full \n                                                          ${premiumPercent >= 75 ? 'bg-green-100 text-green-700 dark:bg-green-800/40 dark:text-green-400' : \n                                                            premiumPercent >= 25 ? 'bg-blue-100 text-blue-700 dark:bg-blue-800/40 dark:text-blue-400' : \n                                                            'bg-gray-100 text-gray-700 dark:bg-gray-800/40 dark:text-gray-400'}`}>\n                                                          {/* Only show percentage if we have a specific grade */}\n                                                          {premium && premium !== "Fuel Grade" ? \n                                                            `${premiumPercent}%` : \n                                                            "Waiting..."\n                                                          }\n                                                        </span>\n                                                      </div>\n                                                    </div>\n                                                    <div className="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2 overflow-hidden">\n                                                      <div \n                                                        className={`${getPremiumColor()} h-2 rounded-full transition-all duration-500 ease-in-out ${pulseAnimation}`}\n                                                        style={{ width: `${premiumPercent}%` }}\n                                                      ></div>\n                                                    </div>\n                                                  </div>\n                                                  \n                                                  {!premium && !dispenser && (\n                                                    <div className="flex h-full items-center">\n                                                      <span>{job.message}</span>\n                                                    </div>\n                                                  )}\n                                                </div>\n                                              );\n                                            })()\n                                          : job.status === 'error'\n                                            ? <span className="text-red-500 dark:text-red-400">{job.message}</span>\n                                            : <span>{job.message}</span>\n                                      }\n                                    </div>\n                                  )}\n                                </td>\n                                <td className="px-4 py-3 text-sm">\n                                  {/* Modified for new line display */}\n                                  <div className="flex flex-col">\n                                    <div className="font-medium text-gray-700 dark:text-gray-300 flex items-center mb-1">\n                                      <div className={`w-2 h-2 rounded-full ${\n                                        job.status === 'running' ? 'bg-primary-500 animate-pulse' :\n                                        job.status === 'completed' ? 'bg-green-500' :\n                                        job.status === 'error' ? 'bg-red-500' : 'bg-gray-400'\n                                      } mr-2 flex-shrink-0`}></div>\n                                      {cleanStoreName}\n                                    </div>\n                                    <div className="text-xs text-gray-500 dark:text-gray-400 flex items-center mb-1 ml-4">\n                                      <span className="font-mono bg-gray-100 dark:bg-gray-700 px-1.5 py-0.5 rounded">#{visitInfo.visitNumber}</span>\n                                    </div>\n                                    {visitInfo.dispenserCount > 0 && (\n                                      <div className="text-xs text-gray-500 dark:text-gray-400 flex items-center ml-4">\n                                        <span className="bg-amber-100 dark:bg-amber-900/30 text-amber-700 dark:text-amber-400 rounded-full px-2 py-0.5 text-xs flex items-center shadow-sm">\n                                          <svg className="w-3 h-3 mr-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">\n                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 3v4M3 5h4M6 17v4m-2-2h4m5-16l2.286 6.857L21 12l-5.714 2.143L13 21l-2.286-6.857L5 12l5.714-2.143L13 3z" />\n                                          </svg>\n                                          <span className="font-medium">Dispensers:</span>\n                                          <span className="ml-1 bg-amber-200 dark:bg-amber-800 text-amber-800 dark:text-amber-300 rounded px-1.5 font-semibold">{visitInfo.dispenserCount}</span>\n                                        </span>\n                                      </div>\n                                    )}\n                                  </div>\n                                </td>\n                                <td className="px-4 py-3 text-sm text-gray-500 dark:text-gray-400">\n                                  {/* Container for timestamp elements */}\n                                  <div className="flex flex-col space-y-1">\n                                    <div className="flex items-center space-x-2">\n                                      <div className="flex-shrink-0 w-8 h-8 flex items-center justify-center rounded-full bg-indigo-100 dark:bg-indigo-800/30 text-indigo-600 dark:text-indigo-400">\n                                        <FiClock className="h-4 w-4" />\n                                      </div>\n                                      <div>\n                                        <div className="font-medium text-gray-700 dark:text-gray-300">\n                                          {job.timestamp}\n                                        </div>\n                                        {job.startTime && (\n                                          <div className="flex items-center text-xs mt-0.5"> {/* Reduced margin top for tighter packing */}\n                                            <span className="inline-flex items-center bg-indigo-50 dark:bg-indigo-900/20 text-indigo-700 dark:text-indigo-400 px-2 py-0.5 rounded-md">\n                                              <svg className="w-3 h-3 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">\n                                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />\n                                              </svg>\n                                              {formatDuration(job.startTime, job.endTime)}\n                                            </span>\n                                          </div>\n                                        )}\n                                      </div>\n                                    </div>\n                                  \n                                    {job.status === 'completed' && job.startTime && job.endTime && (\n                                      <div className="flex items-center text-xs text-green-600 dark:text-green-500 bg-green-50 dark:bg-green-900/30 px-2 py-1 rounded-md self-start"> {/* Use self-start and potentially adjust padding/margin */}\n                                        <FiCheckCircle className="w-4 h-4 mr-1.5 flex-shrink-0" /> {/* Using FiCheckCircle and adjusted size */}\n                                        <span>\n                                          Completed {new Date(job.endTime).toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'})}\n                                        </span>\n                                      </div>\n                                    )}\n                                  \n                                    {job.status === 'error' && job.startTime && job.endTime && (\n                                      <div className="flex items-center text-xs text-red-600 dark:text-red-500 bg-red-50 dark:bg-red-900/30 px-2 py-1 rounded-md self-start">\n                                        <FiXCircle className="w-4 h-4 mr-1.5 flex-shrink-0" /> {/* Assuming FiXCircle exists or use another appropriate icon */}\n                                        <span>\n                                          Failed {new Date(job.endTime).toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'})}\n                                        </span>\n                                      </div>\n                                    )}\n                                  </div>\n                                </td>\n                                <td className="px-4 py-3 text-sm text-gray-500 dark:text-gray-400">\n                                  <div className="flex items-center">\n                                    {job.headless ? (\n                                      <span className="inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-300">\n                                        <svg className="w-3 h-3 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">\n                                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />\n                                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />\n                                        </svg>\n                                        Headless\n                                      </span>\n                                    ) : (\n                                      <span className="inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-blue-100 dark:bg-blue-800/40 text-blue-800 dark:text-blue-300">\n                                        <svg className="w-3 h-3 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">\n                                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />\n                                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />\n                                        </svg>\n                                        Visible\n                                      </span>\n                                    )}\n                                  </div>\n                                </td>\n                              </tr>\n                            );\n                          })}\n                          </tbody>\n                        </table>\n                      </div>\n                    </div>\n                  </div>\n                )}\n              </div>\n            )}\n\n            {activeTab === 'batch' && (\n              <div className="space-y-6">\n                {/* Visit Selection Panel - Styled like the Work Order Selection Panel */}\n                <div className="panel bg-white dark:bg-gray-800 rounded-xl shadow-lg border border-gray-200 dark:border-gray-700">\n                  <div className="panel-header">\n                    <h2 className="panel-title flex items-center space-x-2 mb-0">\n                      <FiClipboard className="text-primary-500 dark:text-primary-400" />\n                      <span>Select Work Order Visits</span>\n                    </h2>\n                  </div>\n                  \n                  <div className="mt-4">\n                    <div className="flex flex-wrap items-center justify-between mb-4 gap-3">\n                      <div className="flex flex-wrap items-center space-x-4">\n                        <div className="flex items-center space-x-2">\n                          <span className="text-sm text-gray-600 dark:text-gray-400">Group By:</span>\n                          <select\n                            className="select text-sm border border-gray-300 dark:border-gray-600 rounded-md shadow-sm py-1.5 px-3 bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100 focus:outline-none focus:ring-1 focus:ring-primary-500 focus:border-primary-500"\n                            value={groupBy}\n                            onChange={(e) => setGroupBy(e.target.value)}\n                          >\n                            <option value="none">No Grouping</option>\n                            <option value="date">Visit Date</option>\n                            <option value="week">Week</option>\n                          </select>\n                        </div>\n                      </div>\n                      \n                      <div className="flex space-x-2">\n                        <button\n                          className="btn-sm bg-primary-50 hover:bg-primary-100 text-primary-600 dark:bg-primary-900/20 dark:hover:bg-primary-900/30 dark:text-primary-400 rounded-md px-3 py-1.5 font-medium flex items-center space-x-1 border border-primary-200 dark:border-primary-800 transition-colors"\n                          onClick={handleSelectAll}\n                        >\n                          <FiCheck className="h-3.5 w-3.5" />\n                          <span>Select All</span>\n                        </button>\n                        <button\n                          className="btn-sm bg-gray-100 hover:bg-gray-200 text-gray-700 dark:bg-gray-700 dark:hover:bg-gray-600 dark:text-gray-300 rounded-md px-3 py-1.5 font-medium flex items-center space-x-1 border border-gray-200 dark:border-gray-600 transition-colors"\n                          onClick={handleDeselectAll}\n                        >\n                          <FiX className="h-3.5 w-3.5" />\n                          <span>Deselect All</span>\n                        </button>\n                      </div>\n                    </div>\n                    \n                    <div className="border rounded-lg overflow-hidden border-gray-200 dark:border-gray-700 shadow-sm">\n                      <div className="flex items-center justify-between px-4 py-3 bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700">\n                        <div className="flex items-center">\n                          <h3 className="text-md font-semibold text-gray-700 dark:text-gray-300">\n                            Available Visits\n                          </h3>\n                          <span className="ml-2 inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-300">\n                            {previewData.length} visits\n                          </span>\n                        </div>\n                        <div className="text-sm text-gray-600 dark:text-gray-400 flex items-center">\n                          <span className="bg-primary-100 text-primary-800 dark:bg-primary-900/30 dark:text-primary-400 text-xs rounded-full px-2 py-0.5">\n                            {selectedVisits.length} selected\n                          </span>\n                        </div>\n                      </div>\n                      \n                      {/* Visit List - Increased max-height to show more rows */}\n                      <div className="max-h-[400px] overflow-y-auto bg-white dark:bg-gray-800">\n                        {isLoading || previewData.length === 0 ? (\n                          <div className="p-8 flex flex-col items-center justify-center text-center">\n                            <div className="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-blue-500 mb-4"></div>\n                            <div className="text-gray-500 dark:text-gray-400">Loading visit data...</div>\n                          </div>\n                        ) : (\n                          renderGroupedVisits()\n                        )}\n                      </div>\n                    </div>\n                  </div>\n                </div>\n                \n                {/* Batch Processing Panel */}\n                <div className="panel bg-white dark:bg-gray-800 rounded-xl shadow-lg border border-gray-200 dark:border-gray-700">\n                  <div className="panel-header">\n                    <h2 className="panel-title flex items-center space-x-2 mb-0">\n                      <FiUpload className="text-primary-500 dark:text-primary-400" />\n                      <span>Batch Processing</span>\n                    </h2>\n                    \n                    {batchJobId && (\n                      <div className="badge badge-primary py-1 px-2 flex items-center">\n                        <FiInfo className="mr-1 h-3.5 w-3.5" />\n                        <span>Job ID: {batchJobId}</span>\n                      </div>\n                    )}\n                  </div>\n                  \n                  <div className="mt-4 space-y-4">\n                    <div className="bg-gray-50 dark:bg-gray-800/80 rounded-lg p-4 border border-gray-200 dark:border-gray-700">\n                      <h3 className="text-sm font-medium text-gray-800 dark:text-gray-200 mb-3">Processing Options</h3>\n                      \n                      <div className="flex items-center mb-3">\n                        <label className="flex items-center cursor-pointer">\n                          <input\n                            type="checkbox"\n                            className="form-checkbox h-5 w-5 text-primary-600 rounded border-gray-300 dark:border-gray-600 focus:ring-primary-500"\n                            checked={!isHeadless}\n                            onChange={() => setIsHeadless(!isHeadless)}\n                          />\n                          <span className="ml-2 text-gray-700 dark:text-gray-300">Show browser during automation (debug mode)</span>\n                        </label>\n                      </div>\n                      \n                      <div className="flex items-center">\n                        <label className="flex items-center cursor-pointer">\n                          <input\n                            type="checkbox"\n                            className="form-checkbox h-5 w-5 text-primary-600 rounded border-gray-300 dark:border-gray-600 focus:ring-primary-500"\n                            checked={resumeBatch}\n                            onChange={() => setResumeBatch(!resumeBatch)}\n                            disabled={!lastFailedBatch}\n                          />\n                          <span className="ml-2 text-gray-700 dark:text-gray-300">\n                            Resume from last failed batch\n                            {!lastFailedBatch && (\n                              <span className="text-gray-500 dark:text-gray-400 text-xs ml-2">(No failed batches found)</span>\n                            )}\n                          </span>\n                        </label>\n                      </div>\n                    </div>\n                    \n                    <div className="flex justify-between items-center">\n                      <div>\n                        {selectedVisits.length > 0 && (\n                          <div className="text-sm text-gray-600 dark:text-gray-400">\n                            <span className="font-medium">{selectedVisits.length}</span> visits selected for processing\n                          </div>\n                        )}\n                      </div>\n                      \n                      <div className="flex space-x-3">\n                        <button\n                          className="btn bg-gray-200 hover:bg-gray-300 text-gray-700 dark:bg-gray-700 dark:hover:bg-gray-600 dark:text-gray-300 flex items-center space-x-2"\n                          onClick={handlePreviewBatch}\n                        >\n                          <FiRefreshCw className="h-4 w-4" />\n                          <span>Refresh Data</span>\n                        </button>\n                        \n                        <button\n                          className="btn btn-primary flex items-center space-x-2"\n                          onClick={() => {\n                            // Handle batch processing\n                            if (selectedVisits.length > 0) {\n                              handleBatchProcess();\n                            } else {\n                              addToast('warning', 'Please select at least one visit to process');\n                            }\n                          }}\n                          disabled={isProcessing || selectedVisits.length === 0}\n                        >\n                          <FiPlay className="h-4 w-4" />\n                          <span>Process {selectedVisits.length} Visit{selectedVisits.length !== 1 ? 's' : ''}</span>\n                        </button>\n                      </div>\n                    </div>\n                  </div>\n                </div>\n                \n                {/* Batch History Panel */}\n                {batchJobs.length > 0 && (\n                  <div className="panel bg-white dark:bg-gray-800 rounded-xl shadow-lg border border-gray-200 dark:border-gray-700">\n                    <div className="panel-header">\n                      <h2 className="panel-title flex items-center space-x-2 mb-0">\n                        <FiClock className="text-primary-500 dark:text-primary-400" />\n                        <span>Batch Processing History</span>\n                      </h2>\n                    </div>\n                    \n                    <div className="mt-4">\n                      <div className="overflow-hidden rounded-lg border border-gray-200 dark:border-gray-700">\n                        <table className="min-w-full divide-y divide-gray-200 dark:divide-gray-700">\n                          <thead className="bg-gray-50 dark:bg-gray-800">\n                            <tr>\n                              <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Timestamp</th>\n                              <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Status</th>\n                              <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Progress</th>\n                              <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">Message</th>\n                            </tr>\n                          </thead>\n                          <tbody className="bg-white dark:bg-gray-800 divide-y divide-gray-200 dark:divide-gray-700">\n                            {batchJobs.map((job, index) => (\n                              <tr \n                                key={index}\n                                className={`hover:bg-gray-50 dark:hover:bg-gray-700/50\n                                  ${job.status === 'running' ? 'bg-primary-50 dark:bg-primary-900/20' : \n                                    job.status === 'completed' ? 'bg-green-50 dark:bg-green-900/20' : \n                                    job.status === 'error' ? 'bg-red-50 dark:bg-red-900/20' : ''\n                                  }\n                                `}\n                              >\n                                <td className="px-4 py-3 whitespace-nowrap text-sm text-gray-700 dark:text-gray-300">{job.timestamp}</td>\n                                <td className="px-4 py-3 whitespace-nowrap">\n                                  <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium\n                                    ${job.status === 'running' ? 'bg-primary-100 text-primary-800 dark:bg-primary-900/30 dark:text-primary-400' :\n                                      job.status === 'completed' ? 'bg-green-100 text-green-800 dark:bg-green-900/30 dark:text-green-400' :\n                                      job.status === 'error' ? 'bg-red-100 text-red-800 dark:bg-red-900/30 dark:text-red-400' :\n                                      'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300'\n                                    }\n                                  `}>\n                                    {job.status}\n                                  </span>\n                                </td>\n                                <td className="px-4 py-3 whitespace-nowrap">\n                                  <div className="flex items-center">\n                                    <div className="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2.5 mr-2 max-w-[100px]">\n                                      <div \n                                        className={`h-2.5 rounded-full ${\n                                          job.status === 'completed' ? 'bg-green-500' :\n                                          job.status === 'running' ? 'bg-primary-500' :\n                                          job.status === 'error' ? 'bg-red-500' : 'bg-gray-500'\n                                        } ${job.status === 'running' ? 'animate-pulse' : ''}`}\n                                        style={{ width: `${job.completedVisits && job.totalVisits ? Math.round((job.completedVisits / job.totalVisits) * 100) : 0}%` }}\n                                      ></div>\n                                    </div>\n                                    <span className="text-xs text-gray-700 dark:text-gray-300">\n                                      {job.completedVisits || 0}/{job.totalVisits || 0}\n                                    </span>\n                                  </div>\n                                </td>\n                                <td className="px-4 py-3 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400">{job.message}</td>\n                              </tr>\n                            ))}\n                          </tbody>\n                        </table>\n                      </div>\n                    </div>\n                  </div>\n                )}\n              </div>\n            )}\n          </div>\n        </div>\n      </div>\n    </div>\n    </>\n  );\n};\n\nexport default FormPrep; \n\n\n\n\n
