# Technical Specifications

## Overview
This document details technical specifications, patterns, and implementation guidelines for the project.

## Table of Contents
1. [Technology Stack](#technology-stack)
2. [Development Patterns](#development-patterns)
3. [Code Standards](#code-standards)
4. [Testing Strategy](#testing-strategy)
5. [Build & Deployment](#build--deployment)

## Technology Stack
### System Requirements
- Node.js v16 or higher
- npm v6 or higher
- Windows, macOS, or Linux operating system
- Minimum 4GB RAM recommended
- 500MB free disk space

### Core Technologies
- Electron for desktop application
- React with TypeScript for frontend
- Express.js for backend server
- Playwright for browser automation
- Vite for development and building

## Development Patterns
* Design patterns
* Architectural patterns
* Code organization
* Best practices

### ES Module Support
The application uses ES Modules throughout the codebase, as specified by `"type": "module"` in package.json. This provides several benefits:
- Modern JavaScript module system with static imports
- Better encapsulation and dependency management
- Native async/await support
- Standardized import/export syntax

When working with Node.js scripts, especially those executed as child processes, ensure proper ES module support:
1. Node scripts should use ES module import/export syntax (`import` and `export` statements)
2. Avoid using CommonJS `require()` statements in ES module contexts
3. When spawning Node.js processes from the server, use the following flags for ES module support:
   ```javascript
   const args = [
     '--experimental-modules',
     '--es-module-specifier-resolution=node',
     'scripts/yourScript.js'
   ];
   
   const process = spawn('node', args, {
     env: { 
       ...global.process.env, 
       NODE_ENV: 'production',
       NODE_OPTIONS: '--experimental-modules --es-module-specifier-resolution=node'
     }
   });
   ```
4. For file path resolution in ES modules, use the pattern:
   ```javascript
   import { fileURLToPath } from 'url';
   import { dirname } from 'path';
   
   const __filename = fileURLToPath(import.meta.url);
   const __dirname = dirname(__filename);
   ```

### Server Architecture
The backend server is organized into the following structure:

- `config/`: Configuration files and environment settings
- `controllers/`: Application controllers for handling business logic
- `routes/`: Express route definitions
- `services/`: Service layer for business logic
- `utils/`: Utility functions and helpers

#### Server Startup Options
The server can be started in several ways:

1. **Development Mode with Auto-reload**:
```bash
npm run dev
```

2. **Production Mode**:
```bash
npm start
```

3. **Full Application (Recommended)**:
```bash
npm run electron:dev:start
```
This command starts:
- The backend server
- Frontend development server
- Electron desktop application
- Handles process cleanup and port management

4. **Alternative Startup Options**:
- `npm run electron:dev`: Start without process management
- `npm run electron:start`: Start only the Electron app
- `npm run start`: Start only the frontend and server

#### API Endpoints
The server provides the following key endpoints:

##### Work Order Scraping
- `GET /api/status`: Get the current status of work order scraping
- `POST /api/scrape`: Start a work order scraping job

##### Dispenser Scraping
- `GET /api/dispenser-status`: Get the current status of dispenser scraping
- `POST /api/dispenser-scrape`: Start a dispenser scraping job

### User Management System
The application supports multiple user accounts with user-specific data storage. This allows multiple Fossa users to share the same installation.

#### Key Components

1. **User Data Structure**
   - Users are stored in `data/users.json`
   - Each user has a unique ID, email, password, and display label
   - User data is stored in user-specific directories: `data/users/<user-id>/`

2. **Active User Management**
   - Only one user can be active at a time
   - The active user ID is stored in `data/settings.json`
   - The active user's credentials are loaded into the server environment variables
   - User switching is handled through a robust process:
     - Frontend calls `setActiveUser` API with the new user ID
     - Backend updates `settings.json` with the new active user
     - Application is reloaded using Electron's `reloadApp` function
     - On reload, the new user's data is loaded and displayed

3. **User-Specific Files**
   - Each user has their own:
     - `scraped_content.json` - Work order data
     - `dispenser_store.json` - Dispenser information
     - `completed_jobs.json` - Completed work orders
     - `prover_preferences.json` - Prover preferences
     - `email_settings.json` - Email notification settings
     - `pushover_settings.json` - Pushover notification settings

4. **User Interface**
   - The active user is displayed in the sidebar with a dropdown menu
   - Users can be switched directly from the sidebar dropdown
   - The Settings page provides additional user management options
   - Switching users updates all displayed data and triggers a reload
   - Prover preferences interface provides user-specific controls for:
     - Viewing current prover information
     - Rescraping prover data from Work Fossa
     - Setting priorities for each prover (1-3)
     - Configuring preferred fuel types per prover
     - Saving user-specific preferences

#### Implementation Details

1. **User Storage Functions** (in `server/utils/userManager.js`)
   - `getActiveUser()` - Returns the ID of the active user
   - `setActiveUser(userId)` - Sets the active user and updates settings.json
   - `resolveUserFilePath(relativePath)` - Resolves file paths to user-specific locations
   - `updateUserLastUsed(userId)` - Updates the last used timestamp for a user
   - `getUserCredentials(userId)` - Retrieves stored credentials for a user

2. **Frontend User Management** (in `src/App.tsx`)
   - `handleUserSwitch(userId)` - Handles user switching process:
     - Calls `setActiveUser` API
     - Updates local state with new user
     - Stores target user label in localStorage
     - Triggers app reload via Electron API or browser fallback
   - User dropdown in sidebar for quick switching
   - Active user display with visual indicators

3. **API Endpoints** (in `server/routes/users.js`)
   - `GET /api/users` - Lists all users
   - `GET /api/users/active` - Gets the active user
   - `POST /api/users/active` - Sets the active user
   - `POST /api/users` - Creates or updates a user
   - `DELETE /api/users/:id` - Deletes a user

4. **Electron Integration**
   - `reloadApp` function in preload script for proper app reload
   - IPC handler in main process for window reload
   - Fallback to browser reload if Electron API unavailable

5. **Data Migration**
   - General migration: `scripts/migrate_user_data.js` migrates global data to user-specific directories
   - Bruce Hunt migration: `scripts/migrate_bruce_data.js` creates and sets up Bruce Hunt's account
   - These scripts ensure backward compatibility with older versions

6. **User-Specific Data Loading**
   - All data loading is performed through API endpoints that utilize user-specific paths
   - Frontend components load data via API calls rather than direct file access
   - The backend resolves file paths to the active user's directory using `resolveUserFilePath()`
   - Key API endpoints supporting user-specific data:
     - `GET /api/work-orders` - Gets work orders for the active user
     - `GET /api/dispensers` - Gets dispenser data for the active user
     - `GET /api/prover-preferences` - Gets prover preferences for the active user
     - `GET /api/last-scraped` - Gets the last scrape time for the active user
     - `POST /api/scrape` - Starts a scrape job for the active user
     - `POST /api/dispenser-scrape` - Starts a dispenser scrape job for the active user

7. **User Context Persistence**
   - The active user context is persisted across application restarts
   - Data shown in the UI always reflects the active user's data
   - User switching causes all data to be reloaded for the new active user
   - Components like the "Last Updated" time in the Data Tools section show user-specific timestamps

8. **File Structure**
   Each user has their own directory structure in `data/users/<user-id>/`:
   ```
   data/
   ├── users/
   │   ├── <user-id-1>/
   │   │   ├── scraped_content.json       # User's work order data
   │   │   ├── dispenser_store.json       # User's dispenser data
   │   │   ├── metadata.json              # User's metadata
   │   │   ├── prover_preferences.json    # User's prover preferences
   │   │   ├── archive/                   # User's archive directory
   │   │   └── changes_archive/           # User's changes archive
   │   │
   │   └── <user-id-2>/
   │       └── ...
   │
   ├── settings.json                     # Global settings including activeUserId
   └── users.json                        # List of all users
   ```

#### Migration Process
The migration process for Bruce Hunt's account follows these steps:
1. Create a user ID by hashing the email address
2. Create user directory structure in `data/users/<user-id>/`
3. Add user record to `data/users.json` with appropriate credentials
4. Copy and migrate prover preferences to user directory
5. Copy and migrate email settings to user directory
6. Copy and migrate pushover settings to user directory
7. Set the active user to Bruce Hunt's account
8. Update timestamps and metadata for all migrated files

#### User Management API
```typescript
// User interface
interface User {
  id: string;
  email: string;
  label: string;
  lastUsed: string;
  isActive?: boolean;
}

// User service functions
export const getUsers = async (): Promise<User[]>;
export const getActiveUser = async (): Promise<User | null>;
export const setActiveUser = async (userId: string): Promise<User>;
export const addUser = async (email: string, password: string, label?: string): Promise<string>;
export const updateUserLabel = async (userId: string, label: string): Promise<void>;
export const deleteUser = async (userId: string): Promise<void>;
```

### Scripts Directory
The `scripts/` directory contains automation scripts and utilities for the Fossa Monitor application.

#### Directory Structure
- `scrapers/`: Web scraping scripts for Fossa
  - `dispenserScrape.js`: Script for scraping dispenser information
  - `workOrderScrape.js`: Script for scraping work order information
  
- `email/`: Email notification functionality
  - `emailService.js`: Service for sending email notifications
  
- `utils/`: Utility scripts and shared functionality
  - `common.js`: Common utility functions
  - `dataManager.js`: Data management utilities
  - `login.js`: Functions for authenticating with Fossa
  - `scheduleComparator.js`: Compares schedule changes
  
- `tests/`: Test scripts
  - Contains test scripts for various components

#### Running Scripts
Most scripts can be run directly with Node:
```bash
node scripts/scrapers/workOrderScrape.js
```

However, it's generally recommended to use the server API to run scripts as it provides:
- Progress tracking
- Error handling
- Better process management
- Integration with the main application

### Form Automation System
The form automation system, implemented using React, Electron, and Playwright, handles automated form filling. For a detailed overview of its component structure (React Frontend, IPC Communication, Browser Automation Engine, Status Monitoring), please refer to the [Form Automation System section in docs/architecture.md](architecture.md#form-automation-system).

This section focuses on specific technical details pertinent to its implementation.

#### Key Interfaces
```typescript
// Form automation job interface
interface FormJob {
  url: string;
  status: 'idle' | 'running' | 'completed' | 'error';
  message?: string;
  timestamp?: string;
  headless: boolean;
  storeName?: string;
  visitNumber?: string;
  dispenserCount?: number;
  _statusChanged?: boolean;
  _completed?: boolean;
  _error?: boolean;
}

// Form automation status interface
interface FormAutomationStatus {
  status: 'idle' | 'running' | 'completed' | 'error';
  message: string;
}
```

#### Polling Implementation
The system uses React's `useEffect` for polling job status. Here's an illustrative example of the polling logic:

```typescript
useEffect(() => {
  let interval: NodeJS.Timeout;
  
  if (polling && batchJobId) {
    interval = setInterval(async () => {
      try {
        const statusData = await getBatchAutomationStatus();
        
        // Update the job with latest status
        setBatchJobs(prev => 
          prev.map(job => {
            if (job.status === 'running') {
              return { 
                ...job,
                status: statusData.status,
                totalVisits: statusData.totalVisits,
                completedVisits: statusData.completedVisits,
                message: statusData.message
              };
            }
            return job;
          })
        );
        
        // Stop polling when job is no longer running
        if (statusData.status !== 'running') {
          setPolling(null);
          setBatchJobId(null);
        }
      } catch (error) {
        console.error('Error polling for batch job status:', error);
      }
    }, 2000); // Poll every 2 seconds
  }
  
  return () => {
    if (interval) {
      clearInterval(interval);
    }
  };
}, [polling, batchJobId]);
```

#### Supported Form Types
- **AccuMeasure Forms**: Used with service codes 2861, 2862, and 3002
- **Open Neck Prover Forms**: Used with service code 3146

#### Service Code Meanings
| Service Code | Form Type | Description |
|--------------|-----------|-------------|
| 2861 | AccuMeasure | All Dispensers - Uses all dispensers and adds proper prover selection |
| 2862 | AccuMeasure | Specific Dispensers - Extracts specific dispensers from instructions |
| 3002 | AccuMeasure | All Dispensers - Same behavior as 2861 |
| 3146 | Open Neck Prover | Uses Open Neck Prover forms instead of AccuMeasure |

### Toast Notification System
The toast notification system provides non-intrusive alerts to the user. For a detailed overview of its component structure (`ToastContext`, `ToastComponent`), please refer to the [Toast Notification System section in docs/architecture.md](architecture.md#toast-notification-system).

This section focuses on the technical implementation details, such as the `useToastNotification` hook and its usage.

#### `useToastNotification` Hook
The `src/hooks/useToastNotification.ts` hook provides a convenient API for components to create and manage toasts. It includes standardized message formats and customization options.

```typescript
// Basic usage example
import { useToastNotification } from '../hooks/useToastNotification';

function MyComponent() {
  const toast = useToastNotification();
  
  // Show a success notification
  const handleSuccess = () => {
    toast.showSuccess('Operation completed successfully!');
  };
  
  // Show an error notification
  const handleError = () => {
    toast.showError('An error occurred. Please try again.');
  };
}
```

#### Available Methods
- `showToast(type, message, options?)` - Generic toast notification
- `showSuccess(message, options?)` - Green success notification
- `showError(message, options?)` - Red error notification
- `showInfo(message, options?)` - Blue informational notification
- `showWarning(message, options?)` - Yellow warning notification

#### Standardized Notifications
The hook provides standardized notifications for common operations:
- `notifyActionStarted(action, options?)` - Notify when an action starts
- `notifyActionCompleted(action, options?)` - Notify when an action completes
- `notifyActionFailed(action, error, options?)` - Notify when an action fails
- `notifyDataLoaded(itemType, count, options?)` - Notify when data is loaded
- `notifyFilterApplied(filter, count, options?)` - Notify when filters are applied
- `notifyNavigated(destination, options?)` - Notify when navigation occurs

#### Customization Options
```typescript
interface ToastOptions {
  duration?: number;  // Duration in milliseconds (default: 5000)
  preventDuplicates?: boolean;  // Prevent duplicate toasts (default: true)
  position?: 'top-right' | 'top-left' | 'bottom-right' | 'bottom-left' | 'top-center' | 'bottom-center';  // Toast position
}
```

#### Toast Types and Styling
Each toast type has its own styling (Success: Green, Error: Red, etc.) and all toasts support dark mode, backdrop blur, animations, responsive design, and accessibility. For more details on visual aspects, refer to the architectural documentation.

### Automated Testing
The application includes a comprehensive suite of tests, organized in the following structure:

#### Test Organization
```
tests/
├── automation/             # Tests for automation features
│   ├── test-change-trigger.js       # Tests for change triggering
│   ├── test-simulate-changes.js     # Tests for simulating changes
│   └── debug-automation.js          # Debugging automation
│
├── notifications/          # Tests for notification features
│   ├── test-pushover-root.js        # Tests for Pushover notifications
│   ├── test-email-format.js         # Tests for email formatting
│   └── test-schedule-pushover.js    # Tests for scheduled notifications
│
├── server/                 # Tests for server functionality
├── browser/                # Tests for browser automation
```

#### Running Tests
You can run tests using the following npm commands:

- `npm run test` - Run all tests
- `npm run test:notifications` - Run only notification tests
- `npm run test:automation` - Run only automation tests

## Code Standards
* Coding style
* Naming conventions
* Documentation requirements
* Code review process

## Testing Strategy
* Unit testing
* Integration testing
* End-to-end testing
* Test coverage requirements

## Build & Deployment
### Development Workflow
Start the application in development mode:
```bash
npm run electron:dev:start
```

This will:
- Launch the backend Express server (default port 3001)
- Start the Vite dev server for the frontend
- Launch the Electron application connected to both services

### Available Scripts

#### Core Development
- `npm run electron:dev:start` - Start the application in development mode
- `npm run dev` - Start only the frontend Vite server
- `npm run server` - Start only the backend Express server
- `npm run build` - Build the frontend application
- `npm run electron:build` - Build the Electron application

#### Utilities
- `npm run backup` - Create a basic backup
- `npm run full-backup` - Create a comprehensive backup
- `npm run full-backup:encrypt` - Create an encrypted comprehensive backup
- `npm run restore` - Restore from a basic backup
- `npm run restore-full` - Restore from a comprehensive backup
- `npm run enhance-logs` - Enhance log readability
- `npm run cleanup-ports` - Fix port conflicts

#### Testing
- `

### Monitoring System
The monitoring system is implemented using Node.js, Playwright, and various notification services.

#### Key Components
1. **Automated Scraping** (`scripts/automated_scrape.js`)
   - Uses Playwright for browser automation
   - Implements scheduled scraping (every hour by default)
   - Handles login and data extraction
   - Saves data in structured JSON format

2. **Schedule Comparator** (`scripts/utils/scheduleComparator.js`)
   - Implements sophisticated change detection
   - Uses Map data structures for efficient comparison
   - Handles various types of changes:
     - Job removals
     - Job additions
     - Job replacements
     - Date changes
   - Categorizes changes by severity
   - Implements smart completion detection

3. **Notification Service** (`scripts/notifications/notificationService.js`)
   - Coordinates multiple notification channels
   - Handles notification routing and delivery
   - Implements retry logic and error handling
   - Supports test notifications

#### Key Interfaces
```typescript
// Change detection result interface
interface ScheduleChanges {
  critical: Array<{
    type: 'removed' | 'added' | 'replacement';
    jobId: string;
    store: string;
    date: string;
    // Additional fields based on change type
  }>;
  high: Array<{
    type: 'date_changed';
    jobId: string;
    store: string;
    oldDate: string;
    newDate: string;
  }>;
  medium: Array<{
    type: string;
    jobId: string;
    store: string;
    // Additional fields based on change type
  }>;
  summary: {
    removed: number;
    added: number;
    modified: number;
    swapped: number;
  };
}

// Notification result interface
interface NotificationResult {
  success: boolean;
  results: {
    email?: {
      success: boolean;
      error?: Error;
    };
    pushover?: {
      success: boolean;
      error?: Error;
    };
  };
}
```

#### Change Detection Algorithm
The system uses a sophisticated algorithm to detect and categorize schedule changes. Here's a detailed breakdown of the process:

1. **Data Preparation and Organization**
   ```javascript
   // Create maps for efficient lookup and comparison
   const currentJobs = new Map(currentSchedule.workOrders.map(job => [job.id, job]));
   const previousJobs = new Map(previousSchedule.workOrders.map(job => [job.id, job]));
   
   // Organize jobs by date for efficient date-based analysis
   const currentJobsByDate = new Map();
   const previousJobsByDate = new Map();
   
   // Populate date-based maps
   for (const job of currentSchedule.workOrders) {
     const date = job.visits.nextVisit.date;
     if (!currentJobsByDate.has(date)) {
       currentJobsByDate.set(date, []);
     }
     currentJobsByDate.get(date).push(job);
   }
   ```

2. **Change Detection Process**
   The system detects changes in the following order:

   a. **Critical Changes (Highest Priority)**
   - Jobs removed from the schedule
   - Jobs added to the schedule
   - Jobs replaced on the same day
   ```javascript
   // Check for removed jobs
   for (const [id, previousJob] of previousJobs) {
     if (!currentJobs.has(id)) {
       changes.critical.push({
         type: 'removed',
         jobId: id,
         store: previousJob.customer.storeNumber,
         storeName: previousJob.customer.name,
         dispensers: getDispenserCount(previousJob),
         date: previousJob.visits.nextVisit.date
       });
     }
   }
   
   // Check for added jobs
   for (const [id, currentJob] of currentJobs) {
     if (!previousJobs.has(id)) {
       changes.critical.push({
         type: 'added',
         jobId: id,
         store: currentJob.customer.storeNumber,
         storeName: currentJob.customer.name,
         dispensers: getDispenserCount(currentJob),
         date: currentJob.visits.nextVisit.date
       });
     }
   }
   ```

   b. **High Priority Changes**
   - Date changes for existing jobs
   - Job swaps between dates
   ```javascript
   // Check for date changes
   for (const [jobId, currentJob] of currentJobs) {
     const previousJob = previousJobs.get(jobId);
     if (previousJob) {
       const currentDate = currentJob.visits.nextVisit.date;
       const previousDate = previousJob.visits.nextVisit.date;
       
       if (currentDate !== previousDate) {
         changes.high.push({
           type: 'date_changed',
           jobId: jobId,
           store: currentJob.customer.storeNumber,
           storeName: currentJob.customer.name,
           dispensers: getDispenserCount(currentJob),
           oldDate: previousDate,
           newDate: currentDate
         });
       }
     }
   }
   ```

3. **Change Categorization**
   Changes are categorized by severity:
   - **Critical**: Jobs removed, added, or replaced on the same day
   - **High**: Date changes and job swaps
   - **Medium**: Less critical changes (e.g., minor modifications)
   - **Low**: Completed jobs (no longer reported)

4. **Change Summary Generation**
   ```javascript
   const summary = {
     removed: changes.critical.filter(c => c.type === 'removed').length,
     added: changes.critical.filter(c => c.type === 'added').length,
     modified: changes.high.filter(c => c.type === 'date_changed').length,
     swapped: changes.high.filter(c => c.type === 'swapped').length
   };
   ```

5. **User Preference Filtering**
   The system respects user preferences when detecting changes:
   ```javascript
   if (userPreferences && !shouldIncludeJob(currentJob, userPreferences)) {
     continue; // Skip this job based on user preferences
   }
   ```

6. **Change Archiving**
   Significant changes are archived for historical tracking:
   ```javascript
   if (changes.summary.removed > 0 || 
       changes.summary.added > 0 || 
       changes.summary.modified > 0 || 
       changes.summary.swapped > 0) {
     archiveChangesReport(changes, username);
   }
   ```

7. **Notification Triggering**
   Changes trigger notifications based on severity:
   ```javascript
   if (changes.critical.length > 0 || changes.high.length > 0) {
     await sendScheduleChangeNotifications(changes);
   }
   ```

#### Change Detection Frequency
The system checks for changes:
1. After each automated scrape (hourly by default)
2. After manual scrape operations
3. When explicitly requested through the API

#### Change Detection Accuracy
The system ensures accurate change detection through:
- Unique job ID tracking
- Date-based organization
- Comprehensive comparison of all job attributes
- User preference filtering
- Duplicate change prevention
- Proper error handling and logging

#### Notification Implementation
The system supports multiple notification channels:

1. **Email Notifications**
   ```javascript
   // Send email notification
   async function sendScheduleChangeEmail(changes) {
     const transporter = nodemailer.createTransport({
       // SMTP configuration...
     });
     
     const mailOptions = {
       from: process.env.EMAIL_USER,
       to: process.env.VITE_RECIPIENT_EMAIL,
       subject: 'Schedule Changes Detected',
       html: generateEmailContent(changes)
     };
     
     return transporter.sendMail(mailOptions);
   }
   ```

2. **Pushover Notifications**
   ```javascript
   // Send Pushover notification
   async function sendPushoverNotification(options) {
     const params = new URLSearchParams();
     params.append('token', process.env.PUSHOVER_APP_TOKEN);
     params.append('user', process.env.PUSHOVER_USER_KEY);
     params.append('message', options.message);
     params.append('title', options.title);
     params.append('priority', options.priority || 0);
     
     const response = await fetch('https://api.pushover.net/1/messages.json', {
       method: 'POST',
       body: params
     });
     
     return response.json();
   }
   ```

#### Scheduling
The system uses node-cron for scheduling:

```javascript
// Schedule the automation to run every hour
cron.schedule('0 * * * *', async () => {
  console.log('Starting scheduled scrape job...');
  try {
    await runAutomation();
    console.log('Scheduled scrape completed successfully');
    
    // Analyze schedule changes
    const changes = analyzeScheduleChanges();
    
    // Send notifications if changes detected
    if (changes.critical.length > 0 || changes.high.length > 0) {
      await sendScheduleChangeNotifications(changes);
    }
  } catch (error) {
    console.error('Scheduled scrape failed:', error);
  }
});
```

# Pushover Notification Technical Details

- User settings for Pushover notifications now only include which job fields to display (job ID, store number, store name, location, date, dispensers).
- Priority and sound are determined automatically by the backend:
  - Normal changes: priority 0, default sound
  - Critical changes: priority 1, 'falling' sound
  - 3+ critical changes: priority 2 (emergency), 'siren' sound
- There are no user-configurable options for priority or sound.
- The backend and API no longer accept or store priorityLevel or sound in pushover settings.

### UI State Persistence Across Reloads

The application includes a comprehensive solution for persisting UI state across page reloads, which helps maintain a seamless user experience when reloads occur due to data refreshes or user switching.

#### Key Components

1. **usePersistedState Hook** (`src/hooks/usePersistedState.ts`)
   - Core hook that wraps React's useState with localStorage/sessionStorage persistence
   - Automatically handles serialization and deserialization of state values
   - Supports both primitive values and complex objects
   - Available as `useLocalStorage` and `useSessionStorage` for different persistence scopes

2. **usePageState Hook** (`src/hooks/usePageState.ts`)
   - Higher-level hook for managing page-level state persistence
   - Automatically prefixes storage keys to prevent conflicts
   - Provides automatic cleanup and state expiration functionality
   - Organizes related state with a common namespace

3. **PersistentView Component** (`src/components/PersistentView.tsx`)
   - React component that wraps page content and provides state persistence
   - Automatically persists scroll position and other common UI state
   - Exposes a context for child components to access persistent state
   - Can be configured for different storage types and expiration times

#### Implementation Example

Here's how to integrate state persistence into a component:

```tsx
// Simple component with persisted state
import { useLocalStorage } from '../hooks/usePersistedState';

function SimpleComponent() {
  // State will persist across page reloads
  const [count, setCount] = useLocalStorage('simple-component-count', 0);
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}

// Page component with PersistentView
import PersistentView, { usePersistentViewContext } from '../components/PersistentView';

function PageComponent() {
  return (
    <PersistentView id="my-page" persistScrollPosition={true}>
      <PageContent />
    </PersistentView>
  );
}

function PageContent() {
  const { createState } = usePersistentViewContext();
  
  // These states will persist across page reloads
  const [activeTab, setActiveTab] = createState('activeTab', 'home');
  const [searchQuery, setSearchQuery] = createState('searchQuery', '');
  
  // Regular state that won't persist
  const [loading, setLoading] = useState(false);
  
  return (
    <div>
      {/* Component content */}
    </div>
  );
}
```

#### When to Use Each Approach

1. **useLocalStorage/useSessionStorage**:
   - For simple, standalone components
   - When you need direct control over storage type
   - For global state items that should persist app-wide

2. **usePageState**:
   - For complex pages with many state variables
   - When you need namespace organization
   - When you want automatic state expiration

3. **PersistentView Component**:
   - For entire page components
   - When you need scroll position persistence
   - When child components need access to persistence

#### Best Practices

1. Only persist UI state that improves user experience (tab selections, scroll positions, expanded items)
2. Don't persist sensitive data or large data sets
3. Use unique, descriptive keys for stored items
4. Use sessionStorage for temporary persistence (in-session only)
5. Use localStorage for longer-term preferences
6. Set appropriate expiration times for state that shouldn't persist indefinitely
7. Always consider a user's bandwidth and device storage limitations

#### Work Order Loading for Active User

The application correctly loads and displays work orders specific to the active user through a robust system:

1. **Data File Resolution**
   - User-specific work order data is stored in `data/users/<user-id>/scraped_content.json`
   - The `getLatestScrapeFile()` function in `dataManager.js` resolves paths based on the active user
   - It falls back gracefully with clear error messages if no active user is found

2. **API Endpoints**
   - `/api/work-orders` - Primary endpoint that retrieves the active user's work orders
   - `/api/workorders` - Secondary endpoint with similar functionality used by certain components
   - Both endpoints use proper error handling with detailed messages for various failure scenarios:
     - No active user
     - File path resolution failures
     - Missing data files
     - File access errors

3. **Work Order Loading Process**
   ```
   Home Component
     ↓ useEffect on mount
     ↓ loadData()
     ↓ getWorkOrders() API call
     ↓ Server API Endpoint
     ↓ getLatestScrapeFile() resolves for active user
     ↓ Read data and return to client
     ↓ Update state and render work orders
   ```

4. **User Switching Mechanism**
   - When a user is switched, a chain of events occurs:
     1. The `handleUserSwitch()` function updates the active user in the server by calling the `/api/users/active` endpoint
     2. The API endpoint uses `userManager.js` to update the active user in `data/settings.json` with atomic write operations
     3. Server-side caching is cleared to ensure fresh data is loaded for the new user
     4. Environment variables are updated with the new user's credentials for automated operations
     5. The active user ID is stored in localStorage for client-side persistence
     6. A custom `user-switched` event is dispatched to notify components about the change
     7. Switch target information is temporarily stored in localStorage to show success confirmation
     8. The application is reloaded via Electron API or browser refresh to completely reset state
     9. On reload, the app detects the user switch completion via localStorage flags
     10. Work orders are loaded for the newly active user through standard API calls
     11. Success notification is displayed to confirm the switch completion

5. **Event-Based Updates**
   - Components listen for the following events to trigger data reloading:
     - `user-switched` - Fired when user is changed manually
     - `storage` - Fired when localStorage changes (user ID updates)
     - `fossa-data-updated` - Fired when data is refreshed/updated

6. **Error Handling and User Feedback**
   - User-friendly toast notifications for error states
   - Detailed console logging for debugging
   - Graceful UI fallbacks when data is unavailable
   - Clear distinction between different error types:
     - No active user selected
     - Data not found for user
     - Permission/access errors
     - Parse errors in data files

7. **Implementation Details**
   - All data access functions use the active user from `userManager.js` when no user ID is explicitly provided
   - The `resolveUserFilePath()` function centralizes path resolution logic
   - User-specific data paths ensure proper isolation between user accounts
   - Events and localStorage are used for cross-component communication
   - Comprehensive logging during the switch process enables debugging of switch failures
   - Multiple verification steps ensure switch consistency across server and client
   - The implementation handles edge cases like rapid switching and network disruptions

### Notification System

The application includes a robust notification system that alerts users to important changes in their work schedules and device status. The system supports multiple notification channels with a centralized formatting approach.

#### Notification Architecture

1. **Centralized Formatting Service**
   - Located at `scripts/notifications/formatService.js`
   - Provides a single source of truth for all notification formatting
   - Standardizes date/time formats, colors, and HTML generation
   - Supports user display preferences
   - Ensures consistent appearance across all notification channels

2. **Notification Channels**
   - **Email Notifications**: HTML-formatted emails with comprehensive changes
   - **Pushover Alerts**: Real-time mobile alerts with formatted information
   - **Desktop Notifications**: In-app alerts for important changes (Electron)

3. **Notification Types**
   - **Schedule Changes**: Notifications about work schedule modifications
   - **Device Alerts**: Notifications about device status (battery, connectivity, errors)
   - **Test Notifications**: Sample notifications for testing various channels

4. **User Preferences**
   - Users can customize which information appears in notifications:
     - Job IDs
     - Store numbers and names
     - Locations
     - Dates
     - Dispenser counts
   - Each notification channel can be enabled/disabled independently
   - Priority levels and sounds can be customized for Pushover alerts

5. **Standardized Formats**
   - **Schedule Change Format**:
   ```javascript
   {
     critical: [],  // Critical changes (added/removed jobs)
     high: [],      // High priority changes (date changes, swaps)
     medium: [],    // Medium priority changes
     low: [],       // Low priority changes
     summary: {
       removed: 0,
       added: 0,
       modified: 0,
       swapped: 0
     }
   }
   ```
   
   - **Alert Format**:
   ```javascript
   {
     type: 'battery',         // battery, connectivity, error
     severity: 'critical',    // critical, high, normal
     deviceName: 'Device 1',
     location: 'Store Location',
     customer: 'Customer Name',
     manufacturer: 'Device Manufacturer',
     store: '#1234',
     storeName: 'Store Name',
     message: 'Low battery detected - 5% remaining'
   }
   ```

#### Implementation Details

1. **Notification Service**
   - `scripts/notifications/notificationService.js` coordinates all notification channels
   - `sendScheduleChangeNotifications()` - Main function for sending schedule notifications
   - `sendTestNotifications()` - Function for testing notification channels
   - Handles user filtering and preference application
   - Routes notifications to appropriate channels based on settings

2. **Email Service**
   - `scripts/notifications/emailService.js` handles all email formatting and delivery
   - Uses the centralized formatting service for consistent HTML generation
   - Respects user display preferences for content customization
   - Supports CC recipients and HTML email content

3. **Pushover Service**
   - `scripts/notifications/pushoverService.js` manages Pushover alert delivery
   - `sendPushoverScheduleChange()` - Sends schedule changes via Pushover
   - `sendAlertPushover()` - Sends device alerts via Pushover
   - Uses the centralized formatting service for HTML rendering
   - Supports priority levels based on severity
   - Automatically selects sounds based on urgency

4. **Testing UI**
   - The Settings interface includes dedicated test sections:
     - Schedule Tests - For testing schedule change notifications
     - Alert Tests - For testing device alert notifications
   - Each test section allows customizing the notification content

5. **Testing Scripts**
   - Notification system includes comprehensive test scripts:
     - `tests/notifications/test-notification-formatting.js` - Tests formatting consistency
     - `tests/automation/test-change-trigger.js` - Simulates schedule changes

For detailed information about the notification system, see the [Notification README](../scripts/notifications/README.md) and [Notification Formatting Guide](notifications/formatting-guide.md).

## Email Service Configuration

The application uses Nodemailer to send emails through Gmail's SMTP server. Due to Google's security policies, the application must use App Passwords rather than regular account passwords.

### Implementation Details

- **Email Settings**: Stored in `data/email-settings.json` (default) and `data/user-settings.json` (user-specific)
- **Main Classes**: 
  - `scripts/notifications/emailService.js`: Core email sending functionality
  - `scripts/email/emailSettings.js`: Settings management (wrapper around the notifications module)
  - `scripts/email/emailService.js`: Higher-level email services that use the core functionality

### Configuration Requirements

- Gmail account with 2-Factor Authentication enabled
- App Password generated for the application
- SMTP Configuration:
  - Host: smtp.gmail.com
  - Port: 587
  - SSL: false (using STARTTLS instead)

### Security Considerations

- App Passwords provide limited access to the Gmail account (only email sending capabilities)
- Credentials are stored in local configuration files, not hardcoded
- Environment variables can be used as fallback for credentials